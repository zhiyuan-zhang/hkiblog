{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"基于SLF4J MDC机制配合AOP实现日志的链路追踪","slug":"slf4jMDC","date":"2019-05-30T16:00:00.000Z","updated":"2019-11-08T01:30:21.215Z","comments":true,"path":"2019/05/31/slf4jMDC/","link":"","permalink":"http://yoursite.com/2019/05/31/slf4jMDC/","excerpt":"","text":"问题描述一个合格的项目必须要有日志来支撑,日志不但能记录输入输出,当系统有问题的时候我们还需要做线上问题的排查. 在一个正常的项目中日志里包含了各种各样的接口及其他无关的数据日志,那么我们如何快速定位单次请求中所有的日志呢 ? 问题分析当我们设计一个系统日志的时候 首先我们需要解决以下几个问题 哪些数据需要写进日志中 日志如何分类 按天还是按周 如何区分每次请求 请求参数及返回值需不需要打印 如何进行多环节配置 解决方案按照上面的问题我们来一个一个解决 主要思路是 AOP 负责切入每个请求及参数打印 在进入 controller 之前打印本次请求的各种参数 MDC 添加 hashCode 来做参数校验 日志使用 logback 配置 日志按天分类,每天生成一个日志 利用 thread 来区分每次请求 springProfile 来做多环境配置 aop 有两种CGLIB,JDK 都是动态代理 今天不讨论这两者的区别 我使用的是 CGLIB pom 中引入 SpringBoot 的 web 模块和使用 AOP 相关的依赖： 定义切面类，实现 web 层的日志切面 对所有的 web 请求做切面来记录日志 第一种 AOP 上 logback 的输出1234567891011121314151617181920// 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null &amp;&amp; joinPoint != null) &#123; HttpServletRequest request = attributes.getRequest(); // 记录请求内容 log.info( \"1. 对象请求的URL : \" + request.getRequestURL().toString()); log.info( \"2. 请求方法名称 : \" + request.getMethod()); log.info( \"3. 对方IP地址 : \" + request.getRemoteAddr()); log.info( \"4. 运行的java类 : \" + joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName()); try&#123; log.info(\"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); &#125;catch (Exception e)&#123; log.info(\"请求参数切点无法切入\"); &#125; &#125;else&#123; throw new CheckException(\"网络请求出错, 请清空缓存重新尝试. \"); &#125; 第二种 request.HashCode 唯一标示在获得 12log.info(request.hashCode()+ \"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); 第三种 基于 SLF4J 的 MDC 机制12MDC.put(\"THREAD_ID\", \"userId\"+ userService.getId() ); 1&lt;pattern&gt;%date [%thread] %-5level %logger&#123;80&#125; %X&#123;THREAD_ID&#125; || %msg%n&lt;/pattern&gt; 第四种 结合 HashCode 和 MDC12MDC.put(\"THREAD_ID\", \"\"+request.hashCode()); 最终效果12345678910112019-06-04 10:14:27,743 [main] INFO com.zwkj.zhxt.ZhxtApplication || Started ZhxtApplication in 48.489 seconds (JVM running for 56.375)2019-06-04 10:15:28,310 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:28,313 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:28,314 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:28,323 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:28,585 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：168 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg=='2019-06-04 10:15:30,860 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || @Around:结果是 :ResultBean com.zwkj.zhxt.controller.SysUserController.findSysUser(UserModel) use time: 25512019-06-04 10:15:30,861 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 282556454: 方法的返回值 : ResultBean(msg=success, code=0, data=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub3ciOiIxNTU5NjE0NTMwMjE2emh4dCIsImtleSI6InVzZXIxMiJ9.ae7ra7hvDSp5N6YfuGYzr8ULeq7Zr5OuC_4PbybqceY) 12345672019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：151 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg==' \\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"},{"name":"SLF4J","slug":"SLF4J","permalink":"http://yoursite.com/tags/SLF4J/"},{"name":"MDC","slug":"MDC","permalink":"http://yoursite.com/tags/MDC/"}]},{"title":"spring-boot-ioc 解析","slug":"springBootIOC","date":"2019-05-21T16:00:00.000Z","updated":"2019-11-08T01:29:08.751Z","comments":true,"path":"2019/05/22/springBootIOC/","link":"","permalink":"http://yoursite.com/2019/05/22/springBootIOC/","excerpt":"","text":"spring boot ioc 启动调用堆栈 1234567891011121314151617181920212223242526272829303132333435inject:177, InjectionMetadata$InjectedElement (org.springframework.beans.factory.annotation)inject:90, InjectionMetadata (org.springframework.beans.factory.annotation)postProcessProperties:321, CommonAnnotationBeanPostProcessor (org.springframework.context.annotation)populateBean:1395, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)doCreateBean:592, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)createBean:515, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)lambda$doGetBean$0:320, AbstractBeanFactory (org.springframework.beans.factory.support)getObject:-1, 2018260103 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$144)getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)doGetBean:318, AbstractBeanFactory (org.springframework.beans.factory.support)getBean:199, AbstractBeanFactory (org.springframework.beans.factory.support)resolveCandidate:277, DependencyDescriptor (org.springframework.beans.factory.config)doResolveDependency:1247, DefaultListableBeanFactory (org.springframework.beans.factory.support)resolveDependency:1167, DefaultListableBeanFactory (org.springframework.beans.factory.support)inject:593, AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement (org.springframework.beans.factory.annotation)inject:90, InjectionMetadata (org.springframework.beans.factory.annotation)postProcessProperties:374, AutowiredAnnotationBeanPostProcessor (org.springframework.beans.factory.annotation)populateBean:1395, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)doCreateBean:592, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)createBean:515, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)lambda$doGetBean$0:320, AbstractBeanFactory (org.springframework.beans.factory.support)getObject:-1, 2018260103 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$144)getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)doGetBean:318, AbstractBeanFactory (org.springframework.beans.factory.support)getBean:199, AbstractBeanFactory (org.springframework.beans.factory.support)preInstantiateSingletons:849, DefaultListableBeanFactory (org.springframework.beans.factory.support)finishBeanFactoryInitialization:877, AbstractApplicationContext (org.springframework.context.support)refresh:549, AbstractApplicationContext (org.springframework.context.support)refresh:142, ServletWebServerApplicationContext (org.springframework.boot.web.servlet.context)refresh:775, SpringApplication (org.springframework.boot)refreshContext:397, SpringApplication (org.springframework.boot)run:316, SpringApplication (org.springframework.boot)run:1260, SpringApplication (org.springframework.boot)run:1248, SpringApplication (org.springframework.boot)main:26, ZhxtApplication (com.zwkj.zhxt) AbstractAutowireCapableBeanFactory 320123456789101112131415161718192021@Override public Object configureBean(Object existingBean, String beanName) throws BeansException &#123; markBeanAsCreated(beanName); BeanDefinition mbd = getMergedBeanDefinition(beanName); RootBeanDefinition bd = null; if (mbd instanceof RootBeanDefinition) &#123; RootBeanDefinition rbd = (RootBeanDefinition) mbd; bd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition()); &#125; if (bd == null) &#123; bd = new RootBeanDefinition(mbd); &#125; if (!bd.isPrototype()) &#123; bd.setScope(BeanDefinition.SCOPE_PROTOTYPE); bd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader()); &#125; BeanWrapper bw = new BeanWrapperImpl(existingBean); initBeanWrapper(bw); populateBean(beanName, bd, bw); return initializeBean(beanName, existingBean, bd); &#125; AbstractAutowireCapableBeanFactory 1336 1234567891011121314151617181920212223242526272829303132333435363738394041PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs;&#125;boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);PropertyDescriptor[] filteredPds = null;if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125;&#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"http://yoursite.com/tags/ioc/"}]},{"title":"记一次慢sql的查询记录","slug":"sqlOptimize","date":"2019-05-12T16:00:00.000Z","updated":"2019-11-08T01:30:27.357Z","comments":true,"path":"2019/05/13/sqlOptimize/","link":"","permalink":"http://yoursite.com/2019/05/13/sqlOptimize/","excerpt":"","text":"本质上来讲 sql优化和数据库优化是两种优化 数据库优化包含的种类较多 软件优化,硬件优化 理论上 单个mysql数据库能够支撑的是每秒2000的并发 极限是5000 当然本次不说数据库优化 先说sql优化 sql优化一般是针对单个业务进行优化 比如秒杀 系统的订单查询 (当然一般用redis 这里只是举个例子) 或者说是对excel表格进行分析插入数据库 等等各种各样的业务 当然一个简单的sql 可能就是这样的 1SELECT * from test WHERE ASSIGNEE_ = 'user1' 但在实际业务环境中可能并不是这样 实际会复杂很多 以及很多条件 当我们在处理这样的sql的时候 应该怎么去优化以及从哪里入手 索引我们大家都是知道索引可以很好的帮我们来提高效率 但是具体怎么用 以及针对某个业务或者单条sql怎么优化 再说这些之前我们先针对SQL进行一些常识性优化 比如 基本优化WHERE 子句里面的列尽量被索引 尽量避免使用 “SELECT *” 如果用到分页 尽量使用物理分页 并非逻辑分页 join列尽量使用索引 order by 使用索引 等等 总之是为了避免全表扫描做出的各种操作 大家应该发现索引的使用还是非常频繁的 那么具体某个sql使用了哪些索引 以及进行了什么处理操作 EXPLAIN 优化我们可以用 EXPLAIN 关键字去查看执行计划 12345678910111213141516EXPLAIN SELECT *FROM professor aWHERE NOT EXISTS ( SELECT * FROM sys_attend b WHERE a.id = b.professor_id AND b.`type` = 1 AND b.table_id = 93353728 ) AND a.polling_status = 1 AND a.status = 1 AND (a.Member_category = 1 OR a.Member_category = 3) AND (organization_category IN (4, 7) OR organization_categoryvice IN (4, 7))LIMIT 0, 2 id select_type table type possible_keys key key_len ref rows Extra 1 “PRIMARY” “a” “index_merge” “professor_level_index,professor_levelvice_index” “professor_level_index,professor_levelvice_index” “2,2” NULL 28 “Using sort_union(professor_level_index,professor_levelvice_index); Using where” 2 “DEPENDENT SUBQUERY” “b” “ALL” NULL NULL NULL NULL 85 “Using where” 这张表里大概有这么几个字段 id 执行顺序 可以重复 id相同则从上往下执行 id从大到小执行 select_type 搜索类型 一共有十一种 具体可以看这篇博客SQL_explain操作解释 这里就简单的介绍常见的几种 第一种也是最常见到的一种 SIMPLE 简单的select查询,查询中不包含子查询或者union; PRIMARY:查询中若包含任何复杂的子查询,最外层查询则被标记; 就是刚刚的优先级最外层则会显示PRIMARY SUBQUERY:在select或者where列表中包含了子查询; type 显示的是访问类型，一般我们优化sql就是着重优化这个 , 是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。 一般来说，得保证查询至少达到range级别，最好能达到ref。 那么怎么能达到这个级别呢 ref:非唯一性索引扫描,返回匹配某个单独值得所有行,本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,它可能会找到多个符合条件的行,所以它应该属于查找和扫描的混合体; range:只检索给定范围的行,使用一个索引来选择行,key列显示使用哪个索引,一般就是在你的where语句中出现了between,&lt;,&gt;,in等的查询；这种范围索引扫描比全表扫描要好,因为它只需要开始于索引的某一个点,结束于另一个点,不用扫描全部索引; 之前说的避免全表扫描就是为了这样 possible_keys:显示可能会被应用到这张表的索引,一个或者多个;查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用到; key:实际使用到的索引.如果为null,则没有使用索引;查询中若使用了覆盖索引,则该索引仅出现在key列表中; key_len:表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好; key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的; ref:显示索引的哪一列被使用了,如果可能的话,是一个常数,哪些列或常量别用于查找索引列上的值; rows:根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数; Extra:包含不适合在其它列中显示但十分重要的额外信息: 对于这个消息栏里展示的东西有很多 一般是你的sql违反的数据库相对应的算法,他认为你的不合理 在这里就不详细解释了 当大家出现后可以百度相对应的信息 MySQL中explain执行计划中额外信息字段(Extra)详解 那么根据这些信息我们可以查到需要优化哪些地方 说完 explain 我们可以再说说 explain extended + show warnings 在执行explain extended 之后我们在 show warnings 可以看到在数据库中我们sql的执行方式, 我们可以在这个基础上再次进行优化 我们可以看到sql的执行方式，对于分析sql还是很有帮助的。 ( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; ( 1 ) FROM [ left_table ] ( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; ( 2 ) ON &lt; join_condition &gt; ( 4 ) WHERE &lt; where_condition &gt; ( 5 ) GROUP BY &lt; group_by_list &gt; ( 6 ) WITH &lt; CUBE | RollUP &gt; ( 7 ) HAVING &lt; having_condition &gt; ( 10 ) ORDER BY &lt; order_by_list &gt; 从优先级我们可以看出为什么order by 排序在 group by 之前不生效了 之前那条sql之后后数据库warnings的执行方式是下面这样的123456789101112131415SELECT `zwkj_zhxt`.`a`.`id` AS `id`, `zwkj_zhxt`.`a`.`name` AS `name`, `zwkj_zhxt`.`a`.`sex` AS `sex`,FROM `zwkj_zhxt`.`professor` `a`WHERE ((`zwkj_zhxt`.`a`.`status` = 1) AND (`zwkj_zhxt`.`a`.`polling_status` = 1) AND (not(exists(/* select#2 */SELECT 1FROM `zwkj_zhxt`.`sys_attend` `b`WHERE ((`zwkj_zhxt`.`b`.`table_id` = 93353728) AND (`zwkj_zhxt`.`b`.`sex` = 1) AND (`zwkj_zhxt`.`a`.`id` = `zwkj_zhxt`.`b`.`professor_id`))))) AND ((`zwkj_zhxt`.`a`.`name` = 1) OR (`zwkj_zhxt`.`a`.`name` = 3)) AND ((`zwkj_zhxt`.`a`.`sex` IN (4,7)) OR (`zwkj_zhxt`.`a`.`sex` IN (4,7)))) limit 0,2 从上面还可以看出 and 的优先级 总是高于 or 但有一点需要注意的是 exteneded得到的sql并不是 最终优化执行的sql这一点可以在官方文档中得到确认Extended EXPLAIN Output Format但从优化的角度上来讲也能帮助我们. 一般企业数据库的优化 基本上是 配硬件+差不多的sql优化+分布式+分库分表+读写分离 等等 反正一系列的操作 基本满足80%的业务场景 当然我们优化个别业务需要根据实际场景来优化 如果确实说需要高级别的维护和优化 公司会有相对应的运维或者DB来做很少需要开发者担心","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"}]},{"title":"浅谈jvm","slug":"jvm","date":"2017-04-07T16:00:00.000Z","updated":"2019-11-08T01:29:31.139Z","comments":true,"path":"2017/04/08/jvm/","link":"","permalink":"http://yoursite.com/2017/04/08/jvm/","excerpt":"","text":"jvm运行时数据分析 在区域中一般分为五块 运行时数据区域 计数器 通过改变这个计数器的值来获取下一条需要执行的字节码,包括判断 循环,跳转,异常处理 方法区(method Area) 该区域用来存放我们生成的各种对象信息 虚拟机栈(VM stack) 每个类 都会在执行的时候创建一个栈帧(javap -c -s xxx.class)来存放关于这个类的所有信息. 包括方法内的局部变量,以及各种操作帧数, 动态链接(各种引用)及方法的出口返回值等等。每个方法的调用到结束意味着虚拟机的栈桢的入栈到出栈, 堆(heap) 在遇到new指令后 我们会根据相对应的内存引用来找如果有就引用 没有的话就执行类加载 Java 类加载过程那一套东西 本地方法栈(native mathod stack) 存放本地原生调用方法和虚拟机栈一样只不过内容是原生计算机内的C方法 native是与C++联合开发的时候用的 所以一般开发不会用到 前面在堆中说了类引用会检查是否已经加载过当前需要的类 如果没有加载则会去加载 那么类的加载过程就是下面要说的 当程序用到某个类但这个类还没有加载到内存中,jvm会通过加载,连接,初始化来对这个类进行初始化 加载 jvm通过类的全类名来获取字节流 (也就是.class文件) 然后根据字节流创建class对象 创建完成后写入到内存中,然后放在运行时区域的方法区内(method Area) 然后在堆(heap)中创建出对应的Class对象 链接 分为三部分 验证语法 满足jvm虚拟机规范 准备阶段 为类的静态static 分配内存 设置默认值 解析阶段 将符号引用替换为内存引用(直接引用) 初始化 将static修饰的方法或者变量进行初始化,如果有父级引用优先加载父类 那么这个类的加载机制又是什么 它是通过什么来加载的 采用的双亲委派机制 当加载某个类的时候先去询问父类节点是否可以加载 这样既避免了重复加载也防止了注入还提高了效率","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"maven多环境配置文件","slug":"mavenProfileSpringboot","date":"2015-10-07T16:00:00.000Z","updated":"2019-11-08T01:30:15.340Z","comments":true,"path":"2015/10/08/mavenProfileSpringboot/","link":"","permalink":"http://yoursite.com/2015/10/08/mavenProfileSpringboot/","excerpt":"","text":"123# 多环境配置文件激活属性---开发、测试、生产spring.profiles.active=@activatedProperties@ 12345678910111213141516171819202122&lt;profiles&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 本地开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认环境为开发环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 12345678910111213141516171819202122&lt;!-- 打包后的名字(test.war) --&gt; &lt;resources&gt; &lt;!-- 打包时要把mapper.xml也打进去！ --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt; &lt;excludes&gt; &lt;exclude&gt;test/*&lt;/exclude&gt; &lt;exclude&gt;dev/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/$&#123;profiles.active&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; 如果先远程部署后本地启动需要先maven install mvn clean package -Pdev -Dmaven.test.skip=true java -jar /xxx/xxx.jar –spring.profiles.active=dev yml环境下有些区别 @换成# 详细情况可以参考 SpringBoot + Maven实现多环境动态切换yml配置及配置文件拆分","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"局域网共享文件夹如何换用户名登陆","slug":"windows01","date":"2015-10-07T16:00:00.000Z","updated":"2019-11-08T01:28:30.602Z","comments":true,"path":"2015/10/08/windows01/","link":"","permalink":"http://yoursite.com/2015/10/08/windows01/","excerpt":"","text":"你在运行里输入 CMD在命令提示符中输入： 1net use * /delete OR 1net use * /del /y 然后它会问你是否要删除网络连接，按 Y，回车即可。","categories":[{"name":"windwos","slug":"windwos","permalink":"http://yoursite.com/categories/windwos/"}],"tags":[{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://yoursite.com/tags/共享文件夹/"},{"name":"登陆","slug":"登陆","permalink":"http://yoursite.com/tags/登陆/"}]},{"title":"博客MD模板应用","slug":"tamplate","date":"2015-10-07T16:00:00.000Z","updated":"2019-11-08T01:28:55.694Z","comments":true,"path":"2015/10/08/tamplate/","link":"","permalink":"http://yoursite.com/2015/10/08/tamplate/","excerpt":"","text":"\\literal asterisks\\\\ 转义 *literal asterisks* MD语法 加粗 **加粗** 比较粗 MD语法 斜体 *斜体* 本来就是斜的 MD语法 列表1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD语法 分割线 *** 代表一条分割线 MD语法 A标签 [A标签显示的名称](链接地址) baidu MD语法 图片 ![ 图片说明 ](图片地址) MD语法 编写代码 三个 ` 123def test() print('asd')test() MD语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"hexo基本命令","slug":"hexoShell","date":"2015-05-01T16:00:00.000Z","updated":"2019-11-08T01:36:09.467Z","comments":true,"path":"2015/05/02/hexoShell/","link":"","permalink":"http://yoursite.com/2015/05/02/hexoShell/","excerpt":"","text":"本地部署验证hexo s -g 清理并生成hexo clean &amp;&amp; hexo g 远程部署hexo d","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}