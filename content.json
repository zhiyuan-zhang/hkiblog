{"meta":{"title":"hki","subtitle":null,"description":null,"author":"zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-12-12T04:27:05.151Z","updated":"2019-12-12T04:27:05.151Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404"}],"posts":[{"title":"浅析redis","slug":"Redis","date":"2020-06-18T16:00:00.000Z","updated":"2020-06-18T03:54:51.788Z","comments":true,"path":"2020/06/19/Redis/","link":"","permalink":"http://yoursite.com/2020/06/19/Redis/","excerpt":"","text":"Redis帮助文档 https://cloud.tencent.com/developer/section/1374167 redis.cn 安装流程1. yum install wget2. wget www.***redis .tar.gz(去github找最新的包)3. tar xf redis.tar.gz4. cd redis-src5. README.md6. makemake yum install gccmake distclean 7. makecd src … 生成了可执行程序 8. cd ..9. make install PREFIX=/opt/xxxx/redis510. vi /etc/profile11. cd utils最后写入… export REDIS_HOME =/opt/xxx/redis5… export PATH=$PATH:$REDIS_HOME/binsource /etc/profile 12. ./install_server.sh 一个物理机中可以有多个redis实例. 通过port区分 可执行程序就有一份在目录, 但是内存中需要多个实例有各自的配置文件 批处理server redi_6379 start/stop/status &gt; linux /etc/init.d/*** ## 存储类型keyvalue String(byte) 字符类型 set k1 test nx nx 如果存在则不能插入成功, 只能用来新增 set k1 test xx xx 如果不存在的话就失败, 只能用来更新 append 追加 range setrange getrange strlen type 命令是哪个分组的就是哪种类型 getset 更新值并且拿到老值 MSETNX 原子性批量操作 要么都成功 要么都失败 数值类型 incr incrby bitmap 一个字节(bit)有8个二进制位 1B=8 Bit1KB＝1024B1MB＝1024KB1GB＝1024MB1TB=1024GB SETBIT key offset value 设置key 偏移量offset 的 0 或者1 BITPOS key bit [start] [end] 查找字符串中第一个设置为1或0的bit位 ,返回该位置 bitpos k1 1 0 0 1 bitpos k1 1 1 1 9 BITCOUNT key [start end] 返回是1的数量 start 和end是字节位置 BITOP operation destkey key [key …] AND 按位与操作 全1是1 其余为0 OR 按位或操作 有1是1 其余为0 XOR NOT lists(双向链表) lpush 左添加 进入队列在链表的左边依次开始添加 lpop 左弹出 rpush 右添加 进入队列在链表的最右边依次添加 rpop 右弹出 lrange 得到固定范围内的所有值 lrem 移除几个什么类型的元素 linsert 只在找到第一个值的地方 after 后面插入 before 前面插入 blpop (阻塞,单播队列) 拿到里面的第一个数据 拿不到则阻塞 Hashes ( 点赞,收藏,详情页) 存储对象name::agename::sexname::weight hset key field value 添加一个对象的属性值 hmset 添加一个对象的多个属性值 hmget 获取一个对象的多个属性值 hvals 获取这个对象的所有属性值 hgetall 拿到这个对象的所有key value HINCRBYFLOAT key field increment 对指定的一个属性进行 +1 -1 sets ( 去重) SADD key member [member …] 添加元素 smembers 去重查看 srem 去除某个value sinter key… 返回 多个key 的交集 sinterstore 将交集结果 保存到指定key sunion 去重并且打印出 并集 sdiff (差集) 前面的key 与后面的key 做差集 Srandmember key count(随机事件) count 正数 得到一个去重的结果集 count 负数 得到一个带重复的结果集 spop 随机取出一个数据,并删除集合里面的该值 sorted sets(排序) zadd 添加一个带数值的set ZRANGE key start stop [WITHSCORES] 得到一个带有起始位置的排序组合 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 最小值和最大值的一个区间组合 zrevrange 逆序输出 zscore 通过元素取到分值 ZRANGE key start stop [WITHSCORES] 通过元素取到排名 ZINCRBY key increment member 对指定key的分值进行加减 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 获取交集和并集 权重和集合指令 管道http://redis.cn/topics/pipelining.html发布订阅client 历史数据 全量数据 – 数据库 短时间内 – sorted set 实时数据 PUBLISH key value 发布 SUBSCRIBE key 监听 先监听才能收到发布的消息 事务mutil 开始事务 exec 执行 哪个先到就执行哪个事务 watch 乐观锁 CAS 监控某个值是否发生了变更 布隆过滤器https://github.com/RedisBloom/RedisBloomredis-server –loadmodule /path/to/redisbloom.so黑名单拦截垃圾邮箱拦截凡是某个值需要经过判断大量数据是否存在并且误报的影响较小的情况下可以使用一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。会有误判就是可能存在但是不一定存在的情况,Redis使用安装使用 redis-cli 进入redis -p 指定端口 -d 指定DB help 帮助文档 在使用前 需要规定编码格式 因为是字节流 二进制安全, 不存在客户端解析问题, 所以需要统一加码解码 kernel内存响应时间是纳秒 如果在同一时间有十多万个并发来请求redis服务端 那么会有秒级的延迟 所以内存寻址每个大约在纳秒级别响应 install_server.sh 创建指定端口的配置文件 作为缓存使用 maxmemory 配置内存尽量控制在1G-10G 设置内存满了之后的拒绝策略 lfu 碰了多少次 lru 多久没碰 key的有效期设置 主动 主动访问的时候发现过期删除 被动 随机抽查20个key 删除已经过期的 如果发现超过25%的key过期那么重复第一步骤 作为数据库使用​ 目前作为缓存的较多 ,作为数据库比较少 因为存在分布式情况下的数据一致性问题 以及备份问题不推荐使用redis做数据库 缓存集群目前单节点的问题 单点故障 看集群搭建 压力有限 看集群搭建 容量有限 业务节点拆分不同的redis 算法拆分 (sharding) hash+ 取模 (modula ) random 消息队列 一边lpush 一边只需要去rpop kemata (一致性hash算法) 有一个首尾相连的环 在这个环上有你的物理节点 业务数据过来后通过hash算法最后会有一个结果落在这个环的某个位置,也就是虚拟点 虚拟点去找后面的物理节点然后保存到redis集群中 优点 : 后续加节点 会分担其他节点的压力,并不会造成全局洗牌 缺点: 新增的节点有部分数据不能命中缓存 导致缓存击穿, 压到mysql数据库中 解决方案 : 去寻找最近的两个节点的缓存数据 AKF X 轴 全量 镜像 Y 轴 业务 功能 Z轴 指定规则将指定的key放在不同的库里面 集群搭建 主节点 当子节点挂在主节点后 主节点会受到一个子节点的消息 子节点 启动的时候 添加配置 redis-server ./6380.conf –REPLICAOF IP port –appendonly yes redis 默认使用的是弱一致性 主从复制配置 replica-serve-stale-data yes 是否在同步期间提供给第三方数据 replica-read-only yes repl-backiog-size 1mb 监控(Sentinel) 监控 port 26379sentinel monitor master1 127.0.0.1 6381 2 redis-server ./26379.conf –sentinel 分布式锁​ 目前纯redis 的分布式锁都不是很好实现 ​ 可以结合zookeeper","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"redis","slug":"java/redis","permalink":"http://yoursite.com/categories/java/redis/"}],"tags":[]},{"title":"再次浅谈jvm","slug":"jvm02","date":"2020-06-10T16:00:00.000Z","updated":"2020-06-18T03:28:33.300Z","comments":true,"path":"2020/06/11/jvm02/","link":"","permalink":"http://yoursite.com/2020/06/11/jvm02/","excerpt":"","text":"jvm1. 虚拟机基础概念Class File Formatjdk -&gt; jre -&gt; jvm### 2. class文件结构3. 内存加载过程 JMM1.Loading 当class 加载到内存中 实际上生成了两块内容一个是将二进制内容放到内存中 与此同时生成了一个.class对象 这个对象指向这个内容后续所有的代码都会通过这个.class对象访问二进制内容类只会load一次所以用emun来实现单例就是这个原理 在jvm的matespacess中 类加载器 机制顺序 1.bootstrap 最顶级的加载器 显示null 2.extension 加载插件的加载器 jre/lib/ext/*.jar 下面的扩展jar包 3.app 加载classPath指定内容 4.CustomClassLoader 自定义ClassLoad 自制类加载器 代码混淆 加密 自定义加载器步骤 extends ClassLoader overwrite findClass() -&gt; defineClass(byte[] -&gt; Class clazz) 加密 ClassLoad 源码 findInCache -&gt; parent.loadClass -&gt; findClass() jvm是按需动态加载,采用双亲委派机制 为什么要采用双亲委派机制 为了防止使用类似String.class 不经过询问直接加载,导致会执行自定义逻辑,使用双亲委派后我们会直接返回已经加载过的内置.class 自底向上检查该类是否已经加载 Parent方向 自顶下下进行查找和加载child方向 jvm编译模式 解释器- 解释语言 JIT just in Time compiler 代码编译 java采用的是混合编译模式 多次被调用的方法和多次被调用的循环 进行编译 -Xmixed 默认混合模式 -Xint 使用解释模式 ,启动很快,执行稍慢 -Xcomp 使用纯编译模式,执行很快,启动慢 Linking Verification 来验证是否符合JVM语法规范 类似开头cafe babe Preparation 给静态成员变量赋默认值, 注意是默认值不是初始化值 Resolution 将类、方法、属性等符号引用解析为直接引用 常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用 Initializing ɪˈnɪʃəlaɪzɪŋ 调用类初始化代码 ，给静态成员变量赋初始值 4. 运行时内存结构每个线程都有单独的区域 Program Counter 存放栈帧的下一步运行 虚拟机里面类似这样的循环while( not end ) {​ 取PC中的位置，找到对应位置的指令；​ 执行该指令；​ PC ++;} JVM Stack 每个方法对应一个栈帧, 栈帧可以叠加 代表方法调用方法 每个方法都有自己的栈帧,并且都拥有这四个属性 Local Variable Table 局部变量表 istore_3 包括入参和方法内定义的变量 非static 里面默认包含一个this Operand-Stack 操作数栈 一个用来执行栈操作的 压栈和出栈 如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。 Dynamic Linking 动态链接 当一个方法里面有指向另一个类的符号引用时, 将符号引用替换为直接引用, return address a() -&gt; b()，方法a调用了方法b, b方法的返回值放在什么地方 b方法的返回值放在A方法的栈顶 便于赋值 return后返回的地方 A-&gt;B-&gt;C 栈帧也是 ABC 指令集目前分为两种 1 基于栈的指令集 JVM就是这样的 iadd istore_2 load pop mul sub return invoke InvokeStatic 调用静态方法使用的 InvokeVirtual 多数方法使用这个 自带多态 InvokeInterface List list = new ArrayList(); 使用 InvokeSpecial 可以直接调用的 不需要多态 private InvokeDynamic lambda 使用或者反射使用 基于寄存器的指令集 类似汇编 AX BX Native Method Stack 本地方法栈为虚拟机使用到的Native方法服务 共享区域 Heap 堆 method Area 装的各种各样的 class结构 Perm Space (&lt;1.8)字符串常量位于PermSpaceFGC不会清理大小启动的时候指定，不能变 Meta Space (&gt;=1.8)字符串常量位于堆会触发FGC清理不设定的话，最大就是物理内存 Direct Memory JVM 使用未公开的Unsafe 可以直接访问内核空间的内存 (操作系统OS管理的内存) NIO包下ByteBuffer 提高效率, 实现zero copy 在jvm中只保留一个引用, 可以扩展至更大的内存空间。比如超过1TB甚至比主存还大的空间 理论上能减少GC暂停时间（节约了大量的堆内内存） 它的持久化存储可以支持快速重启，同时还能够在测试环境中重现生产数据 堆外内存能够提升IO效率 堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了数据从用户内向内核态的拷贝。 Run-Time Constant Pool 常量池的数据 JMM (java memory model)硬件层数据一致性问题 JMM 有很多协议 一般使用intel的MESI MESI 一共有四种状态来表示当前缓存的状态 现代CPU的数据一致性是靠 缓存锁 + 总线锁来实现 读取缓存是以cache line为单位, 目前是64bytes位 一块为单位 四块为一个单位的合并写技术 WCbuffer 伪共享 就是 当内存发现这一块的数据中有一个发生改变就会重新读取整个块的内容 这样就会导致 即使你用不到的数据发生变动 也会导致重新加载内存的问题 在多线程与高并发期间Disruptor 就采用了在游标前后加上 7个空的long类型 填充缓存块 乱排序问题 cpu会将无关的指令并行执行 但有时候也会出现问题 处理乱序的规范 硬件内存屏障 X86 cpu硬件级别的内存屏障 利用汇编指令来完成 save fence 写操作 写之前必须完成这个指令前的所有操作 load fence 读操作 读操作之前必须在这个指令前的所有操作 mfence 读写操作 这条指令前的所有读写必须完成了才能操作后续的指令 原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序 JVM级别的内存屏障 LoadLoad屏障 (读操作) 语句Load1; LoadLoad; Load2， 在执行之前必须保证之前的读取数据访问完成 StoreStore屏障 (写操作) 语句Store1; StoreStore; Store2， 在执行之前保证1的写入操作 对其他处理器可见 LoadStore屏障 语句Load1; LoadStore; Store2， 在后续写入操作被刷出之前,必须保证之前的操作读取完毕 StoreLoad屏障 语句Store1; StoreLoad; Load2， 在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 volatile实现细节 字节码层面 Access flags = volatile JVM层面 volatile内存区的读写 都加屏障 StoreStoreBarrier volatile 写操作 StoreLoadBarrier - LoadLoadBarrier volatile 读操作 LoadStoreBarrier OS/硬件层面 windows lock 指令实现 子主题 1 工具 hsdis Synchronized 实现细节 字节码层面 ACC_SYNCHRONIZEDmonitorenter monitorexit monitorexit JVM层面的实现 调用了 C C++ 指令 OS/硬件层面的实现 X86 Lock cmpxchg XXX 指令 5. jvm 常用命令-开头的 标准参数-X 开头的是非标准参数-XX 是不建议使用的参数常见垃圾回收器的组合参数设定 1.8 一般不会使用的 -XX:+UseParNewGC = ParNew + SerialOld -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 常见的几种组合 -XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】 -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 Linux下1.8版本默认的垃圾回收器到底是什么？ 1.8.0_181 默认（看不出来）Copy MarkCompact 1.8.0_222 默认 PS + PO GC 日志打印 -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:../logs/gc.log 日志文件的输出路径 -XX:+HeapDumpOnOutOfMemoryError 发生异常 自动存储 例如: java -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclog -jar zhxt-1.01-SNAPSHOT.jar 6. GC 与调优什么是垃圾 没有任何引用指向的一个对象或者多个对象 怎么查找到它 Reference Count 无法解决循环引用 Root Searching 哪些可以成为根节点 static references in method area 本地方法区的静态引用 class run-time constant pool 常量池 native method stack JNI指针 JVM Stack GC 垃圾回收算法 Mark-Sweep 标记清除 通过根节点找到所有在用的,然后清除掉其他没用的 优点: 存活对象多的情况下效率较高缺点: 容易产生碎片,需要扫描两次 Copying 将内存一分为二优点: 适合存活对象较少 , 只需要扫描一次, 没有碎片缺点: 移动复制对象,需要调整指向引用 Mark-Compact 扫描两次 需要将所以在使用的块移动到一起 优点: 不会有碎片产生, 不会让内存减半缺点: 需要移动对象,效率偏低,不适合存货对象较多的区域 JVM 内存分代模型 逻辑物理都分代 POPS, CMS , 逻辑分代,物理不分代 G1 逻辑物理都不分代 Epsilon ZGC Shenandoah 堆内逻辑分区 new / young 新生代 1 eden 伊甸区 8 survivor 1 survivor 1 old tenured老年代 3 Method area Garbage Collectors Serial Seral Old ParNew (Parallel New) CMS 老年代垃圾回收器 清理过程 初始标记 找到根节点并且标记出来 并发标记 找出根节点下的所有关联节点 重新标记 由于并发标记并会停止线程工作 可能导致一些漏标或者错标问题,所以这个时候需要STW来重新整理下 并发清理 将其他的清理掉 这个时候的垃圾就浮动垃圾 等待下一次回收 缺点 Memory Fragmentation 内存碎片的问题 当有新的对象在老年代放不下的时候会产生一次较长时间的STW 然后会有Seral Old 来标记移动对象 这样会效率很慢 解决1. 保证老年代有足够的空间 -XX:CMSSInitiatingOccupancyFraction 60% Floating Garbage 浮动垃圾过多 算法 三色标记 + Incremental Update 三色标记 是在并发标记的过程中 将标记的所有对象归结为三类 黑,白,灰,黑色代表自己和子节点标记完成,灰色代表自己完成子节点未标记完成,白色代表自己和子节点都没标记 漏标问题应为并发过程中还有线程会引用 所以会产生一个情况灰色的子节点标记删除了,黑色新增一个白色的子节点,这样导致子节点会不扫描 Incremental Update 增量更新,关注引用的增加,将黑色重新标记为灰色,下次就会重新扫描 Parallel Scavenge copy 算法 Parallel Old mark-compact 算法 G1 1.8成熟 1.9 默认 算法 三色标记 + SATB 漏标问题 SATB(Snapshot at the beginning) 将所有的删除操作放在一个栈里面 保证下一次直接扫描这个栈里面的引用就可以了 将所有内存 分为 Eden, Survivor, Old , Humongous(分配大对象) 传统YGC找一个对象是否存活非常麻烦 需要去遍历所有的堆空间, 这样非常消耗时间 G1 是把所有关联的内存当成一个card,存储在card table里, 然后每个card里面有一个标识 RSet = RemenberedSet记录了其他Region中的对象到本Region的引用垃圾回收器只需要扫描这个RSet就能知道谁引用了 新老年代比例 G1会根据上次YGC的时间来控制新老年代的比例 一般在5%-60% 之间 什么时候回FGC当内存分配过快的时候 回产生FGC 扩内存 - 提高CPU性能 - 降低MixedGC的出发阈值,让MixedGC提前发生 默认是45% XX:InitiatingHeapOccupacyPercent Card table bitmap ZGC 算法 ColoredPointers + 写屏障 Epsilon 什么都不做的垃圾回收器 Shenandoah 收费 算法 ColoredPointers + 读屏障 tunning 基本概念 吞吐量 优先 PS + PO 算法支撑 F=N*R/TF：吞吐量；N：并发虚拟用户数；R：每个虚拟用户发出的请求数量；T：性能测试所用的时间 响应时间 优先 G1 淘宝一年来最高并发 54W 12306 百万并发 什么是调优 根据需求进行JVM规划和预调优 优化运行JVM环境 解决各种JVM在运行过程中的问题 OOM 调优开始步骤 需要有具体业务场景 需要有压力测试报告指明调优方向, 了解业务场景 响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应） 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS] 选择回收器组合 计算内存需求( 经验值 1.5G 16G) 选定CPU (越高越好) 设定年代大小, 升级年龄 设定日志参数 -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause 或者每天产生一个日志文件 观察日志情况 调优步骤 查询当前机器所有的进程top 11056 或者 jsp 查询当前所有java进程 查询指定进程中的所有线程执行状态top -Hp 11056 查询所有的线程执行状况jstack 11056 启动信息查询jinfo 88768 打印堆栈信息jstat -gc 88768 500 找出哪个对象占用内存最多jmap -histo 88768 | head -20 导出jmap -dump:format=b,file=xxx pid：线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合） 调优工具Arthas jvm == jinfo thread thread 54 dashboard == top heapdump heapdump /tmp/dump.hprof 分析文件 jhat -J -mx=512M dump.hprof jad redefine 热替换 面试题1. 对象的创建过程 加载到内存 申请对象内存 成员变量赋默认值 调用构造方法 成员变量 顺序 赋初始值 执行构造方法语句 2,内存布局 普通对象 markword 对象头 ClassPointer指针 -XX:+UseConpressedClassPointers 为4个字节 不开启为8个字节 实例数据 -XX: +UserCompressedOops 为4个字节 不开启为8个字节 padding 对其 8 的倍数 数组对象 对象头：markword 8 ClassPointer指针同上 数组长度：4字节 数组数据 对齐 8的倍数 3. 一个空对象在内存中占用多少个字节 普通对象 对象头markword 8个字节 指针 本来是8个字节 但是64位系统为压缩到4个字节 本来是8+4 = 12 后续padding补齐 一共16个字节 数组对象 比普通对象多个 数组长度 4个字节 4. 对象头具体包含什么 4位的 分代年龄 1位的偏向锁 2位的锁标志 31位的 hash code 5. 对象怎么定位 句柄池 通过一个间接指针来指到两个指针上 其中一个指定 T.clss 另外一个指定具体内容 直接指针 (HotSpot) A指向内容 内容包含B.class 6. 对象的分配过程 栈上分配 线程私有小对象 逃逸分析 查看大不大 如果大的直接old TLAB Thread Loocal Allocation Buffer 多线程的时候每个人分配占用1%的eden区域来分配对象,提高效率 eden 对象何时进入老年代 除了CMS是6次之外 其他的都是15 分配担保 YGC期间 当Sruvivor区内存空间不够了 空间担保直接进入老年代 动态年龄 Survivor 的 区域大于50% , 找出年龄最大的放在老年代","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"jvm","slug":"java/jvm","permalink":"http://yoursite.com/categories/java/jvm/"}],"tags":[]},{"title":"predixy","slug":"predixy","date":"2020-06-05T16:00:00.000Z","updated":"2020-06-18T02:50:23.906Z","comments":true,"path":"2020/06/06/predixy/","link":"","permalink":"http://yoursite.com/2020/06/06/predixy/","excerpt":"","text":"predixy 去github 找最新的tar包下载到服务器 https://github.com/joyieldInc/predixy.git git clone https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz 解压tar xf predixy-1.0.5-bin-amd64-linux.tar.gz 进入主目录cd bin 配置文件cd conf vi predixy.conf Bind 127.0.0.1:7617 找到serversInclude sentinel.conf vi sentinel.conf 复制examples 在sentinels 里面配置 你之前设置好的redis-sentinel 127.0.0.1:26379 127.0.0.1:26380 127.0.0.1:26381 还需要配置你的主库名称 Group master1 { } Group master2 { }","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"推特redis twemproxy集群搭建","slug":"twemproxy","date":"2020-05-31T16:00:00.000Z","updated":"2020-06-18T03:44:33.829Z","comments":true,"path":"2020/06/01/twemproxy/","link":"","permalink":"http://yoursite.com/2020/06/01/twemproxy/","excerpt":"","text":"简单介绍可以查看https://github.com/twitter/twemproxy.git 推特redis twemproxy集群搭建 twemproxy 1git clone https://github.com/twitter/twemproxy.git 如果报错 yum update nss 进入twemproxy文件 1yum install automake libtool -y 1autoreconf -fvi 如果报错 更改centOS源https://developer.aliyun.com/mirror/ 1wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo yum clean all 进入twemproxy文件夹 1yum search autoconf 搜索出来的 install 下 1yum install autoreconf268 autoreconf268 -fvi执行完之后 多了一个 configure 执行 ./configure 执行 make 进入scripts 12cp nutcracker.init /etc/init.d/twemproxycd /etc/init.d/twemproxy 赋予权限 1chmod +x twemproxy 因为该文件依赖一个yml配置文件 所以我们需要拷贝一个源码目录的这个配置文件 进入twemproxy文件夹 12cp ./conf/* /etc/nutcracker/cd /twemproxy/nutcracker/src 拷贝可执行 cp nutcracker /sur/bin 修改配置文件 1234cd /etc/nutcracker/vi nutcracker.yml 配置对应的server 123servers - 127.0.0.1:6379 - 127.0.0.1:6380 启动刚刚配置好的 redis 启动nutcracker 1service nutcracker start 如果你改名了的话就用改了名字的启动 1service twemproxy start 然后去启动 1redis-cli -p 22121 端口是你刚刚那个配置文件里配置的端口 这个时候你连接22121 的redis 添加的数据会落在你之前配置的yml文件的server数据库中 缺点不支持 keys *不支持 watch不支持 multi","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"},{"name":"java","slug":"redis/java","permalink":"http://yoursite.com/categories/redis/java/"},{"name":"linux","slug":"redis/java/linux","permalink":"http://yoursite.com/categories/redis/java/linux/"}],"tags":[]},{"title":"设计原则","slug":"设计原则","date":"2020-04-28T16:00:00.000Z","updated":"2020-04-30T05:41:57.444Z","comments":true,"path":"2020/04/29/设计原则/","link":"","permalink":"http://yoursite.com/2020/04/29/设计原则/","excerpt":"","text":"单一职责原则单个类不要设计的太庞大 当关联业务比较多的时候可以单独抽出来做一个manage类 Person 人相关的方法 PersonManager 与人相关的业务方法 开闭原则设计紧抓这一点 “面向修改关闭,面向拓展开放” 当你发现修改一个业务需要更改很多地方或者很多代码的时候说明你的设计有问题 尽量在最少修改的情况下达到完成需求. 留下以前的代码,旧代码也有价值的. 里氏替换原则Liscov Substitutiono Principle 所有引用父类对象的地方,必须能够透明的使用子类对象 依赖倒置原则Dependency INversion Priciple 参考 Array 对应 ArrayList ,LinkedList 就是在你需要添加新业务的时候 只需要新增一个抽象类的子类, 你只需要调用抽象类的方法就可以完成需求,无需修改现有逻辑, 面向接口编程 . 面向抽象编程. 接口隔离原则每个接口承担自己独立的业务,不要混和完成一个功能.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"模板方法设计模式","slug":"TemplateMathod","date":"2020-04-27T16:00:00.000Z","updated":"2020-05-18T06:07:58.205Z","comments":true,"path":"2020/04/28/TemplateMathod/","link":"","permalink":"http://yoursite.com/2020/04/28/TemplateMathod/","excerpt":"","text":"模板方法 也叫钩子函数 就是父类把所有的应该做的方法都写出来 让子类去实现 我先定义一个模板出来 具体的实现子类去做 定义抽象类 12345678910abstract class F &#123; public void m() &#123; op1(); op2(); &#125; abstract void op1(); abstract void op2();&#125; 可以实现一个子类或多个子类 123456789101112class C1 extends F &#123; @Override void op1() &#123; System.out.println(\"op1\"); &#125; @Override void op2() &#123; System.out.println(\"op2\"); &#125;&#125; main 使用 12F f = new C1();f.m(); 在AQS里面有使用这个模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; /** * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // Methods relayed from outer class final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; final boolean isLocked() &#123; return getState() != 0; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125; &#125; 12345678910111213141516171819202122/** * Sync object for non-fair locks */static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 1234567891011121314151617181920212223242526272829 /** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. */ public ReentrantLock() &#123; sync = new NonfairSync(); &#125;/** * Acquires the lock. * * &lt;p&gt;Acquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * &lt;p&gt;If the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * &lt;p&gt;If the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */ public void lock() &#123; sync.lock(); &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"工厂设计模式实际应用案例","slug":"factory","date":"2020-04-23T16:00:00.000Z","updated":"2020-04-24T03:17:44.652Z","comments":true,"path":"2020/04/24/factory/","link":"","permalink":"http://yoursite.com/2020/04/24/factory/","excerpt":"","text":"设计模式中的工厂模式 工厂模式在实际应用中也很常见 各种框架的factory也很多 先说说需求我们这个项目有一个发送通知的需求 通知有各种各样的 举几个例子 手机验证码通知 项目审批通知 出函通知 确认函通知 会议取消通知 待处理通知 … 发送方式也有很多种 邮件通知 短信通知 微信通知 钉钉通知 … 所以在设计的时候一个合格的通知必须经过三个步骤 确定发送类型 确定发送人 确定发送方式 我们可以把通知类做成一个factory 专门做通知的发送 // 2020年修改 后来我觉得这么设计有点不妥 改成 factory 制作各种通知 由策略模式来负责发送短信 工厂只负责短信的生产,不负责发送 具体实现步骤 1创建一个接口。 ProfessorStrategy 12345public interface notice &#123; void type(); void choose(); void send();&#125; 步骤 2创建实现接口的实体类。 EIMProfessorStrategy 12345678public class EIMProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; IPDProfessorStrategy 123456789public class IPDProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; UserProfessorStrategy 123456789public class UserProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。 123456789101112131415 /** * 返回接口数据 * @param tableId * @param professorStrategy * @return */ public static List&lt;SysAttendsModel&gt; find(Integer tableId, ProfessorStrategy professorStrategy) &#123;// 获取对应的五个专家 List&lt;Professor&gt; five = professorStrategy.five(tableId); List&lt;SysAttendsModel&gt; sysAttendsModels = new ArrayList&lt;&gt;(); return sysAttendsModels; &#125; 步骤 4使用 find 来查看当它改变策略 Strategy 时的行为变化。 main 12345678910111213public static void main(String[] args) &#123; // 单据id int tableId = 10086; // 挂牌算法 List&lt;SysAttendsModel&gt; list = find(tableId, new EIMProfessorStrategy()); // 可转债算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new IPDProfessorStrategy()); // 会员算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new IPDProfessorStrategy()); &#125; 代码讲解","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"权限设计","slug":"权限设计","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-22T08:58:36.239Z","comments":true,"path":"2020/04/14/权限设计/","link":"","permalink":"http://yoursite.com/2020/04/14/权限设计/","excerpt":"","text":"设计核心每个登录用户拥有各自的权限,由后端返回 后端下文整个权限模式基于RBAC理论设计 后台验证角色的权限,前端根据后台返回的menuList, permissionList 来设计前端的页面Router 角色的作用其实只是用来管理分配权限的,真正的验证只验证权限 数据库数据库主要包含五张表，分别是用户表 sys_user 、角色表 sys_role 、用户角色表 sys_job 、权限表 sys_permission 、角色权限表 sys_role_permission 。 关联关系如下图所示 数据库表内容及其含义运营后台用户表12345678910111213CREATE TABLE `sys_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL COMMENT '用户名', `password` varchar(255) DEFAULT NULL COMMENT '密码', `nickname` varchar(255) DEFAULT NULL COMMENT '昵称', `role_id` varchar(64) DEFAULT '0' COMMENT '角色ID', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间', `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', `phone` varchar(255) DEFAULT NULL COMMENT '管理员手机号', `type` varchar(64) DEFAULT '1' COMMENT '1:流程管理用户 2：管理员或者超级管理员', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=10089 DEFAULT CHARSET=utf8 COMMENT='运营后台用户表'; 用户的组织角色和岗位信息123456789101112CREATE TABLE `sys_job` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `org_id` int(11) NOT NULL DEFAULT '0' COMMENT '组织id', `job_name` varchar(255) NOT NULL DEFAULT '0' COMMENT '表单id', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', `user_id` int(11) NOT NULL COMMENT '用户id', `role_id` varchar(64) DEFAULT NULL COMMENT '用户关联组的角色', `claim_type` varchar(12) DEFAULT '1' COMMENT '认领类型 1：可以认领任务 2：不能认领任务', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1084 DEFAULT CHARSET=utf8mb4 COMMENT='判断用户的组织和岗位'; 后台角色表1234567891011CREATE TABLE `sys_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` int(11) DEFAULT NULL COMMENT '角色类型', `name` varchar(20) DEFAULT NULL COMMENT '角色名', `flow_id` varchar(255) NOT NULL COMMENT '流程角色id', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', `note` varchar(255) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=47 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT='后台角色表'; 后台权限表123456789CREATE TABLE `sys_permission` ( `id` int(11) NOT NULL DEFAULT '0' COMMENT '自定id,主要供前端展示权限列表分类排序使用.', `menu_code` varchar(255) DEFAULT '' COMMENT '归属菜单,前端判断并展示菜单使用,', `menu_name` varchar(255) DEFAULT '' COMMENT '菜单的中文释义', `permission_code` varchar(255) DEFAULT '' COMMENT '权限的代码/通配符,对应代码中@RequiresPermissions 的value', `permission_name` varchar(255) DEFAULT '' COMMENT '本权限的中文释义', `required_permission` tinyint(1) DEFAULT '2' COMMENT '是否本菜单必选权限, 1.必选 2非必选 通常是\"列表\"权限是必选', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='后台权限表'; 角色-权限关联表123456789CREATE TABLE `sys_role_permission` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_id` int(11) DEFAULT NULL COMMENT '角色id', `permission_id` int(11) DEFAULT NULL COMMENT '权限id', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8 COMMENT='角色-权限关联表'; 逻辑设计用户配置岗位信息举例: 固收分管领导及总裁 账号是 admin11 关联的岗位job信息是1015 岗位信息包含当前系统中所有的岗位 岗位信息关联角色当前系统所有的角色信息 固收分管领导及总裁 流程角色id是user88 角色id是 39 给角色对应的权限当前角色对应权限表中的某些权限 固收分管领导及总裁的角色id是39 所以需要给role_id配置不同的权限. 下面配置了4个权限,具体权限内容可以在权限表中查看 配置所有的权限列表存储系统中不同粒度的权限 包含但不止 其中如果想要分配子权限必须拥有顶级权限 其他问题最后: 如何一个账号对应多个第三方系统的角色 有两种解决方案 理论上来讲它也是当前系统中的一种权限,所以把它加到系统权限表中,之后配置角色的时候来添加不同的第三方角色 如果你觉得第一种比较麻烦,可以在你当前系统的角色表中添加一个第三方系统角色的ID来标识,这样有一个缺点就是无法添加多个角色,不过也有解决办法,就是新建一张表来维护与第三方的角色关系. 角色继承的问题 一个user对应多个岗位 一个岗位对应一个角色 延伸 可以在用户user和岗位job两个表中间添加一个关联表 用户和岗位关联起来 岗位是初始化指定角色权限的个人岗位job 初始化的时候角色和岗位是一对一的 后期添加操作修改权限是针对岗位来操作的 举个例子 张三是程序员岗位的角色后来申请可以操作DB的权限 在数据库中是张三这个岗位可以操作DB 并不是程序员这个角色可以操作DB 上面这种架构系统对继承角色非常麻烦, 要么循环当前角色来继承他的权限,要么多维护一张表.或者可以读下关于RBAC3的继承逻辑. RBAC参考文献 http://csrc.nist.gov/groups/SNS/rbac/index.html http://csrc.nist.gov/groups/SNS/rbac/faq.html","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"浅谈jvm","slug":"jvm","date":"2020-04-09T16:00:00.000Z","updated":"2020-06-18T03:29:55.286Z","comments":true,"path":"2020/04/10/jvm/","link":"","permalink":"http://yoursite.com/2020/04/10/jvm/","excerpt":"","text":"GC的基础知识1.什么是垃圾简单来讲没有任何引用指向的一个对象或者多个对象（循环引用）就是垃圾. 引用又分为强引用，软引用，弱引用，虚引用。 强引用（Strong Reference）：这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象,当内存不够的时候只会抛出OOM异常 1Object obj = new Object(); 软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。 1SoftReference soft = new SoftReference(user); 弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。 虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。 2.如何寻找垃圾 引用计数 java没有在用这种算法,它需要单独维护一个引用计数器 目前OkHttp,netty在用故不在本章节讨论范围. 根可达算法 所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局 部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。 这种算法的基本思路： （1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。 （2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。 （3）重复（2）。 （4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。 常见的根节点(起始点)（1）虚拟机栈中引用的对象（栈帧中的本地变量表）；（2）方法区中的常量引用的对象；final 常量名=值;（3）方法区中的类静态属性引用的对象 static；（4）本地方法栈中JNI（Native方法）的引用对象。（5）活跃线程。 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 1.如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。 2.如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。 3.常见的垃圾回收算法 标记清除 - 位置不连续 产生碎片 拷贝算法 - 没有碎片，浪费空间 标记压缩 - 没有碎片，效率偏低 4.JVM内存分代模型（用于分代垃圾回收算法） 新生代 + 老年代 + 永久代（1.7）/ 元数据区(1.8) Metaspace 永久代 元数据 - Class 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存） 字符串常量 1.7 - 永久代，1.8 - 堆 MethodArea逻辑概念 - 永久代、元数据 新生代 = Eden + 2个suvivor区 YGC回收之后，大多数的对象会被回收，活着的进入 s0 再次YGC，活着的对象eden + s0 -&gt; s1 再次YGC，eden + s1 -&gt; s0 年龄足够 -&gt; 老年代 （15 CMS 6） suvivor区装不下 -&gt; 老年代 老年代 顽固分子 老年代满了FGC Full GC GC Tuning (Generation) 尽量减少FGC MinorGC = YGC MajorGC = FGC 5.常见的垃圾回收器 Serial 年轻代 串行回收 PS 年轻代 并行回收 ParNew 年轻代 配合CMS的并行回收 SerialOld ParallelOld ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms) G1(10ms) ZGC (1ms) PK C++ Shenandoah Eplison 1.8默认的垃圾回收：PS + ParallelOld 6.JVM调优第一步，了解生产环境下的垃圾回收器组合jvm运行时数据分析在区域中一般分为五块 运行时数据区域 计数器 通过改变这个计数器的值来获取下一条需要执行的字节码,包括判断 循环,跳转,异常处理 方法区(method Area) 该区域用来存放我们生成的各种对象信息 虚拟机栈(VM stack) 每个类 都会在执行的时候创建一个栈帧(javap -c -s xxx.class)来存放关于这个类的所有信息. 包括方法内的局部变量,以及各种操作帧数, 动态链接(各种引用)及方法的出口返回值等等。每个方法的调用到结束意味着虚拟机的栈桢的入栈到出栈, 堆(heap) 在遇到new指令后 我们会根据相对应的内存引用 来找如果有就引用 没有的话就执行类加载 Java 类加载过程那一套东西 本地方法栈(native mathod stack) 存放本地原生调用方法和虚拟机栈一样只不过内容是原生计算机内的C方法 native是与C++联合开发的时候用的 所以一般开发不会用到 前面在堆中说了类引用会检查是否已经加载过当前需要的类 如果没有加载则会去加载 那么类的加载过程就是下面要说的 当程序用到某个类但这个类还没有加载到内存中,jvm会通过加载,连接,初始化来对这个类进行初始化 加载 jvm通过类的全类名来获取字节流 (也就是.class文件) 然后根据字节流创建class对象 创建完成后写入到内存中,然后放在运行时区域的方法区内(method Area) 然后在堆(heap)中创建出对应的Class对象 链接 分为三部分 验证语法 满足jvm虚拟机规范 准备阶段 为类的静态static 分配内存 设置默认值 解析阶段 将符号引用替换为内存引用(直接引用) 初始化 将static修饰的方法或者变量进行初始化,如果有父级引用优先加载父类 那么这个类的加载机制又是什么 它是通过什么来加载的 采用的双亲委派机制 当加载某个类的时候先去询问父类节点是否可以加载 这样既避免了重复加载也防止了注入还提高了效率 常见垃圾回收器组合参数设定：(1.8) -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器 -XX:+UseParNewGC = ParNew + SerialOld 这个组合已经很少用（在某些版本中已经废弃） https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future -XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】 -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC java +XX:+PrintCommandLineFlags -version 通过GC的日志来分辨 Linux下1.8版本默认的垃圾回收器到底是什么？ 1.8.0_181 默认（看不出来）Copy MarkCompact 1.8.0_222 默认 PS + PO java -XX:+PrintFlagsWithComments //只有debug版本能用 JVM的命令行参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html JVM参数分类 标准： - 开头，所有的HotSpot都支持 非标准：-X 开头，特定版本HotSpot支持特定命令 不稳定：-XX 开头，下个版本可能取消 -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal 最终参数值 -XX:+PrintFlagsInitial 默认参数值 PS GC日志详解每种垃圾回收器的日志格式是不同的！ PS日志格式 heap dump部分： 12eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000) 后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址 total = eden + 1个survivor 调优前的基础概念： 吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间） 响应时间：STW越短，响应时间越好 所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量… 问题： 科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO） 响应时间：网站 GUI API （1.8 G1） 什么是调优？ 根据需求进行JVM规划和预调优 优化运行JVM运行环境（慢，卡顿） 解决JVM运行过程中出现的各种问题(OOM) 调优，从规划开始 调优，从业务场景开始，没有业务场景的调优都是耍流氓 无监控（压力测试，能看到结果），不调优 步骤： 熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） 响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应） 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS] 选择回收器组合 计算内存需求（经验值 1.5G 16G） 选定CPU（越高越好） 设定年代大小、升级年龄 设定日志参数 -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause 或者每天产生一个日志文件 观察日志情况 思维导图 查看地址: https://www.processon.com/embed/5e902d83e401fd32b82a99c2 参考资料 https://blogs.oracle.com/ jonthecollector/our-collectors https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp 《深入理解JVM虚拟机》","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"redis-bitmap","slug":"redis-bitmap","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-07T07:26:11.766Z","comments":true,"path":"2020/04/03/redis-bitmap/","link":"","permalink":"http://yoursite.com/2020/04/03/redis-bitmap/","excerpt":"","text":"1. BitMap 是什么在redis中可以设置用一个bit的位置来标识某个元素的0-1状态, 具体的操作指令是 指定某个key的offset的0或者1的状态 1SETBIT key offset value 计算某个key的被设置为 1 的比特位的数量 1BITCOUNT key [start end] 2. BitMap 怎么用12345678910/** * 设置reids的bitmap位置 * @param key * @param offset 根据需求设置long int * @param value * @return */public Boolean setBit(String key,int offset, Boolean value) &#123; return redisTemplate.execute((RedisCallback&lt;Boolean&gt;) con -&gt; con.setBit(key.getBytes(),(long)offset,value));&#125; 123456789/** * 统计key的所有1值 * @param key * @return */public long bitCount(String key) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) con -&gt; con.bitCount(key.getBytes()));&#125; 3. BitMap 什么时候用 短信验证一分钟不能发送5次 之前我们的做法调用reids的increment方法来自增完成需求 现在我们的做法将当前用户当做key ,拿到当前分钟的毫秒数做offset,最后用bitcount来统计用户在当前分钟数访问次数. 记录用户当前是否在线 之前我们的做法我们需要在数据库字段里标志处是否离线 现在我们的做法找到我们需要的key, 拿用户id做offset,最后我们标记出是否在线 还可以统计当前在线总人数","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"redis","slug":"java/redis","permalink":"http://yoursite.com/categories/java/redis/"}],"tags":[]},{"title":"浅析docker","slug":"docker02","date":"2020-03-09T16:00:00.000Z","updated":"2020-06-18T03:41:09.722Z","comments":true,"path":"2020/03/10/docker02/","link":"","permalink":"http://yoursite.com/2020/03/10/docker02/","excerpt":"","text":"dockerDocker 安装Mac https://docs.docker.com/docker-for-mac/install/Windows https://docs.docker.com/docker-for-windows/install/Ubuntu https://docs.docker.com/install/linux/docker-ce/ubuntu/Debian https://docs.docker.com/install/linux/docker-ce/debian/CentOS https://docs.docker.com/install/linux/docker-ce/centos/Fedora https://docs.docker.com/install/linux/docker-ce/fedora/ 其他 Linux 发行版 https://docs.docker.com/install/linux/docker-ce/binaries/ 镜像加速https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 可以按照阿里云的步骤 操作 容器与镜像 docker pull 拉取镜像image 然后根据镜像image 产生具体的容器 我们最后操作的是容器并不是镜像image client 指的是我们的操作命令 各种pull run 等等,我们可以根据命令来操作dockerHost,registry 是我们的远程仓库,或者说是dockerhub接下来就是我们的整体dockerHost 这里面包含了 整个docker组件, images CONTAINERS 你可以把daemon当做是一个管家来管理docker组件你在client端上的所有操作都会由它来执行 容器生命周期 基础命令pull 拉取镜像文件命令 docker pull mysql:latestdocker pull mysql:8.0.20格式是 : docker pull NAME[:TAG] TAG 默认是 latest images docker images 查看所有已经下拉到本地的镜像 docker images | grep ‘test’ run docker run tomcat 端口转发docker run -p 8000:8080 tomcat -d 后台运行 –name 赋予容器名称 –ip 172.17.0.10 指定启动的ip地址 logs docker logs [容器ID] 查看一个容器的启动日志 ps docker ps 查看所有正在运行容器 (并不是镜像) -a 查看所有容器 stop 将一个已经在运行的容器停止 docker stop [容器ID] kill 与stop不同的是 kill 会将这个容器删除 stop是将这个容器停止 后续还可以继续start使用 rm 使用前容器必须在stop状态下docker rm [容器id] 无需容器在stop状态强制删除 -fdocker rm -f [容器ID] docker rm $(docker ps -a -q) 删除所有容器 强制删除镜像imagesdocker rmi -f [容器ID] 注意点：1. 删除前需要保证容器是停止的 stop2. 需要注意删除镜像和容器的命令不一样。 docker rmi ID ,其中 容器(rm) 和 镜像(rmi)3. 顺序需要先删除容器 exec docker exec -it [id] /bin/bash 进入一个已经存在的容器 inspect docker inspect [容器ID] 查看容器的详细信息 network docker network ls 列出当前存在的网络连接 docker network create my_net 创建一个网桥 类似于网关 -d 设置创建的网络驱动 build docker build -t 机构/镜像名&lt;版本&gt; Dockerfile目录 help docker -h docker run -h DockerFile构建docker build -t 机构/镜像名&lt;版本&gt; Dockerfile目录FROM 基准镜像 基于哪一个来构建的image FROM centos FROM scratch 不依赖任何镜像 FROM mysql:8.0.20 说明信息 MAINTAINER 当前镜像由谁来维护 LABEL version=”V1.0” LABEL description = “” WORKDIR 工作目录 类似cdADD &amp; COPY ADD text.txt / 将当前text文件添加到容器的根目录 ADD text.gz / 添加并解压缩 ENV ENV JAVA_HOME /sur/local/jdk 设置容器环境变量 RUN shell 模式 RUN yum install -y vim exec 模式(推荐) RUN [“yum”,”install”,”-y”,”vim”] ENTRYPOINT 只有最后一个有效 ENTRYPOINT [“ps”] CMD 类似ENTRYPOINT 但是有时候不一定会被执行 建议用ENTRYPOINT CMD 当你的容器启动的时候最后附带参数的话就不会被执行 如果不附带参数的话就会执行当前CMD指令 EXPOSE 对外暴露端口 docker build -t 机构/镜像名&lt;版本&gt; Dockerfile目录docker build -t hki.com/myapp:1.0 .容器间通讯单向通讯 在启动的时候加上一个参数 –link [需要通讯的容器名称] bridge网桥 双向通讯 启动的时候指定网桥来通讯 –network my_net启动的时候多加一个参数来指定当前容器的 网桥是哪个 创建一个网桥 用来通讯 创建一个网桥docker network create my_net 将容器containerr1连接到新建网络my_netdocker network connect my_net container1 将容器containerr2连接到新建网络my_netdocker network connect my_net container2 volume数据共享数据共享分两种 1. 在启动的时候加上-v参数来设置数据卷 2. 先设置一个存档点,然后后续容器启动的时候直接指定这个存档点-v 宿主机文件地址:容器的文件地址创建共享容器来存放数据 docker create –name my_volume -v /usr/test:/usr/local/tomcat/webapps/ tomcat docker run -d -p 8000:8080 –volumes-from my_volume –name test tomcat DockerComposeWindows 和 mac 不需要安装 linux需要 sudo curl -L “https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose k8s 代替了","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"IDEA远程调试","slug":"ideaDebug","date":"2020-02-24T16:00:00.000Z","updated":"2020-04-07T07:54:08.489Z","comments":true,"path":"2020/02/25/ideaDebug/","link":"","permalink":"http://yoursite.com/2020/02/25/ideaDebug/","excerpt":"","text":"远程debug是什么 ?远程debug 原理是利用服务器端口监听来触发本地开发工具IDEA的一种调试手段 什么情况下会用到 ?一般我们本地调试的话会直接在代码中打断点然后debug模式运行代码就可以调试了. 但是我们在实际开发中会遇到一些比较复杂的问题我举几个例子 涉及到调用生产环境会出现的网络问题. 本地运行没问题,只有在测试服务器或者生产环境会出现报错 因为开发系统和服务器系统不一致导致的问题 等等类似这样的问题我们在本地就没办法调试,这时候就需要用到远程服务器调试了. 如何使用远程服务器调试远程调试主要有以下几个步骤 在调试之前我们需要你本地的代码和远程的代码要保持一致 部署上去之后需要加上特定的参数来启动 服务器启动之后在启动本地环境 保持一致就不需要我们详细说了,部署最新版的就可以了. 接下来我们来加上启动参数 原来启动jar包需要的命令1java -jar xxx.jar 如果是远程debug 则需要加上一些参数1java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=4001 xxx.jar 这个参数在idea里可以直接获取到 接下来我们去找如何获取debug参数 菜单 -&gt; Run -&gt; Edit Configurations… 在debug Configurations的弹出框里添加一个remote 之后会弹出一个如下图所示的界面 我们需要配置两个地方.图中的1是我们的服务器地址和端口,端口我们一般默认为4001.也可以自己配置.2是我们需要调试的项目.当这两个配置好后3的位置就会自动生成我们需要的启动参数 之后启动jar的时候添加上 服务器启动好后 在启动本地的remote 注意事项 当发现启动报错 首先检查下你的命令 不要直接复制我的 看你自己生成的代码 保证端口没被占用 本地启动remote会发送请求连接服务器 如果本机无法连接服务器也不行","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"}]},{"title":"迭代器模式","slug":"Iterator","date":"2020-02-10T16:00:00.000Z","updated":"2020-04-28T10:10:39.341Z","comments":true,"path":"2020/02/11/Iterator/","link":"","permalink":"http://yoursite.com/2020/02/11/Iterator/","excerpt":"","text":"查看java代码 Iterator 和 Collection 模式 其原理就是利用了接口实现规则来约束每个array或者link结构来实现他的遍历方式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"策略设计模式实际应用案例","slug":"strategy","date":"2020-01-17T16:00:00.000Z","updated":"2020-04-24T03:15:28.722Z","comments":true,"path":"2020/01/18/strategy/","link":"","permalink":"http://yoursite.com/2020/01/18/strategy/","excerpt":"","text":"设计模式中的策略模式 讲理论的话网上有很多现成的 以前也看了不少 这次特地在实际项目中抽取出来做成笔记 先说说需求根据不同的单据类型选出选出五个教授 其中单据类型有可转债和挂牌两大类 目前可转债和挂牌各有几种选择方式 下面案例我一样拿出一种来 之前的模式在有多种策略选择相似的情况下，使用 if…else 复杂和难以维护,代码阅读起来也比较困难 现在使用策略模式的步骤及简化结果 具体实现步骤 1创建一个接口。 ProfessorStrategy 123456public interface ProfessorStrategy &#123; List&lt;Professor&gt; five(Integer tableId);&#125; 步骤 2创建实现接口的实体类。 EIMProfessorStrategy 12345678public class EIMProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; IPDProfessorStrategy 123456789public class IPDProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; UserStrategy 123456789public class UserStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; 步骤 3创建具体的 find 方法, 你也可以创建一个有泛型的类来使用。 123456789101112131415 /** * 返回接口数据 * @param tableId * @param professorStrategy * @return */ public static List&lt;SysAttendsModel&gt; find(Integer tableId, ProfessorStrategy professorStrategy) &#123;// 获取对应的五个专家 List&lt;Professor&gt; five = professorStrategy.five(tableId); List&lt;SysAttendsModel&gt; sysAttendsModels = new ArrayList&lt;&gt;(); return sysAttendsModels; &#125; 步骤 4使用 find 来查看当它改变策略 Strategy 时的行为变化。 main 12345678910111213public static void main(String[] args) &#123; // 单据id int tableId = 10086; // 挂牌算法 List&lt;SysAttendsModel&gt; list = find(tableId, new EIMProfessorStrategy()); // 可转债算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new IPDProfessorStrategy()); // 会员算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new UserStrategy()); &#125; 代码讲解讲讲上面的代码 大概就和支付策略是一个逻辑 支付前都需要找出二维码 支付后都需要查看是否到账 中间走具体的 现金 or 微信支付 or 支付宝支付 我们不关心 不管后面有多少个支付手段我们就加上相对应的接口的实体类就行了.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"外部jar包打包方式","slug":"jarOpinize","date":"2020-01-01T16:00:00.000Z","updated":"2020-04-01T03:22:43.132Z","comments":true,"path":"2020/01/02/jarOpinize/","link":"","permalink":"http://yoursite.com/2020/01/02/jarOpinize/","excerpt":"","text":"将原本 jar 包解压缩找到 BOOT-INF 下的 lib ,该目录下包含当前项目中用到的所有 jar包 ,复制出来放到jar包启动位置 在 pom 中 spring-boot-maven-plugin 打包插件设置打包时排除所有 jar 包 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt; &lt;!-- 排除所有Jar --&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt;&lt;/plugin&gt; 这个时候需要在jar包启动参数上添加一个 -Dloader.path 1java -Dloader.path=&quot;lib/&quot; -jar test.jar","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"linux语法操作","slug":"shell","date":"2019-12-27T16:00:00.000Z","updated":"2020-04-08T06:44:19.461Z","comments":true,"path":"2019/12/28/shell/","link":"","permalink":"http://yoursite.com/2019/12/28/shell/","excerpt":"","text":"&gt;File1234ls ll ls -l ll -rt &gt;shell base12345Ctrl+w:删除光标前面的单词的字符Ctrl – a ：移到行首Ctrl – e ：移到行尾esc - f : 前移一个词esc - b: 后移一个词 创建文件用touch1例如：touch [1.txt] 删除文件用rm1例如：rm -f [1.txt] 创建目录用mkdir1例如：mkdir [xxx] &#123; -p 参数来创建多级文件夹 &#125; 删除空目录用rmdir1例如：rmdir [xxx]（有东西的目录不能删） 打开文件 1vi vim open cat more less 批量创建 1mkdir -p nginxdb/&#123;conf,conf.d,html,logs&#125; &gt;删除删除装有东西的目录就用 -rfi 例如rm -rfi [XXX]1i是为了提醒 最好加上 &gt;查看文件末尾123Tail -20 [filename]# &gt;经常查看日志需要用到这个tail -f xxx.log -n100 重新命名1Mv [old.text] [new.text] &gt;杀死进程1Kill [pid] pkill和阿里源码里学的直接删除程序对应的进程1pkill -f zwkj-0.0.1-SNAPSHOT.jar &gt;权限赋予123Chmod -R 777 [目录]建议了解下 linux权限的 0124 组成 这样就知道777怎么来的chown apple/staff xxx &gt;解压1234zip all.zip *.jpgunzip all.zip &gt;Grep 管道查询1234567891011121314151617-A num：匹配到搜索到的行以及该行下面的num行 -B num：匹配到搜索到的行以及该行上面的num行-C num：匹配到搜索到的行以及上下各num行grep -E -B 1 &apos;use time:&apos; /data/home/zhxt/zhxt-test/logs/test.logls | grep &apos;.docx&apos;ls | grep a* (a 开头的)ls | grep &apos;a*&apos; (包含a的)https://www.cnblogs.com/kongzhongqijing/articles/4462793.html &gt;查看历史输入的命令123cat ~/.bash_historyhistory | head -20 &gt;查看执行文件的路径1whereis mysql &gt;读取文件1Cat [filename] &gt;查询文件123find [path_root] -name &apos;*.doc*&apos;find / -name [xxx] -dlocate &gt;查看某个端口是否被占用 习惯用lsof 不想用netstat123456安装 yum install lsof -y lsof -i tcp:8080 (PS 必须用root权限) netstat -tunlp|grep [端口号]ps -axu|grep [java] 启动位置输出 &gt;文件下载1wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.zip --no-check-certificate &gt;scp下载123scp -P 2204 isinonet@106.37.74.50:/home/gzzx/excel/ProfessionReport18584791024.xlsx /Users/apple/Documentsscp -P 2204 isinonet@106.37.74.50:/logs/test.log /Users/apple/Documents-r 文件夹 -p端口 &gt;上传服务器文件移动12scp /Users/apple/Documents/zwsj-category-0.0.1-SNAPSHOT.jar root@192.168.0.118:/home/zwsjObjScp -r &gt;其他查看磁盘容量12df -hl /xxx 查看位置12which java rpm包安装12rpm -ivh **.rpm 后台运行命令12Nohup 详细指南 该命令用来列出目前与过去登录系统的用户相关信息12Last Linux查看文件夹大小12du -sh 查看当前文件夹大小12du -sh * | sort -n 统计当前文件夹(目录)大小，并按文件大小排序12du -sk filename 查看指定文件大小 遇到其他不会的命令实例可以按照这个命令来查看基础语法1tldr mkdir","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"多线程与高并发(基础知识)","slug":"JUC02","date":"2019-12-27T16:00:00.000Z","updated":"2020-06-18T03:43:08.907Z","comments":true,"path":"2019/12/28/JUC02/","link":"","permalink":"http://yoursite.com/2019/12/28/JUC02/","excerpt":"","text":"JUC基本知识实现方式 继承thread .strat() 实现runable接口 new Thread(new MyRunable()).start() 匿名函数实现 new Thread(()-&gt;{System.out.println(&quot;Hello Lambda!&quot;); }).start(); 启动线程的三种方式 1：Thread 2: Runnable 3:Executors.newCachedThrad yield 让出资源进入等待队列 join 调用其他线程 线程状态迁移图 wait &amp; notify notify 不释放锁 ,需要手动将当前线程wait, 让出锁 notify才能生效 notifyAll 是让所有线程都醒过来去争抢锁 wait 和 await await//此时当前线程释放lock锁，进入[等待状态]，等待其他线程执行 signal()时才有可能执行 signal() //此时当前线程释放obj锁，随机唤醒一个处于等待状态的线程，继续执行wait后面的程序。 使用wait要用notify/notifyAll唤醒 使用await要用signal/signalAll唤醒 synchronized 悲观锁 在对象头中有一个64位的对象头 markword其中有一个2位的标识符 00 - 11 共四个状态来标志这个锁对象 还有一位来标识是否是偏向锁 this 和 锁住某个对象意义是一样的 锁方法和锁住整块代码意义也是一样的 synchronized static 锁住的是 XX.class sychronized 是可重入锁 , 同一个锁可以相互调用,也就是说如果锁的是同一个对象那么可以相互调用 sychronized 如果抛出异常会释放锁,这样的话会导致其他线程拿到锁之后执行业务逻辑,所以需要做try处理 synchronized 锁的对象不能是String常量 ,Integer ,Long synchronized(this) 的锁升级过程 无锁状态当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁， 只需测试Mark Word里线程ID是否为当前线程。因为没人和它竞争所以就没必要加锁 如果后来有线程进来对比发现线程ID和自己不一样 则发生竞争 偏向锁如果判断发现ThreadID和自己不一样，则下一步需要判断偏向锁的标识。如果标识被设置为0（表示当前是无锁状态），则使用CAS(原子操作)竞争锁； 如果标识设置成1（表示当前是偏向锁状态），则尝试使用CAS将对象头的偏向锁指向当前线程，触发偏向锁的撤销。 偏向锁只有在竞争出现才会释放锁。当其他线程尝试竞争偏向锁时，程序到达全局安全点后（没有正在执行的代码），它会查看Java对象头中记录的线程是否存活，如果没有存活，那么锁对象被重置为无锁状态， 其它线程可以竞争将其设置为偏向锁； 如果存活，那么立刻查找该线程的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程，撤销偏向锁，升级为轻量级锁， 如果线程1不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。 3.轻量级锁 线程在执行同步块之前， JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的MarkWord复制到锁记录中，即Displaced Mark Word。 然后线程会尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁。如果失败，表示其他线程在竞争锁，当前线程使用自旋来获取锁。 当自旋次数达到一定次数时，锁就会升级为重量级锁。 轻量级锁解锁时，会使用CAS操作将Displaced Mark Word替换回到对象头，如果成功，表示没有竞争发生。 如果失败，表示当前锁存在竞争， 锁已经被升级为重量级锁，则会释放锁并唤醒等待的线程。 当自旋超过10次之后 我们会进入os的等待队列 退出CPU的资源 然后向系统资源申请重量级锁 *注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。 volatile 1.线程间可见 缓存一致性协议 2.禁止jvm重排序 线程在分配内存的时候 分三步 1.申请内存,2赋值,3引用指向, 当执行步骤为132的时候 会出现还没有赋值但是对象不为空的问题 JMM模式 jmm模型中有8个指令完成数据的读写, 其中 load store 指令相互组成的4个内存屏障实现指令重排序 注意: 和synchronized 不同的是 volatile可以保证可见性但并不能保证原子性, synchronized可以都保证. ThreadLocal 线程间各占一份 互不影响 static ThreadLocal tl = new ThreadLocal&lt;&gt;(); 使用完成后必须remove调 不然会产生内存泄露 JUC同步锁CAS (Compare And Set ) 无锁优化| 自旋锁 | 乐观锁 atomic包中的都是CAS操作 cas(V, Expected, NewValue) 有三个参数需要注意, v本次的对象, Expected 期望的值, NewValue 新的值 如果发现期望的值和现在的不一样那么就重新轮询一次获取新值 CAS自旋原理 在解释一下cas (操作对象， 期望值，更新值) 如果发现期望值不一样 则重新读取内存当中的值if(当前值== 期望值){ 当前值 = 更新值}else{ 重新获取值} CPU源语支持 不存在指令重排序 ABA问题 解决方法就是加一个版本号 不停地增加 AtomicStampedReference increment 高并发递增值的方法 sync atomicXXXX LongAdder 高并发情况下效率最高 采用跳表实现 分段锁 ReentrantLock 类似snychronized可以使用 .lock() nulock() 来锁代码 trylock(time)尝试去拿锁， 如果规定时间内拿不到锁则继续执行，拿到了就加锁执行 lockInterruptibly在一个线程等待锁的过程中可以被打断如果一个线程开启锁的方式是lockInterruptibly()那么这个线程可以调用.interrupt()被打断 new ReentrantLock(true)如果设置成公平锁，新的线程在竞争锁的时候回去检查队列里面是否有线程在等待 如果有则进入队列进行排队取锁 CountDownLatch 门闩 使用环境是在于并发转换文件 当转换完成后需要继续执行业务Thread[] threads = new Thread[100]; CountDownLatch latch = new CountDownLatch(threads.length); 当执行完成某个后需要调用latch.countDown(); 当全部执行完成后 latch.await()后继续之后的逻辑 CyclicBarrier 线程栅栏 当任务达到一定数量后再执行并发操作 积攒一定数量的任务当数量达到阈值后开始执行任务 Phaser (feize) 升级版的CyclicBarrier , 可以控制执行阶段 就是一个业务分为十个阶段,每个阶段都需要并发执行,只有当上个阶段的都执行完才能执行下一个阶段, arriveAndAwaitAdvance() arriveAndDeregister() ReadWriteLock 共享锁 | 排他锁 | 读写锁 写锁 是排他锁 , 读锁是共享锁. 类似读写分离吧, 读操作可以并发,写操作在后续执行static ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); static Lock readLock = readWriteLock.readLock(); static Lock writeLock = readWriteLock.writeLock(); Semaphoer 信号量 , 信号灯 0 - 1 可以设置数量Semaphore s = new Semaphore(2); 可以设置公平锁Semaphore s = new Semaphore(2, true); 使用场景 限流 (车道-收费站) semaphoer和lock的区别 Exchanger 线程间通讯 s = exchanger.exchange(s); 当线程运行到这段代码后会阻塞等待交换 Locksupport part 停车 或者 停止 unpart 开始 或者 启动 AQS (AbstractQueuedSynchronized)ReentrantLock – sync – AQS维护了一个双向链表队列- 所有人去抢 status这个状态值 它用volatile 修饰 后续会用CAS操作更改值锁住链表最后一个节点然后用CAS来操作公平锁和非公平锁的区别是会去尝试通过CAS来操作如果不成功则进入队列 成功抢到锁则运行强软弱虚 引用强 new Object()软 SoftReference 软引用在系统内存不够用的时候会回收 主要用来做缓存 弱waekReference 只要遭遇GC,就会回收只要进行一次GC,就会回收 TheadLocal 使用了弱引用中的entryentry继承自弱引用 , 如果当前线程存在则不会回收,如果当前线程消失可能会存在内存泄露,但是使用弱引用泄露的概率就很小了 虚phantomReterence 当你的框架或者是项目需要使用对外内存可能会用到这个引用 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。虚引用和弱引用对关联对象的回收都不会产生影响，如果只有虚引用活着弱引用关联着对象，那么这个对象就会被回收。它们的不同之处在于弱引用的get方法，虚引用的get方法始终返回null,弱引用可以使用ReferenceQueue,虚引用必须配合ReferenceQueue使用。 jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。 事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。 同步容器Collections 单个数据进出 List 完全没锁 线程不安全, 需要手动加锁来处理任务 CopyOnWrite 写-时-复制 也就是说 在写的时候复制一份对象 如果一个业务写的业务较少 读取的业务较多的时候 可以考虑用这个， 其本质上来讲就是一个ReadWriteLock CopyOnWriteList /** Appends the specified element to the end of this list.* @param e element to be appended to this list @return {@code true} (as specified by {@link Collection#add})*/public boolean add(E e) {final ReentrantLock lock = this.lock;lock.lock();try {Object[] elements = getArray();int len = elements.length;//重点是这一句话Object[] newElements = Arrays.copyOf(elements, len + 1);newElements[len] = e;setArray(newElements);return true;} finally {lock.unlock();}} CopyOnWriteSet /** A version of addIfAbsent using the strong hint that given recent snapshot does not contain e.*/private boolean addIfAbsent(E e, Object[] snapshot) {final ReentrantLock lock = this.lock;lock.lock();try {Object[] current = getArray();int len = current.length;if (snapshot != current) {// Optimize for lost race to another addXXX operationint common = Math.min(snapshot.length, len);for (int i = 0; i &lt; common; i++)if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0)return false; }Object[] newElements = Arrays.copyOf(current, len + 1);newElements[len] = e;setArray(newElements);return true;} finally {lock.unlock();}} ArrayList 未考虑多线程安全（未实现同步） Set vector Vector 线程安全 大部分关键方法都加了锁但是可能出现锁与锁之间的共享问题 还是会出现线程不安全就是两个方法虽然都加了锁但是 调用过程中会出现问题 Queue 面对高并发准备 (*高并发,多线程) 内部使用的是CAS来操作数据 ConcurrentLinkedQueue 和Queue 的区别offer -&gt; add 会有返回值peek -&gt; getpoll -&gt; get remove - ArrayBlockingQueue - 数组阻塞队列 strs.offer(“aaa”, 1, TimeUnit.SECONDS);当内容满了之后就会等待阻塞 如果后面加上时间参数则会等待规定的时间后返回false 继续执行 - LinkedBlockQueue - 链表实现的阻塞队列 在ConcurrentLinkedQueue基础上添加了方法 put 如果满了就等待 take 如果空了就等待 底层实现是利用了part 和unpart 类似之前面试题用到的 wait notify - DelayQueue - 按照等待时间排序 也是阻塞队列的一种 BlockingQueue 按照时间进行任务调度可以用这个 本质上是PriorityQueue - SychronusQueue 同步 - 本质上和exchange线程差不多 线程size为0 所以不能add 不能往里面装东西 会阻塞等待消费者进行消费 put take - TransferQueue - 需要得到一个线程完成的标记或者是结果 可以用这个 Map 键值对K-V HashMap HashTable 刚开始设计的时候只有这个,所有方法都加了锁的 线程是安全的 但是性能不是很高 HashMap 后来意识到之后就把锁都给取消了 , 所有方法都没有加锁 线程不安全 但是性能较高 SynchronizedHashTable 后来觉得锁的粒度放细一点,只在具体调用函数的代码块来锁 其实和HashTable本质上并没什么区别. ConcurrentHashMap 无序集合 高并发使用 采用了跳表的形式虽然写的时候不如 HashTable高 但是读起来性能高很多 ConcurrentSkipListMap 有序集合线程安全高并发使用 跳表实现原理 读取效率高 LinkedHashMap 里面维护了一个 LinkedKeySet 非线程安全 TreeMap WeakHashMap identityHashMap 面试题背过 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法， 能够支持2个生产者线程以及10个消费者线程的阻塞调用 注意点: 1.wait 和await的区别 2. lock 和unlock 要全部包住代码 put get 并发和并行 Concurrent VS Parallel 并发指的是任务同时到达某个接口 并行指的是多个CPU同时去处理某个事情 并行是并发的子集 线程池ExecutorServices -&gt; Executor 线程池 里面拥有很多操作线程的方法 awaitTermination invokeAll invokeAny isShutdown isTerminated shutdown shutdownNow submit ExecutorServeices.submit 之后是异步执行的 不影响主线程 基本知识 Callable(String) 一个有返回值的线程 Future Future submit = executorService.submit(() -&gt; {return &quot;&quot;; });submit.get(); 线程池提交一个线程之后会返回这个线程的future 我们可以get它的返回值 提交是异步 get是阻塞的 FutureTask 用来存放Callable的返回值 –public FutureTask(Callable callable) 如果想拿到的话 直接调用 FutureTask.get() 这个方法是阻塞的相当于直接拿到这个线程的返回值 不需要生成线程池 CompletableFuture 组合各个线程的返回结果然后统一返回一个结果 两种线程池的自定义方式 ThreadPoolExecutor ThreadPoolExecutor -&gt; AbstractExecutorService -&gt; ExecutorService -&gt; Executor ThreadPoolExecutor tpe = new ThreadPoolExecutor(2, 4, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); corePoolSize 核心线程 maxPoolSize 可扩展的最大线程 keepAliveTime 如果一个线程空闲时间超过设定值则讲线程紫苑交给操作系统 核心线程永远活着 不过有个方法可以设置核心线程参不参与归还资源 TimeUnit 时间单位 queue BolckingQueue线程队列当核心线程满了之后 后续任务进入的等待队列 threadFactory DefaultThreadFactory 线程池的工厂类实现 ThreadFactory 接口 里面有一个newThread 自己去实现具体的线程public Thread newThread(Runnable r) {Thread t = new Thread(group, r,namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon())//设置线程守护t.setDaemon(false);if (t.getPriority() != Thread.NORM_PRIORITY)//设置优先级t.setPriority(Thread.NORM_PRIORITY);return t;} rejectedExecutionHandler 拒绝策略 线程池满了 并且 任务队列也满了 然后启动的非核心线程数也满了 会执行拒绝策略 - JDK默认提供了四种拒绝策略 - Abort 抛异常 - Discard 扔掉,不抛异常 - DiscardOldest 扔掉排队时间最久的 - CallerRuns 调用处理任务 哪个线程调用的哪个去处理 非异步处理 - 我们也可以去自定义自己的拒绝策略 实现 implements RejectedExecutionHandler接口完成rejectedExecution方法 - 自定义拒绝策略 static class MyHandler implements RejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { //log(&quot;r rejected&quot;) //save r kafka mysql redis //try 3 times if(executor.getQueue().size() &lt; 10000) { //try put again(); } } } ForkJoinPool ForkJoinPool -&gt; AbstractExecutorService -&gt; ExecutorService -&gt; Executor 主要用来处理CPU密集型的任务 每个线程有自己的任务队列 把大任务切分成一个一个的小任务来执行然后再汇总结果 newWorkStealingPoolnew ForkJoinPool(Runtime.getRuntime().availableProcessors(),ForkJoinPool.defaultForkJoinWorkerThreadFactory,null, true); JDK默认的线程池的实现 Executors -线程池的工厂 SingleThreadExecutor 单例的线程池 里面只有一个线程new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); newCachedThreadPool 里面拥有核心线程池为0, 可以扩展最大的为int最大值new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); newFixedThreadPool 核心线程和扩展线程都是固定的值 可以通过计算 一般是CPU的核心线程数+1new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); newScheduledThreadPool 定时任务线程池可以用框架代替Quartz cron super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); 以上四个线程池底层都是ThreadPoolExecutor来实现的 Disruptor维护一个环形数组队列 首尾相连目前性能最高的MQ","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"vimrc配置文件","slug":"vimrc","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-19T09:19:22.865Z","comments":true,"path":"2019/12/18/vimrc/","link":"","permalink":"http://yoursite.com/2019/12/18/vimrc/","excerpt":"","text":"替换了本地的自带的vi 采用了 macvim 安装方法通过 brew 1brew install macvim 安装过程需要xcode的支持 下载时间比较长耐心等待下 可能会报错 具体解决原有看报错后的日志 之后需要修改.bash_profile 123alias vi=vimalias vim=mvimalias mvim=&apos;/usr/local/bin/mvim -v&apos; 安装完成后 去配置vim的 .vimrc文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&quot;=========================================================================&quot; DesCRiption: 适合自己使用的vimrc文件，for Linux/Windows, GUI/Console&quot;&quot; Last Change: 2019年08月02日 15时13分 &quot;&quot; Version: 1.80&quot;&quot;=========================================================================set nocompatible &quot; 关闭 vi 兼容模式syntax on &quot; 自动语法高亮set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot; 设定 tab 长度为 4set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录filetype plugin indent on &quot; 开启插件set backupcopy=yes &quot; 设置备份时的行为为覆盖set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan &quot; 禁止在搜索到文件两端时重新搜索set incsearch &quot; 输入搜索内容时就显示搜索结果set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码&quot; set showmatch &quot; 插入括号时，短暂地跳转到匹配的对应括号&quot; set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set hidden &quot; 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start&quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ %c:%l/%L%)\\ &quot; 设置在状态行显示的信息set foldenable &quot; 开始折叠set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度setlocal foldlevel=1 &quot; 设置折叠层数为&quot; set foldclose=all &quot; 设置为自动关闭折叠 &quot; nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot; 用空格键来开关折叠&quot; return OS type, eg: windows, or linux, mac, et.st..function! MySys()if has(&quot;win16&quot;) || has(&quot;win32&quot;) || has(&quot;win64&quot;) || has(&quot;win95&quot;)return &quot;windows&quot;elseif has(&quot;unix&quot;)return &quot;linux&quot;endifendfunction&quot; 用户目录变量$VIMFILESif MySys() == &quot;windows&quot;let $VIMFILES = $VIM.&apos;/vimfiles&apos;elseif MySys() == &quot;linux&quot;let $VIMFILES = $HOME.&apos;/.vim&apos;endif&quot; 设定doc文档目录let helptags=$VIMFILES.&apos;/doc&apos;&quot; 设置字体 以及中文支持if has(&quot;win32&quot;)set guifont=Inconsolata:h12:cANSIendif&quot; 配置多语言环境if has(&quot;multi_byte&quot;)&quot; UTF-8 编码set encoding=utf-8set termencoding=utf-8set formatoptions+=mMset fencs=utf-8,gbkif v:lang =~? &apos;^\\(zh\\)\\|\\(ja\\)\\|\\(ko\\)&apos;set ambiwidth=doubleendifif has(&quot;win32&quot;)source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8endifelseechoerr &quot;Sorry, this version of (g)vim was not compiled with +multi_byte&quot;endif&quot; Buffers操作快捷方式!nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;&quot; Tab操作快捷方式!nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;&quot;关于tab的快捷键&quot; map tn :tabnext&lt;cr&gt;&quot; map tp :tabprevious&lt;cr&gt;&quot; map td :tabnew .&lt;cr&gt;&quot; map te :tabedit&quot; map tc :tabclose&lt;cr&gt;&quot;窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动&quot;光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的&quot;时候会变得非常方便.nnoremap &lt;C-h&gt; &lt;C-w&gt;hnnoremap &lt;C-j&gt; &lt;C-w&gt;jnnoremap &lt;C-k&gt; &lt;C-w&gt;knnoremap &lt;C-l&gt; &lt;C-w&gt;l&quot;一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;&quot; set fileformats=unix,dos,mac&quot; nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;&quot; nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;&quot; use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result&quot; map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;&quot; map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;&quot; map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;&quot; map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;&quot; 让 Tohtml 产生有 CSS 语法的 html&quot; syntax/2html.vim，可以用:runtime! syntax/2html.vimlet html_use_css=1&quot; Python 文件的一般设置，比如不要 tab 等autocmd FileType python set tabstop=4 shiftwidth=4 expandtabautocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot; 打开javascript折叠let b:javascript_fold=1&quot; 打开javascript对dom、html和css的支持let javascript_enable_domhtmlcss=1&quot; 设置字典 ~/.vim/dict/文件的路径autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dictautocmd filetype css set dictionary=$VIMFILES/dict/css.dictautocmd filetype php set dictionary=$VIMFILES/dict/php.dict&quot;-----------------------------------------------------------------&quot; plugin - bufexplorer.vim Buffers切换&quot; \\be 全屏方式查看全部打开的文件列表&quot; \\bv 左右方式查看 \\bs 上下方式查看&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - taglist.vim 查看函数列表，需要ctags程序&quot; F4 打开隐藏taglist窗口&quot;-----------------------------------------------------------------if MySys() == &quot;windows&quot; &quot; 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = &apos;&quot;&apos;.$VIMRUNTIME.&apos;/ctags.exe&quot;&apos;elseif MySys() == &quot;linux&quot; &quot; 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = &apos;/usr/bin/ctags&apos;endifnnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;let Tlist_Show_One_File = 1 &quot; 不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow = 1 &quot; 如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window = 1 &quot; 在右侧窗口中显示taglist窗口let Tlist_File_Fold_Auto_Close=1 &quot; 自动折叠当前非编辑文件的方法列表let Tlist_Auto_Open = 0let Tlist_Auto_Update = 1let Tlist_Hightlight_Tag_On_BufEnter = 1let Tlist_Enable_Fold_Column = 0let Tlist_Process_File_Always = 1let Tlist_Display_Prototype = 0let Tlist_Compact_Format = 1&quot;-----------------------------------------------------------------&quot; plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。&quot; \\m mark or unmark the word under (or before) the cursor&quot; \\r manually input a regular expression. 用于搜索.&quot; \\n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .&quot; \\* 当前MarkWord的下一个 \\# 当前MarkWord的上一个&quot; \\/ 所有MarkWords的下一个 \\? 所有MarkWords的上一个&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录&quot; :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree&quot; o 打开关闭文件或者目录 t 在标签页中打开&quot; T 在后台标签页中打开 ! 执行此文件&quot; p 到上层目录 P 到根目录&quot; K 到第一个节点 J 到最后一个节点&quot; u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）&quot; r 递归刷新当前目录 R 递归刷新当前根目录&quot;-----------------------------------------------------------------&quot; F3 NERDTree 切换map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;&quot;-----------------------------------------------------------------&quot; plugin - NERD_commenter.vim 注释代码用的，&quot; [count],cc 光标以下count行逐行添加注释(7,cc)&quot; [count],cu 光标以下count行逐行取消注释(7,cu)&quot; [count],cm 光标以下count行尝试添加块注释(7,cm)&quot; ,cA 在行尾插入 /* */,并且进入插入模式。 这个命令方便写注释。&quot; 注：count参数可选，无则默认为选中行或当前行&quot;-----------------------------------------------------------------let NERDSpaceDelims=1 &quot; 让注释符与语句之间留一个空格let NERDCompactSexyComs=1 &quot; 多行注释时样子更好看&quot;-----------------------------------------------------------------&quot; plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释&quot;-----------------------------------------------------------------let g:DoxygenToolkit_authorName=&quot;Asins - asinsimple AT gmail DOT com&quot;let g:DoxygenToolkit_briefTag_funcName=&quot;yes&quot;map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;map &lt;leader&gt;df :Dox&lt;CR&gt;map &lt;leader&gt;db :DoxBlock&lt;CR&gt;map &lt;leader&gt;dc a /* */&lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;&quot;-----------------------------------------------------------------&quot; plugin – ZenCoding.vim 很酷的插件，HTML代码生成&quot; 插件最新版：http://github.com/mattn/zencoding-vim&quot; 常用命令可看：http://nootn.com/blog/Tool/23/&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin – checksyntax.vim JavaScript常见语法错误检查&quot; 默认快捷方式为 F5&quot;-----------------------------------------------------------------let g:checksyntax_auto = 0 &quot; 不自动检查&quot;-----------------------------------------------------------------&quot; plugin - NeoComplCache.vim 自动补全插件&quot;-----------------------------------------------------------------let g:AutoComplPop_NotEnableAtStartup = 1let g:NeoComplCache_EnableAtStartup = 1let g:NeoComplCache_SmartCase = 1let g:NeoComplCache_TagsAutoUpdate = 1let g:NeoComplCache_EnableInfo = 1let g:NeoComplCache_EnableCamelCaseCompletion = 1let g:NeoComplCache_MinSyntaxLength = 3let g:NeoComplCache_EnableSkipCompletion = 1let g:NeoComplCache_SkipInputTime = &apos;0.5&apos;let g:NeoComplCache_SnippetsDir = $VIMFILES.&apos;/snippets&apos;&quot; &lt;TAB&gt; completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;&quot; snippets expand keyimap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)&quot;-----------------------------------------------------------------&quot; plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转&quot; % 正向匹配 g% 反向匹配&quot; [% 定位块首 ]% 定位块尾&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转&quot; SVN/git管理工具&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin – a.vim&quot;----------------------------------------------------------------&quot;让vimrc配置变更立即生效autocmd BufWritePost $MYVIMRC source $MYVIMRC-","categories":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}],"tags":[]},{"title":"spring cloud alibaba","slug":"alibaba","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-16T06:09:32.591Z","comments":true,"path":"2019/12/16/alibaba/","link":"","permalink":"http://yoursite.com/2019/12/16/alibaba/","excerpt":"","text":"spring cloud alibaba nacos 远程配置 | 服务发现和注册ribbon 负载均衡sentinel 熔断监控gateway 网关skywalking 链路追踪rockertMQ 异步通讯seata 分布式事务管理dubbo RPC框架","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"责任链模式","slug":"cor","date":"2019-12-07T16:00:00.000Z","updated":"2020-04-27T07:29:22.701Z","comments":true,"path":"2019/12/08/cor/","link":"","permalink":"http://yoursite.com/2019/12/08/cor/","excerpt":"","text":"123456789101112131415public class Servlet_Main &#123; public static void main(String[] args) &#123; Request request = new Request(); request.str = \"开始 进入: &lt;&gt; 1 \"; Response response = new Response(); response.str = \"结束 退出: \"; FilterChain chain = new FilterChain(); chain.add(new HTMLFilter()).add(new SensitiveFilter()); chain.doFilter(request, response); System.out.println(request.str); System.out.println(response.str); &#125;&#125; 123interface Filter &#123; void doFilter(Request request, Response response, FilterChain chain);&#125; 12345678class Request &#123; String str;&#125;class Response &#123; String str;&#125; 123456789101112131415161718192021222324252627282930313233class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // 进入的时候做的业务逻辑 request.str = request.str.replaceAll(\"&lt;\", \"[\").replaceAll(\"&gt;\", \"]\") + \"HTMLFilter()\"; // 调用下一个chain chain.doFilter(request, response); // 完成后做业务逻辑 response.str += \"--HTMLFilter()\"; &#125;&#125;class SensitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // 进入之前做的业务逻辑 System.out.println(\"拦截器2\"); request.str = request.str.replaceAll(\"1\", \"2\") + \" SensitiveFilter()\"; // 去找下一个chain chain.doFilter(request, response); // 之后的逻辑处理 response.str += \"--SensitiveFilter()\"; &#125;&#125; 1234567891011121314151617181920212223242526272829class FilterChain &#123; List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); int index = 0; public FilterChain add(Filter f) &#123; filters.add(f); return this; &#125; public void doFilter(Request request, Response response) &#123; if(index == filters.size()) &#123; // 做了某些业务后需要返回 System.out.println(\"做了某些业务后需要返回\"); return; &#125; Filter f = filters.get(index); index ++; f.doFilter(request, response, this); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"装饰者模式","slug":"decorator","date":"2019-11-30T16:00:00.000Z","updated":"2020-04-27T07:30:01.470Z","comments":true,"path":"2019/12/01/decorator/","link":"","permalink":"http://yoursite.com/2019/12/01/decorator/","excerpt":"","text":"decorator 装饰器","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"idea 显示run dashboard","slug":"ideaRun","date":"2019-11-19T16:00:00.000Z","updated":"2020-04-08T06:41:57.428Z","comments":true,"path":"2019/11/20/ideaRun/","link":"","permalink":"http://yoursite.com/2019/11/20/ideaRun/","excerpt":"","text":"在最上面的 help -&gt; edit custom VM options 在打开的xml里面添加 -Dide.run.dashboard=true","categories":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"博客MD模板应用","slug":"singleton","date":"2019-10-07T16:00:00.000Z","updated":"2020-05-13T02:05:05.797Z","comments":true,"path":"2019/10/08/singleton/","link":"","permalink":"http://yoursite.com/2019/10/08/singleton/","excerpt":"","text":"\\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"git 忽略已经提交和没提交的文件","slug":"gitignore","date":"2019-10-07T16:00:00.000Z","updated":"2019-12-27T09:23:18.414Z","comments":true,"path":"2019/10/08/gitignore/","link":"","permalink":"http://yoursite.com/2019/10/08/gitignore/","excerpt":"","text":"没有提交的其实一直都知道有这么个功能 但是一直都是手写没有记录 可以先去看下github官方提供的gitignore 里面有各种语言的 gitignore https://github.com/github/gitignore 自己个性化的话 可以在上面的文件基础上修改 在Git工作区的根目录下创建一个特殊的 .gitignore 下面是我自己使用的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/target/**/targettarget!.mvn/wrapper/maven-wrapper.jar###STS###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache###IntelliJIDEA###.idea*.iws*.iml*.ipr###NetBeans###/nbproject/private//build//nbbuild//dist//nbdist//.nb-gradle/#Compiledclassfile*.class#Logfile*.log#BlueJfiles*.ctxt#MobileToolsforJava(J2ME).mtj.tmp/#PackageFiles#*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.pdf.zip.doc 下面是一些语法使用1234567891011121314151617• bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件• /bin: 忽略根目录下的bin文件• /*.c: 忽略 cat.c，不忽略 build/cat.c• debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj• **/foo: 忽略/foo, a/foo, a/b/foo等• a/**/b: 忽略a/b, a/x/b, a/x/y/b等• !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件• *.log: 忽略所有 .log 文件• config.php: 忽略当前路径的 config.php 文件 已经提交但是本地在修改需要忽略的值得注意的是中央仓库已经存在该文件后 需要取消追踪对某个文件取消跟踪 12345git rm --cached readme1.txt # 删除readme1.txt的跟踪，并保留在本地。git add -A # 这里是将所有的改动提交到gitgit commit -m &apos;update local file&apos; 然后git commit 即可。但是git status查看状态时还是会列出来","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"观察者模式","slug":"ObServer","date":"2019-10-07T16:00:00.000Z","updated":"2020-05-13T02:05:05.796Z","comments":true,"path":"2019/10/08/ObServer/","link":"","permalink":"http://yoursite.com/2019/10/08/ObServer/","excerpt":"","text":"简单说下 后续再改 首先这个模式很常见 类似的有 callback function ,listener , hook 都是这样的, 也可以说是一个东西 窗口添加事件 js 回调事件 等等类似的其实本质上都是ObServer模式 首先我们看下main函数运行的代码 12345678910public static void main(String[] args) &#123; Button b = new Button(); b.addActionListener(new MyActionListener()); b.addActionListener(new MyActionListener2()); b.addActionListener((e)-&gt;&#123; System.out.println(\"ppp\"); &#125;); b.buttonPressed();&#125; 因为你之前new Button() 所以我们会实现一个button类 里面会有一个for循环来依次实现你之前添加的事件 就是buttonPressed 里的 for循环 同时还有一个添加事件的方法 12345678910111213141516class Button &#123; private List&lt;ActionListener&gt; actionListeners = new ArrayList&lt;ActionListener&gt;(); public void buttonPressed() &#123; ActionEvent e = new ActionEvent(System.currentTimeMillis(),this); for(int i=0; i&lt;actionListeners.size(); i++) &#123; ActionListener l = actionListeners.get(i); l.actionPerformed(e); &#125; &#125; public void addActionListener(ActionListener l) &#123; actionListeners.add(l); &#125;&#125; 接下来我们需要写 事件类的接口 参数是你具体的事件本身 123interface ActionListener &#123; public void actionPerformed(ActionEvent e);&#125; 添加事件类接口的实现 1234567891011121314151617class MyActionListener implements ActionListener &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"button pressed!\"); &#125; &#125;class MyActionListener2 implements ActionListener &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"button pressed 2!\"); &#125; &#125; 然后是刚刚传的参数你也需要定义 这里我们定义的是 事件本身需要的属性 这里有两个 你可以根据自己的业务需求来判断 123456789101112131415161718192021class ActionEvent &#123; long when; Object source; public ActionEvent(long when, Object source) &#123; super(); this.when = when; this.source = source; &#125; public long getWhen() &#123; return when; &#125; public Object getSource() &#123; return source; &#125; &#125; 一般会和责任链模式配合使用 在返回false后执行失败监听函数","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"docker基本语法","slug":"dockerShell","date":"2019-10-07T16:00:00.000Z","updated":"2020-05-12T06:38:14.847Z","comments":true,"path":"2019/10/08/dockerShell/","link":"","permalink":"http://yoursite.com/2019/10/08/dockerShell/","excerpt":"","text":"查看所有正在运行容器 1$ docker ps 查看所有容器 1$ docker ps -a 查看所有容器ID 1$ docker ps -a -q 启动容器 1$ docker start [NAME] stop停止所有容器 12$ docker stop $(docker ps -a -q) remove删除所有容器 1$ docker rm $(docker ps -a -q) run创建一个新的服务 1docker run -it [NAME] /bin/bash Exec 进入一个已经存在的 1docker exec -it 217a29f3495a /bin/bash 查看容器启动日志 1docker logs [容器ID] -删除容器镜像 image12sudo docker rmi IMAGE [IMAGE...] sudo docker rmi centos:latest 强制删除 实例 1docker rm -f 启动一个实例Container 123sudo docker run [OPTIONS] IMAGE [COMMAND] [ARG...]sudo docker run -t -i contos /bin/bashsudo docker run -p 8080:8080 -d [name]","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"享元模式","slug":"flyweight","date":"2019-10-07T16:00:00.000Z","updated":"2020-04-28T03:42:21.514Z","comments":true,"path":"2019/10/08/flyweight/","link":"","permalink":"http://yoursite.com/2019/10/08/flyweight/","excerpt":"","text":"重点是重复利用对象 类似安卓 的 List组件 RecyclerView 创建一个对象 1234567891011class Bullet &#123; public UUID id = UUID.randomUUID(); boolean living = true; @Override public String toString() &#123; return \"Bullet&#123;\" + \"id=\" + id + '&#125;'; &#125;&#125; 维持一个池子里的key for循环查看key的标签是否可以重复利用 如果可以则返回 不可以说明都在用 这个时候需要new出来了 12345678910111213141516171819public class BulletPool &#123; List&lt;Bullet&gt; bullets = new ArrayList&lt;&gt;(); &#123; for (int i = 0; i &lt; 5; i++) bullets.add(new Bullet()); &#125; public Bullet getBullet() &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet b = bullets.get(i); if (!b.living) return b; &#125; return new Bullet(); &#125; &#125; main函数实际使用 12345678public static void main(String[] args) &#123; BulletPool bp = new BulletPool(); for (int i = 0; i &lt; 10; i++) &#123; Bullet b = bp.getBullet(); System.out.println(b); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"AOP之代理模式","slug":"Proxy","date":"2019-08-17T16:00:00.000Z","updated":"2020-04-28T08:15:20.779Z","comments":true,"path":"2019/08/18/Proxy/","link":"","permalink":"http://yoursite.com/2019/08/18/Proxy/","excerpt":"","text":"在我看来 代理模式 最常用 也最难理解 会得不难 , 难得不会, 在我看来现在理解了代理的运作模式也觉得没有以前想的那么复杂 代理模式说白了就是面向切面编程 AOP 业务和实际切点代码分割 那么重点就在于 如何使在最小修改业务代码的情况下 来完成切点的插入 首先实现一个业务接口 123interface Movable &#123; void move();&#125; 接口具体实现类 123456789101112131415public class Tank implements Movable &#123; /** * 模拟坦克移动了一段儿时间 */ @Override public void move() &#123; System.out.println(\"Tank moving claclacla...\"); try &#123; Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个时候我们有一个新的需求需要在 这段业务前后加入某些逻辑 不管是日志还是权限 这个时候我们需要新建一个代理类 实现 InvocationHandler 接口 然后实现具体的invoke方法 具体逻辑看下图 1234567891011121314151617181920212223242526class TimeProxy implements InvocationHandler &#123; Movable m; public TimeProxy(Movable m) &#123; this.m = m; &#125; public void before() &#123; System.out.println(\"method start..\"); &#125; public void after() &#123; System.out.println(\"method stop..\"); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //Arrays.stream(proxy.getClass().getMethods()).map(Method::getName).forEach(System.out::println); before(); Object o = method.invoke(m, args); after(); return o; &#125;&#125; 最纠结的点可能是 这段代码 method.invoke(m, args); 先放一边 我们看是怎么调用的 main函数调用 12345678910public static void main(String[] args) &#123; Tank tank = new Tank(); //返回的是ASM生成的$Proxy0的方法 后续调用也是调用这个方法的move Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader(), new Class[]&#123;Movable.class&#125;, //tank.class.getInterfaces() new TimeProxy(tank) ); m.move();&#125; 我们给Proxy 传了三个参数 分别是 Tank.class.getClassLoader() 生成的代理对象$Proxy0 我们传的是tank.class 实现的接口是movable 所以ASM生成的代理类对象$Proxy0 也会实现接口movable 同时也会实现里面的方法 move() 可以说 我们把 Movable 传进去告诉ASM 你们给我生成一个实现了Movable接口的类 让我来调用 new Class[]{Movable.class} 也可以写成 1Tank.class.getInterfaces() reflection 通过二进制字节码分析类的属性和方法 就是拿到这个接口类的所有的属性和方法 不明白的话我举个例子 就是 Tank这个类实现的接口是哪个接口类 你要告诉ASM 你也可以直接给我new出来 这个类 也可以通过 Tank拿到他的接口类 new TimeProxy(tank) 这个就是具体的实现类 你具体要给这个接口的哪个实现类实现代理你要给ASM说 这三个参数涉及到 ASM newProxyInstance生成代理类对象的逻辑 可能会有点复杂在这里就不展开谈了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"build 复杂对象构造器","slug":"build","date":"2019-08-17T16:00:00.000Z","updated":"2020-04-29T07:26:49.549Z","comments":true,"path":"2019/08/18/build/","link":"","permalink":"http://yoursite.com/2019/08/18/build/","excerpt":"","text":"Build 模式一般是用来对复杂对象的构造器 一般我们可以对一个复杂对象这样new 12345678910111213public SysMessage(String phone, String comm, LocalDateTime sendTime, Integer status, Integer templateId, String tableId, String name, String role) &#123; this.phone = phone; this.comm = comm; this.sendTime = sendTime; this.status = status; this.templateId = templateId; this.tableId = tableId; this.name = name; this.role = role;&#125; 使用的时候是这样的 123new SysMessage(getTel(), comm, LocalDateTime.now() , getDeleted(), 1006, \"10086\", getName(), \"专家\") 上面这个例子是一个短信模板对象的生成 这样写也可以 如果不想要其中某个我们可以传空 但是这么写在&lt;&gt;中是不推荐这么写的 书中写到如果你要构建复杂对象的话 最好使用build模式来做 1234567891011121314151617181920212223242526272829303132public static class SysMessageBuild&#123; SysMessage sysMessage = new SysMessage(); public SysMessageBuild basicInfo(String role,String name,String phone,String comm) &#123; sysMessage.role = role; sysMessage.name = name; sysMessage.phone = phone; sysMessage.comm = comm; return this; &#125; public SysMessageBuild sendTime(LocalDateTime sendTime)&#123; sysMessage.sendTime = sendTime; return this; &#125; public SysMessageBuild status(Integer status)&#123; sysMessage.status = status; return this; &#125; public SysMessageBuild templateId(Integer templateId)&#123; sysMessage.templateId = templateId; return this; &#125; public SysMessageBuild tableId(String tableId)&#123; sysMessage.tableId = tableId; return this; &#125; public SysMessage build() &#123; return sysMessage; &#125; 最后用一个build方法返回","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"多线程与高并发(基础知识)","slug":"juc","date":"2019-08-17T16:00:00.000Z","updated":"2020-05-13T02:03:52.379Z","comments":true,"path":"2019/08/18/juc/","link":"","permalink":"http://yoursite.com/2019/08/18/juc/","excerpt":"","text":"","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"博客MD模板应用","slug":"A1tamplate","date":"2019-08-17T16:00:00.000Z","updated":"2020-04-28T03:43:53.312Z","comments":true,"path":"2019/08/18/A1tamplate/","link":"","permalink":"http://yoursite.com/2019/08/18/A1tamplate/","excerpt":"","text":"\\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"组合模式","slug":"compsite","date":"2019-08-11T16:00:00.000Z","updated":"2020-04-27T07:29:47.792Z","comments":true,"path":"2019/08/12/compsite/","link":"","permalink":"http://yoursite.com/2019/08/12/compsite/","excerpt":"","text":"组合模式用来处理树状接口 处理树状结构本质上就是查看当前节点是否包含子节点 所以说只需要判断 当前节点下是否有子节点 然后循环遍历 做这个树状结构也只需要 一个节点抽象类 两个节点信息 (一个是下面有节点,一个是没节点的) 一个抽象类 1234abstract class Node &#123; abstract public void p();&#125; 有两个类继承节点信息 区别就是一个类有子节点 一个没有 没有子节点的如下图 12345678910class LeafNode extends Node &#123; String content; public LeafNode(String content) &#123;this.content = content;&#125; @Override public void p() &#123; System.out.println(content); &#125;&#125; 有子节点的如下如 有子节点 意味着需要维护一个list 还需要一个add 方法来添加子节点 12345678910111213141516class BranchNode extends Node &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); String name; public BranchNode(String name) &#123;this.name = name;&#125; @Override public void p() &#123; System.out.println(name); &#125; public void add(Node n) &#123; nodes.add(n); &#125;&#125; 使用的话就是 添加root节点 然后依次添加 大节点和小节点 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; BranchNode root = new BranchNode(\"root\"); BranchNode chapter1 = new BranchNode(\"chapter1\"); BranchNode chapter2 = new BranchNode(\"chapter2\"); Node r1 = new LeafNode(\"r1\"); Node c11 = new LeafNode(\"c11\"); Node c12 = new LeafNode(\"c12\"); BranchNode b21 = new BranchNode(\"section21\"); Node c211 = new LeafNode(\"c211\"); Node c212 = new LeafNode(\"c212\"); root.add(chapter1); root.add(chapter2); root.add(r1); chapter1.add(c11); chapter1.add(c12); chapter2.add(b21); b21.add(c211); b21.add(c212); // 遍历 tree(root, 0); &#125; static void tree(Node b, int depth) &#123; for(int i=0; i&lt;depth; i++) System.out.print(\"--\"); b.p(); if(b instanceof BranchNode) &#123; for (Node n : ((BranchNode)b).nodes) &#123; tree(n, depth + 1); &#125; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"基于SLF4J MDC机制配合AOP实现日志的链路追踪","slug":"slf4jMDC","date":"2019-05-30T16:00:00.000Z","updated":"2020-04-08T06:44:37.502Z","comments":true,"path":"2019/05/31/slf4jMDC/","link":"","permalink":"http://yoursite.com/2019/05/31/slf4jMDC/","excerpt":"","text":"问题描述一个合格的项目必须要有日志来支撑,日志不但能记录输入输出,当系统有问题的时候我们还需要做线上问题的排查. 在一个正常的项目中日志里包含了各种各样的接口及其他无关的数据日志,那么我们如何快速定位单次请求中所有的日志呢 ? 问题分析当我们设计一个系统日志的时候 首先我们需要解决以下几个问题 哪些数据需要写进日志中 日志如何分类 按天还是按周 如何区分每次请求 请求参数及返回值需不需要打印 如何进行多环节配置 解决方案按照上面的问题我们来一个一个解决 主要思路是 AOP 负责切入每个请求及参数打印 在进入 controller 之前打印本次请求的各种参数 MDC 添加 hashCode 来做参数校验 日志使用 logback 配置 日志按天分类,每天生成一个日志 利用 thread 来区分每次请求 springProfile 来做多环境配置 aop 有两种CGLIB,JDK 都是动态代理 今天不讨论这两者的区别 我使用的是 CGLIB pom 中引入 SpringBoot 的 web 模块和使用 AOP 相关的依赖： 定义切面类，实现 web 层的日志切面 对所有的 web 请求做切面来记录日志 第一种 AOP 上 logback 的输出1234567891011121314151617181920// 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null &amp;&amp; joinPoint != null) &#123; HttpServletRequest request = attributes.getRequest(); // 记录请求内容 log.info( \"1. 对象请求的URL : \" + request.getRequestURL().toString()); log.info( \"2. 请求方法名称 : \" + request.getMethod()); log.info( \"3. 对方IP地址 : \" + request.getRemoteAddr()); log.info( \"4. 运行的java类 : \" + joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName()); try&#123; log.info(\"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); &#125;catch (Exception e)&#123; log.info(\"请求参数切点无法切入\"); &#125; &#125;else&#123; throw new CheckException(\"网络请求出错, 请清空缓存重新尝试. \"); &#125; 第二种 request.HashCode 唯一标示在获得 12log.info(request.hashCode()+ \"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); 第三种 基于 SLF4J 的 MDC 机制12MDC.put(\"THREAD_ID\", \"userId\"+ userService.getId() ); 1&lt;pattern&gt;%date [%thread] %-5level %logger&#123;80&#125; %X&#123;THREAD_ID&#125; || %msg%n&lt;/pattern&gt; 第四种 结合 HashCode 和 MDC12MDC.put(\"THREAD_ID\", \"\"+request.hashCode()); 最终效果12345678910112019-06-04 10:14:27,743 [main] INFO com.zwkj.zhxt.ZhxtApplication || Started ZhxtApplication in 48.489 seconds (JVM running for 56.375)2019-06-04 10:15:28,310 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:28,313 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:28,314 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:28,323 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:28,585 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：168 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg=='2019-06-04 10:15:30,860 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || @Around:结果是 :ResultBean com.zwkj.zhxt.controller.SysUserController.findSysUser(UserModel) use time: 25512019-06-04 10:15:30,861 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 282556454: 方法的返回值 : ResultBean(msg=success, code=0, data=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub3ciOiIxNTU5NjE0NTMwMjE2emh4dCIsImtleSI6InVzZXIxMiJ9.ae7ra7hvDSp5N6YfuGYzr8ULeq7Zr5OuC_4PbybqceY) 12345672019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：151 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg==' \\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"spring-boot-ioc 解析","slug":"springBootIOC","date":"2019-05-21T16:00:00.000Z","updated":"2020-04-08T06:44:50.945Z","comments":true,"path":"2019/05/22/springBootIOC/","link":"","permalink":"http://yoursite.com/2019/05/22/springBootIOC/","excerpt":"","text":"内容过期","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"http://yoursite.com/tags/ioc/"}]},{"title":"记一次慢sql的查询记录","slug":"sqlOptimize","date":"2019-05-12T16:00:00.000Z","updated":"2020-04-08T07:04:30.720Z","comments":true,"path":"2019/05/13/sqlOptimize/","link":"","permalink":"http://yoursite.com/2019/05/13/sqlOptimize/","excerpt":"","text":"本质上来讲 sql优化和数据库优化是两种优化 数据库优化包含的种类较多 软件优化,硬件优化 理论上 单个mysql数据库能够支撑的是每秒2000的并发 极限是5000 当然本次不说数据库优化 先说sql优化 sql优化一般是针对单个业务进行优化 比如秒杀 系统的订单查询 (一般用redis 这里只是举个例子) 或者说是对excel表格进行分析插入数据库 等等各种各样的业务 当然一个简单的sql 可能就是这样的 1SELECT * from test WHERE ASSIGNEE_ = 'user1' 但在实际业务环境中可能并不是这样 实际会复杂很多 以及很多条件 当我们在处理这样的sql的时候 应该怎么去优化以及从哪里入手 索引我们大家都是知道索引可以很好的帮我们来提高效率 但是具体怎么用 以及针对某个业务或者单条sql怎么优化 再说这些之前我们先针对SQL进行一些常识性优化 比如 基本优化WHERE 子句里面的列尽量被索引 尽量避免使用 “SELECT *” 如果用到分页 尽量使用物理分页 并非逻辑分页 join列尽量使用索引 order by 使用索引 等等 总之是为了避免全表扫描做出的各种操作 大家应该发现索引的使用还是非常频繁的 那么具体某个sql使用了哪些索引 以及进行了什么处理操作 EXPLAIN 优化我们可以用 EXPLAIN 关键字去查看执行计划 12345678910111213141516EXPLAIN SELECT *FROM professor aWHERE NOT EXISTS ( SELECT * FROM sys_attend b WHERE a.id = b.professor_id AND b.`type` = 1 AND b.table_id = 93353728 ) AND a.polling_status = 1 AND a.status = 1 AND (a.Member_category = 1 OR a.Member_category = 3) AND (organization_category IN (4, 7) OR organization_categoryvice IN (4, 7))LIMIT 0, 2 这张表里大概有这么几个字段 id 执行顺序 可以重复 id相同则从上往下执行 id从大到小执行 select_type 搜索类型 一共有十一种 具体可以看这篇博客SQL_explain操作解释 这里就简单的介绍常见的几种 第一种也是最常见到的一种 SIMPLE 简单的select查询,查询中不包含子查询或者union; PRIMARY:查询中若包含任何复杂的子查询,最外层查询则被标记; 就是刚刚的优先级最外层则会显示PRIMARY SUBQUERY:在select或者where列表中包含了子查询; type 显示的是访问类型，一般我们优化sql就是着重优化这个 , 是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。 一般来说，得保证查询至少达到range级别，最好能达到ref。 那么怎么能达到这个级别呢 ref:非唯一性索引扫描,返回匹配某个单独值得所有行,本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,它可能会找到多个符合条件的行,所以它应该属于查找和扫描的混合体; range:只检索给定范围的行,使用一个索引来选择行,key列显示使用哪个索引,一般就是在你的where语句中出现了between,&lt;,&gt;,in等的查询；这种范围索引扫描比全表扫描要好,因为它只需要开始于索引的某一个点,结束于另一个点,不用扫描全部索引; 之前说的避免全表扫描就是为了这样 possible_keys:显示可能会被应用到这张表的索引,一个或者多个;查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用到; key:实际使用到的索引.如果为null,则没有使用索引;查询中若使用了覆盖索引,则该索引仅出现在key列表中; key_len:表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好; key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的; ref:显示索引的哪一列被使用了,如果可能的话,是一个常数,哪些列或常量别用于查找索引列上的值; rows:根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数; Extra:包含不适合在其它列中显示但十分重要的额外信息: 对于这个消息栏里展示的东西有很多 一般是你的sql违反的数据库相对应的算法,他认为你的不合理 在这里就不详细解释了 当大家出现后可以百度相对应的信息 MySQL中explain执行计划中额外信息字段(Extra)详解 那么根据这些信息我们可以查到需要优化哪些地方 说完 explain 我们可以再说说 explain extended + show warnings 在执行explain extended 之后我们在 show warnings 可以看到在数据库中我们sql的执行方式, 我们可以在这个基础上再次进行优化 我们可以看到sql的执行方式，对于分析sql还是很有帮助的。 ( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; ( 1 ) FROM [ left_table ] ( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; ( 2 ) ON &lt; join_condition &gt; ( 4 ) WHERE &lt; where_condition &gt; ( 5 ) GROUP BY &lt; group_by_list &gt; ( 6 ) WITH &lt; CUBE | RollUP &gt; ( 7 ) HAVING &lt; having_condition &gt; ( 10 ) ORDER BY &lt; order_by_list &gt; 从优先级我们可以看出为什么order by 排序在 group by 之前不生效了 之前那条sql之后后数据库warnings的执行方式是下面这样的123456789101112131415SELECT `zwkj_zhxt`.`a`.`id` AS `id`, `zwkj_zhxt`.`a`.`name` AS `name`, `zwkj_zhxt`.`a`.`sex` AS `sex`,FROM `zwkj_zhxt`.`professor` `a`WHERE ((`zwkj_zhxt`.`a`.`status` = 1) AND (`zwkj_zhxt`.`a`.`polling_status` = 1) AND (not(exists(/* select#2 */SELECT 1FROM `zwkj_zhxt`.`sys_attend` `b`WHERE ((`zwkj_zhxt`.`b`.`table_id` = 93353728) AND (`zwkj_zhxt`.`b`.`sex` = 1) AND (`zwkj_zhxt`.`a`.`id` = `zwkj_zhxt`.`b`.`professor_id`))))) AND ((`zwkj_zhxt`.`a`.`name` = 1) OR (`zwkj_zhxt`.`a`.`name` = 3)) AND ((`zwkj_zhxt`.`a`.`sex` IN (4,7)) OR (`zwkj_zhxt`.`a`.`sex` IN (4,7)))) limit 0,2 从上面还可以看出 and 的优先级 总是高于 or 但有一点需要注意的是 exteneded得到的sql并不是 最终优化执行的sql这一点可以在官方文档中得到确认Extended EXPLAIN Output Format但从优化的角度上来讲也能帮助我们. 一般企业数据库的优化 基本上是 配硬件+差不多的sql优化+分布式+分库分表+读写分离 等等 反正一系列的操作 基本满足80%的业务场景 当然我们优化个别业务需要根据实际场景来优化 如果确实说需要高级别的维护和优化 公司会有相对应的运维或者DB来做很少需要开发者担心","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"db","slug":"java/db","permalink":"http://yoursite.com/categories/java/db/"}],"tags":[{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"launchctl自动化脚本","slug":"macLaunchctl","date":"2019-04-17T16:00:00.000Z","updated":"2020-04-08T06:43:46.133Z","comments":true,"path":"2019/04/18/macLaunchctl/","link":"","permalink":"http://yoursite.com/2019/04/18/macLaunchctl/","excerpt":"","text":"启动1launchctl start con.hki.zhxtgit.plist 查找1launchctl list | grep &apos;con&apos; 加载1launchctl load -w con.hki.zhxtgit.plist 卸载1launchctl unload con.hki.zhxtgit.plist 校验语法1plutil -lint com.hki.zhxtgit.plist plist文件1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Disabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;con.hki.zhxtgit.plist&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Documents/shell/zhxtgit.sh&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;false/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/Documents/shell/run.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/Documents/shell/run.err&lt;/string&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;15&lt;/integer&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;5&lt;/integer&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"自动化脚本","slug":"自动化脚本","permalink":"http://yoursite.com/tags/自动化脚本/"}]},{"title":"git stash 在多分支下的使用","slug":"git_stash","date":"2019-03-07T16:00:00.000Z","updated":"2020-04-28T08:49:17.381Z","comments":true,"path":"2019/03/08/git_stash/","link":"","permalink":"http://yoursite.com/2019/03/08/git_stash/","excerpt":"","text":"1. 前言stash命令叫暂存 平常开发很多情况都会遇到 开发一半的代码线上环境要紧急修复个bug这个时候我们可以把代码暂存起来 常用的有 12345678910111213gsta='git stash save'gstaa='git stash apply'gstc='git stash clear'gstd='git stash drop'gstl='git stash list'gstp='git stash pop'gsts='git stash show --text' 问题这一段时间频繁在各个分支上开发及修改bug导致用到的stash命令挺多的 最近出现一个挺让我纠结的问题就是 在各个分支下stash存放的栈是一样的所以在dev分支下和master分支下你保存的数据都是一个地方 如果你在dev 下save了stash 然后切换master分支你仍然可以apply到你刚刚在dev下保存的代码 下面我们看具体代码 2. 出现原因现在我们文件下有两个文档 123 和 abc 123master &gt; ll-rw-r--r-- 1 apple staff 21B 4 23 15:30 123.txt-rw-r--r-- 1 apple staff 66B 10 29 10:44 abc.txt 现在我们删除一个 123master &gt; rm -rf abc.txttotal 8-rw-r--r-- 1 apple staff 21B 4 23 15:30 123.txt 不提交当前代码 stash保存起来 12master &gt; git stash save \"master save\"Saved working directory and index state On master: master save 切换到生产分支 123456master &gt; git checkout prod切换到分支 'prod'prod &gt; lltotal 16-rw-r--r-- 1 apple staff 21B 4 23 15:30 123.txt-rw-r--r-- 1 apple staff 121B 4 23 16:11 abc.txt 再次修改代码 并且stash保存 123 prod &gt; vi 123.txt prod &gt; git stash save \"prod save\"Saved working directory and index state On prod: prod save 切换分支查看stash list 12345master &gt; git checkout master切换到分支 'master'master &gt; git stash liststash@&#123;0&#125;: On prod: prod savestash@&#123;1&#125;: On master: master save 这个时候显示出了两个保存栈 分别是我在master和prod上保存的代码 如果这个时候你直接git stash apply 会使用最近的一个 也就是你在prod下保存的代码而不是你master的代码 3. 优化使用Stash 有两种保存方式 一种是带消息保存和不带消息保存 上面我演示的是带消息所以能看出来我保存的是哪个分支 所以在使用satsh的时候最好带上当前保存的一个标记语 这样方便我们下次使用的时候拉取 1git stash save \"markword\"","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"Quartz cron语法规则及demo","slug":"quartzCron","date":"2018-12-28T16:00:00.000Z","updated":"2020-04-08T06:44:10.589Z","comments":true,"path":"2018/12/29/quartzCron/","link":"","permalink":"http://yoursite.com/2018/12/29/quartzCron/","excerpt":"","text":"测试在线地址 http://cron.qqe2.com/ 下面是一些demo 每天凌晨2点 0 0 2 ?和每天隔一小时 0 /1 ? 例1：每隔5秒执行一次：/5 * ? 例2：每隔5分执行一次：0 /5 ? 在26分、29分、33分执行一次：0 26,29,33 * ? 例3：每天半夜12点30分执行一次：0 30 0 ? （注意日期域为0不是24） 每天凌晨1点执行一次：0 0 1 ? 每天上午10：15执行一次： 0 15 10 ? 或 0 15 10 ? 或 0 15 10 ? * 每天中午十二点执行一次：0 0 12 ? 每天14点到14：59分，每1分钟执行一次：0 14 * ? 每天14点到14：05分，每1分钟执行一次：0 0-5 14 ? 每天14点到14：55分，每5分钟执行一次：0 0/5 14 ? 每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0/5 14,18 ? 每天18点执行一次：0 0 18 ? 每天18点、22点执行一次：0 0 18,22 ? 每天7点到23点，每整点执行一次：0 0 7-23 ? 每个整点执行一次：0 0 0/1 ? 每天凌晨2点 0 0 2 ?和每天隔一小时 0 /1 ? 例1：每隔5秒执行一次：/5 * ? 例2：每隔5分执行一次：0 /5 ? 在26分、29分、33分执行一次：0 26,29,33 * ? 例3：每天半夜12点30分执行一次：0 30 0 ? （注意日期域为0不是24） 每天凌晨1点执行一次：0 0 1 ? 每天上午10：15执行一次： 0 15 10 ? 或 0 15 10 ? 或 0 15 10 ? * 每天中午十二点执行一次：0 0 12 ? 每天14点到14：59分，每1分钟执行一次：0 14 * ? 每天14点到14：05分，每1分钟执行一次：0 0-5 14 ? 每天14点到14：55分，每5分钟执行一次：0 0/5 14 ? 每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0/5 14,18 ? 每天18点执行一次：0 0 18 ? 每天18点、22点执行一次：0 0 18,22 ? 每天7点到23点，每整点执行一次：0 0 7-23 ? 每个整点执行一次：0 0 0/1 ?","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"异步的观察者模式处理后台任务","slug":"ApplicationEvent","date":"2018-10-07T16:00:00.000Z","updated":"2020-04-28T08:57:59.122Z","comments":true,"path":"2018/10/08/ApplicationEvent/","link":"","permalink":"http://yoursite.com/2018/10/08/ApplicationEvent/","excerpt":"","text":"收到任务说要做一个后台监听文件上传接口 如果有docx文档 需要将任务放在后台进程中 将docx文档转换成pdf文档 首先文档转换不是我们今天要讲的内容 稍后我会开一章来讲 事件监听在spring boot里还是比较容易实现的 有以下几点需要注意 vo实体需要继承 ApplicationEvent 实现接口ApplicationListener里的onApplicationEvent方法 使用applicationContext的publishEvent来发布事件 最后继承AsyncUncaughtExceptionHandler添加异步报错控制 新建实体 因为我这里只用到 id 所以只需要传入id即可123456789101112131415/** * @author: ZHANG.HAO * @Description: */public class WordToPdfEvent extends ApplicationEvent &#123; Integer id; public WordToPdfEvent(Integer id) &#123; super(id); this.id = id; &#125;&#125; 这里需要写你的后台监听到事件后要做的内容 我的是转换文档123456789101112131415/** * @Author: ZHANG.HAO * @Description: */@Slf4j@Componentpublic class handleListener implements ApplicationListener&lt;WordToPdfEvent&gt; &#123; @Override public void onApplicationEvent(WordToPdfEvent wordToPdfEvent) &#123; // do something &#125;&#125; 异步发布事件 12345678910111213141516171819202122/** * @author: ZHANG.HAO * @Description: */@Slf4j@Servicepublic class AsyncService &#123; @Autowired ApplicationContext applicationContext; @Async public void executorAsyncTask(List&lt;SysFile&gt; list)&#123; list.forEach(SysFile -&gt; &#123; applicationContext.publishEvent(new WordToPdfEvent(SysFile.getId())); &#125;); &#125;&#125; 配置后台异步exception12345678910111213141516171819202122232425262728/** * 后台异步exception * @author: ZHANG.HAO * @Description: */@Slf4jpublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler &#123; @Autowired ISysLogService sysLogService; @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123; log.info(\"handleUncaughtException \"); StringJoiner sjr = new StringJoiner(\",\", \"[\", \"]\"); sjr.add(\"Exception Cause - \" + ex.getMessage()) ; sjr.add(\"Method name - \" + method.getName()) ; for (Object param : params) &#123; sjr.add(\"Parameter value - \" + param) ; &#125; sysLogService.save(new SysLog(-99,sjr.toString())); &#125;&#125; 配置异步连接池1234567891011121314151617181920212223242526/** * @author ZHANG.HAO * @Date: 2019-09-09 18:34 * @Description: */@Componentpublic class AsyncConfig implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(17); executor.setMaxPoolSize(42); executor.setQueueCapacity(11); executor.setThreadNamePrefix(\"WordToPdfExecutor-\"); executor.initialize(); return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return new MyAsyncUncaughtExceptionHandler(); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"Lombok的应用","slug":"lombok","date":"2018-09-01T16:00:00.000Z","updated":"2020-04-08T06:43:40.041Z","comments":true,"path":"2018/09/02/lombok/","link":"","permalink":"http://yoursite.com/2018/09/02/lombok/","excerpt":"","text":"eclipse下下载jar运行jar。Java -jar lombok.jar选择要安装的路径 Clean 项目 其实一般情况下都有插件管理中心可以下载idea 下直接去plugins 里下载安装 在项目中添加 lombok123456789&lt;lombok.version&gt;1.16.20&lt;/lombok.version&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 下面是使用的基本用法 123456789101112131415161718192021222324252627282930313233343536373839• al：用在局部变量前面，相当于将变量声明为final• @NonNull：给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）• @Cleanup：自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流• @Getter/@Setter：用在属性上，再也不用自己手写setter和getter方法了，还可以指定访问范围• @ToString：用在类上，可以自动覆写toString方法，当然还可以加其他参数，例如@ToString(exclude=”id”)排除id属性，或者@ToString(callSuper=true, includeFieldNames=true)调用父类的toString方法，包含所有属性• @EqualsAndHashCode：用在类上，自动生成equals方法和hashCode方法• @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor：用在类上，自动生成无参构造和使用所有参数的构造函数以及把所有@NonNull属性作为参数的构造函数，如果指定staticName = “of”参数，同时还会生成一个返回类对象的静态工厂方法，比使用构造函数方便很多• @Data：注解在类上，相当于同时使用了@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstrutor这些注解，对于POJO类十分有用• @Value：用在类上，是@Data的不可变形式，相当于为属性添加final声明，只提供getter方法，而不提供setter方法• @Builder：用在类、构造器、方法上，为你提供复杂的builder APIs，让你可以像如下方式一样调用Person.builder().name(&quot;Adam Savage&quot;).city(&quot;San Francisco&quot;).job(&quot;Mythbusters&quot;).job(&quot;Unchained Reaction&quot;).build();更多说明参考Builder• @SneakyThrows：自动抛受检异常，而无需显式在方法上使用throws语句• @Synchronized：用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性$lock或$LOCK，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误• @Getter(lazy=true)：可以替代经典的Double Check Lock样板代码• @Log：根据不同的注解生成不同类型的log对象，但是实例名称都是log，有六种可选实现类 ○ @CommonsLog Creates log = org.apache.commons.logging.LogFactory.getLog(LogExample.class); ○ @Log Creates log = java.util.logging.Logger.getLogger(LogExample.class.getName()); ○ @Log4j Creates log = org.apache.log4j.Logger.getLogger(LogExample.class); ○ @Log4j2 Creates log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class); ○ @Slf4j Creates log = org.slf4j.LoggerFactory.getLogger(LogExample.class); ○ @XSlf4j Creates log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"linux开放端口","slug":"linuxPort","date":"2018-05-17T16:00:00.000Z","updated":"2020-01-03T03:35:33.048Z","comments":true,"path":"2018/05/18/linuxPort/","link":"","permalink":"http://yoursite.com/2018/05/18/linuxPort/","excerpt":"","text":"文件local1/etc/sysconfig/iptables 添加 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 5236 -j ACCEPT 生效1service iptables restart -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 3000:5000 -j ACCEPT","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"记一次ftp并发导致的bug","slug":"threadLocal","date":"2018-04-19T16:00:00.000Z","updated":"2019-12-13T10:14:00.330Z","comments":true,"path":"2018/04/20/threadLocal/","link":"","permalink":"http://yoursite.com/2018/04/20/threadLocal/","excerpt":"","text":"ThreadLocal 适用于如下两种场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 1234567891011121314151617181920212223242526272829 private ThreadLocal&lt;FTPClient&gt; ftpClientThreadLocal = new ThreadLocal&lt;FTPClient&gt;(); private FTPClient getFTPClient() &#123; if (ftpClientThreadLocal.get() != null &amp;&amp; ftpClientThreadLocal.get().isConnected()) &#123; return ftpClientThreadLocal.get(); &#125;else&#123; FTPClient ftpClient = new FTPClient(); //构造一个FtpClient实例 ftpClient.setControlEncoding(&quot;UTF-8&quot;);// ftpClient.completePendingCommand(); ftpClient.enterLocalPassiveMode();// ftpClient.enterLocalActiveMode(); ftpClient.setBufferSize(1024*2); loginFtp(ftpClient); try &#123; ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; ftpClientThreadLocal.set(ftpClient); return ftpClient; &#125; &#125; 1FTPClient ftpClient = getFTPClient();","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}]},{"title":"JVM 调优","slug":"jvmOptimize","date":"2018-04-07T16:00:00.000Z","updated":"2020-03-31T01:37:22.596Z","comments":true,"path":"2018/04/08/jvmOptimize/","link":"","permalink":"http://yoursite.com/2018/04/08/jvmOptimize/","excerpt":"","text":"参数查看可以打开本地jdk下的jconsole查看 可以先查看下本地的jdk环境是client 还是server可以根据java -version 查看1234apple@appletekiMacBook-Air  ~  java -versionjava version \"1.8.0_181\"Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 如果是client jar包启动还可以加上 -server 这样启动虽然会慢点 但是效率会高很多 其他的优化点 12-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC 我在这边简单说一下：-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）-Xms1024m （堆最大大小）-Xmx1024m （堆默认大小）-Xmn256m （新生代大小）-Xss256k （棧最大深度大小）-XX:SurvivorRatio=8 （新生代分区比例 8:2）-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）-XX:+PrintGCDetails （打印详细的GC日志） 知识点：JDK8之后把-XX:PermSize 和 -XX:MaxPermGen移除了，取而代之的是-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。使用本地化的内存有什么好处呢？最直接的表现就是java.lang.OutOfMemoryError: PermGen 空间问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此我们也要限制Metaspace的大小：使用-XX:MaxMetaspaceSize参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"乐扣刷题3 无重复的最长字符串","slug":"leetcode3","date":"2017-11-17T16:00:00.000Z","updated":"2019-11-22T03:24:26.887Z","comments":true,"path":"2017/11/18/leetcode3/","link":"","permalink":"http://yoursite.com/2017/11/18/leetcode3/","excerpt":"","text":"//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。//// 示例 1://// 输入: “abcabcbb”//输出: 3//解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。////// 示例 2://// 输入: “bbbbb”//输出: 1//解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。////// 示例 3://// 输入: “pwwkew”//输出: 3//解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。// 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。//// Related Topics 哈希表 双指针 字符串 Sliding Window 12345678910111213141516171819202122public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; //创建map窗口,i为左区间，j为右区间，右边界移动 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int j = 0, i = 0; j &lt; n; j++) &#123; // 如果窗口中包含当前字符， if (map.containsKey(s.charAt(j))) &#123; //当找到相同的数据 i = Math.max(map.get(s.charAt(j)), i); &#125; //比对当前无重复字段长度和储存的长度，选最大值并替换 //取的[i,j]长度 +1 是因为从0开始的 ans = Math.max(ans, j - i + 1); // 将当前字符为key，下一个索引为value放入map中 // value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了 map.put(s.charAt(j), j+1); &#125; return ans; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"乐扣刷题2 两数相加","slug":"leetcode2","date":"2017-11-17T16:00:00.000Z","updated":"2019-11-22T03:23:48.455Z","comments":true,"path":"2017/11/18/leetcode2/","link":"","permalink":"http://yoursite.com/2017/11/18/leetcode2/","excerpt":"","text":"大概思路都在下面备注里 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode a = new ListNode(0); ListNode p = l1, q = l2,curr = a; int carry = 0; while(p != null || q != null)&#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; // 只能是0 或者 1 carry = sum / 10; //读取个位数 加入next curr.next = new ListNode(sum % 10); // 激活下一位 curr = curr.next; // 赋值两个链表 if(p != null) p = p.next; if(q != null) q = q.next; &#125; // 当最后大于1 但是while不会循环 所以需要给new一个listNode来补充 比如 11 99 110 用来最后添加这个1的 if(carry &gt; 0)&#123; curr.next = new ListNode(carry); &#125; return a.next; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"门面模式和调停者模式","slug":"facade&mediator","date":"2017-01-26T16:00:00.000Z","updated":"2020-04-27T07:30:20.029Z","comments":true,"path":"2017/01/27/facade&mediator/","link":"","permalink":"http://yoursite.com/2017/01/27/facade&mediator/","excerpt":"","text":"facade mediator对外 门面模式对内 调停者模式著名的消息中间件就是这个思路案例 :1234567891011121314151617181920212223242526272829303132333435363738package facade;public class FacadePattern&#123; public static void main(String[] args)&#123; Facade f=new Facade(); f.method(); &#125;&#125;//外观角色class Facade&#123; private SubSystem01 obj1=new SubSystem01(); private SubSystem02 obj2=new SubSystem02(); private SubSystem03 obj3=new SubSystem03(); public void method()&#123; obj1.method1(); obj2.method2(); obj3.method3(); &#125;&#125;//子系统角色class SubSystem01&#123; public void method1()&#123; System.out.println(\"子系统01的method1()被调用！\"); &#125; &#125;//子系统角色class SubSystem02&#123; public void method2()&#123; System.out.println(\"子系统02的method2()被调用！\"); &#125; &#125;//子系统角色class SubSystem03&#123; public void method3()&#123; System.out.println(\"子系统03的method3()被调用！\"); &#125; &#125; 参考资料: http://c.biancheng.net/view/1369.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"benchmark测试","slug":"banchmark","date":"2016-05-31T16:00:00.000Z","updated":"2020-04-28T08:57:44.788Z","comments":true,"path":"2016/06/01/banchmark/","link":"","permalink":"http://yoursite.com/2016/06/01/banchmark/","excerpt":"","text":"benchmark测试 apache旗下的一个软件可以测试 19年 用 jmeter","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"局域网共享文件夹如何换用户名登陆","slug":"windows01","date":"2015-10-07T16:00:00.000Z","updated":"2020-04-08T06:45:16.134Z","comments":true,"path":"2015/10/08/windows01/","link":"","permalink":"http://yoursite.com/2015/10/08/windows01/","excerpt":"","text":"你在运行里输入 CMD在命令提示符中输入： 1net use * /delete OR 1net use * /del /y 然后它会问你是否要删除网络连接，按 Y，回车即可。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://yoursite.com/tags/共享文件夹/"},{"name":"登陆","slug":"登陆","permalink":"http://yoursite.com/tags/登陆/"}]},{"title":"bfg工具 清除git 历史记录","slug":"bfg","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:12:43.061Z","comments":true,"path":"2015/10/08/bfg/","link":"","permalink":"http://yoursite.com/2015/10/08/bfg/","excerpt":"","text":"下载jar包下载地址 下载好后在你的根目录下执行1java -jar bfg.jar --strip-blobs-bigger-than 100M /你的项目地址 回到你的项目目录执行 1git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive 1git push","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Shell 传递参数","slug":"shellArgs","date":"2015-10-07T16:00:00.000Z","updated":"2020-04-08T06:44:29.486Z","comments":true,"path":"2015/10/08/shellArgs/","link":"","permalink":"http://yoursite.com/2015/10/08/shellArgs/","excerpt":"","text":"脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 新建shell1234567#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 调用1$ ./test.sh 1 2 3","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"maven多环境配置文件","slug":"mavenProfileSpringboot","date":"2015-10-07T16:00:00.000Z","updated":"2020-04-08T06:43:55.862Z","comments":true,"path":"2015/10/08/mavenProfileSpringboot/","link":"","permalink":"http://yoursite.com/2015/10/08/mavenProfileSpringboot/","excerpt":"","text":"123# 多环境配置文件激活属性---开发、测试、生产spring.profiles.active=@activatedProperties@ 12345678910111213141516171819202122&lt;profiles&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 本地开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认环境为开发环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; // 2019/11/22 测试不需要这个12345678910111213141516171819202122&lt;!-- 打包后的名字(test.war) --&gt; &lt;resources&gt; &lt;!-- 打包时要把mapper.xml也打进去！ --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt; &lt;excludes&gt; &lt;exclude&gt;test/*&lt;/exclude&gt; &lt;exclude&gt;dev/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/$&#123;profiles.active&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; 如果先远程部署后本地启动需要先maven install // 没有-P 选择默认的mvn clean package -Pdev -Dmaven.test.skip=true // 命令优先度高java -jar /xxx/xxx.jar –spring.profiles.active=dev yml环境下有些区别 @换成# 详细情况可以参考 SpringBoot + Maven实现多环境动态切换yml配置及配置文件拆分","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"swagger生成项目离线文档","slug":"swaggerTodoc","date":"2015-10-07T16:00:00.000Z","updated":"2020-08-13T08:54:34.614Z","comments":true,"path":"2015/10/08/swaggerTodoc/","link":"","permalink":"http://yoursite.com/2015/10/08/swaggerTodoc/","excerpt":"","text":"最近需要写项目文档来记录下把swagger转换成adoc 然后根据adoc的格式依次转换成 pdf html 首先导入 swagger包1234567891011121314151617181920&lt;!-- swagger start --&gt; &lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5-RELEASE&lt;/version&gt; &lt;!----&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-vue-ui&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.version&#125;&lt;/version&gt; &lt;/dependency&gt; 导入转换插件 注意两个路径123456789101112131415161718192021222324252627282930313233&lt;plugin&gt; &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt; &lt;artifactId&gt;swagger2markup-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;configuration&gt; &lt;swaggerInput&gt;http://localhost:8088/zhxtotc/v2/api-docs&lt;/swaggerInput&gt;&lt;!---swagger-api-json路径--&gt; &lt;outputFile&gt;src/docs/asciidoc/generated/swagger&lt;/outputFile&gt;&lt;!---生成路径--&gt; &lt;config&gt; &lt;swagger2markup.markupLanguage&gt;ASCIIDOC&lt;/swagger2markup.markupLanguage&gt;&lt;!--生成格式--&gt; &lt;/config&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;configuration&gt; &lt;!--asciidoc文件目录--&gt; &lt;sourceDirectory&gt;src/docs/asciidoc/generated&lt;/sourceDirectory&gt; &lt;!---生成html的路径--&gt; &lt;outputDirectory&gt;docs/asciidoc/html&lt;/outputDirectory&gt; &lt;backend&gt;html&lt;/backend&gt; &lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt; &lt;attributes&gt; &lt;!--导航栏在左--&gt; &lt;toc&gt;left&lt;/toc&gt; &lt;!--显示层级数--&gt; &lt;!--&lt;toclevels&gt;3&lt;/toclevels&gt;--&gt; &lt;!--自动打数字序号--&gt; &lt;sectnums&gt;true&lt;/sectnums&gt; &lt;/attributes&gt; &lt;/configuration&gt; &lt;/plugin&gt; 后续直接在maven插件里运行对呀的插件执行方法就能生成出来 adoc可能会出现乱码情况 html 目前比较好 推荐用这个","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://yoursite.com/tags/swagger/"}]},{"title":"浅析HTTP及lvs","slug":"HTTP","date":"2015-05-01T16:00:00.000Z","updated":"2020-06-18T03:23:52.887Z","comments":true,"path":"2015/05/02/HTTP/","link":"","permalink":"http://yoursite.com/2015/05/02/HTTP/","excerpt":"","text":"HTTP七层协议应用层 用户态 - 浏览器 -生成各种 HTTP/1.1 只需要写好规则 表示层会话层传输控制层 (相当于操作系统的接口) 给内核态 socket 一台主机拥有的端口号是65535个 tcp协议 (可靠协议) 三次握手 之后建立资源消耗 开辟资源后返回给应用层来 传输数据 操作 四次挥手 要求双方都发送一个分开链接和接受一次分开的包 tcp 是 基于下一跳的规则 每个节点只需要记录下一个节点的地址 组织TCP协议的包然后发送给网络层 并且在当前阻塞住 udp协议 网络层 netstat TCP/IP 拿到包之后 通过本地的ip地址寻找相对于的路由表 route -nip 和 Genmask(子网掩码) 按位与运算 得到 Destination 找到(gateWay)网关 链路层 TCP/IP 找到mac 地址 封装包给下一层 arp -a 物理层 三层确定对方地址 源mac地址 -&gt; 目标mac地址 (会不停地找下一跳 所以会变) 源IP地址 -&gt; 目标IP地址 源端口号 -&gt; 目标端口号 建立连接的包 sync sync/ack ack 断开连接的包 finl 七层协议出去之后基于lvs的三种模式 D-NAT 出去的时候肯定是 CIP 和 VIP 去寻找下一跳 然后会找到具体的VIP地址来确定DIP 最后访问RIP 回去的时候按照原路返回 DR模式 基于两层 CIP -&gt; VIP -&gt; DIP -&gt; RIP -&gt; VIP(对外隐藏) 出去的时候肯定是 CIP 和 VIP 去寻找下一跳 然后会找到具体的VIP地址来确定DIP 在找到DIP的地址之后会封装一个 ( CIP VIP | RIP @ MAC ) 的包 最后访问RIP 然后RIP根据包里面的CIP来返回数据 路由器ip地址由 运营商提供 -&gt; 去寻找VIP出去的时候为了防止同一局域网出去的ip一样会在路由器内部生成一个私有的端口号来区别 速度快, 成本低, 负载和RS要在同一局域网 TUN隧道技术 vpn &amp; 翻墙软件 LVS主备 nginx nginx 和server建立三次连接 lvs 和nginx 建立通讯 七层协议每层都有相对应的规范","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo基本命令","slug":"hexoShell","date":"2015-05-01T16:00:00.000Z","updated":"2019-11-11T09:47:04.618Z","comments":true,"path":"2015/05/02/hexoShell/","link":"","permalink":"http://yoursite.com/2015/05/02/hexoShell/","excerpt":"","text":"本地部署验证hexo s -g 清理并生成hexo clean &amp;&amp; hexo g 远程部署hexo d","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}