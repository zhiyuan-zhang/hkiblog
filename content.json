{"meta":{"title":"hki","subtitle":null,"description":null,"author":"zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-12-12T04:27:05.151Z","updated":"2019-12-12T04:27:05.151Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404"}],"posts":[{"title":"","slug":"shell","date":"2019-12-27T09:23:26.861Z","updated":"2019-12-27T09:34:04.441Z","comments":true,"path":"2019/12/27/shell/","link":"","permalink":"http://yoursite.com/2019/12/27/shell/","excerpt":"","text":"title: linux语法操作date: 2019/12/28categories: linuxabbrlink: 29383tags: File1234ls ll ls -l ll -rt shell base12345Ctrl+w:删除光标前面的单词的字符Ctrl – a ：移到行首Ctrl – e ：移到行尾esc - f : 前移一个词esc - b: 后移一个词 创建文件用touch 例如：touch [1.txt]删除文件用rm 例如：rm -f [1.txt]创建目录用mkdir 例如：mkdir [xxx] { -p 参数来创建多级文件夹 }删除空目录用rmdir 例如：rmdir [xxx]（有东西的目录不能删）打开文件 Vi open cat more less 删除装有东西的目录就用rm -rfi 例如rm -rfi [XXX]i是为了提醒 最好加上 批量创建 mkdir -p nginxdb/{conf,conf.d,html,logs} 查看文件末尾 Tail -20 [filename]12# 经常查看日志需要用到这个tail -f xxx.log -n100 重新命名 Mv [old.text] [new.text] 杀死进程 Kill [pid] pkill和阿里源码里学的直接删除程序对应的进程pkill -f zwkj-0.0.1-SNAPSHOT.jar 权限赋予 Chmod -R 777 [目录]建议了解下 linux权限的 0124 组成 这样就知道777怎么来的 读取文件 Cat [filename] 查询文件find [path_root] -name ‘.doc‘find / -name [xxx] -dlocate 查看某个端口是否被占用 习惯用lsof 不想用netstat按照 yum install lsof -ylsof -i tcp:8080 (PS 必须用root权限) netstat -tunlp|grep [端口号]ps -axu|grep [java] 启动位置输出 文件下载wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.zip –no-check-certificate 服务器文件移动 上传scp /Users/apple/Documents/zwsj-category-0.0.1-SNAPSHOT.jar root@192.168.0.118:/home/zwsjObjScp -r 下载scp -P 2204 isinonet@106.37.74.50:/home/gzzx/excel/ProfessionReport18584791024.xlsx /Users/apple/Documentsscp -P 2204 isinonet@106.37.74.50:/logs/test.log /Users/apple/Documents-r 文件夹 -p端口 查看磁盘容量 df -hl /xxx 查看位置 which java rpm包安装 rpm -ivh **.rpm 后台运行命令Nohup 详细指南 该命令用来列出目前与过去登录系统的用户相关信息 Last Linux查看文件夹大小 du -sh 查看当前文件夹大小 du -sh * | sort -n 统计当前文件夹(目录)大小，并按文件大小排序 du -sk filename 查看指定文件大小 解压 zip all.zip *.jpg unzip all.zip Grep 管道查询 -A num：匹配到搜索到的行以及该行下面的num行 -B num：匹配到搜索到的行以及该行上面的num行 -C num：匹配到搜索到的行以及上下各num行 grep -E -B 1 ‘use time:’ /data/home/zhxt/zhxt-test/logs/test.log ls | grep ‘.docx’ ls | grep a* (a 开头的) ls | grep ‘a*’ (包含a的) https://www.cnblogs.com/kongzhongqijing/articles/4462793.html 遇到其他不会的命令实例可以按照这个命令来查看基础语法 tldr mkdir 查看历史输入的命令 cat ~/.bash_history 查看执行文件的路径 whereis mysql","categories":[],"tags":[]},{"title":"vimrc配置文件","slug":"vimrc","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-19T09:19:22.865Z","comments":true,"path":"2019/12/18/vimrc/","link":"","permalink":"http://yoursite.com/2019/12/18/vimrc/","excerpt":"","text":"替换了本地的自带的vi 采用了 macvim 安装方法通过 brew 1brew install macvim 安装过程需要xcode的支持 下载时间比较长耐心等待下 可能会报错 具体解决原有看报错后的日志 之后需要修改.bash_profile 123alias vi=vimalias vim=mvimalias mvim=&apos;/usr/local/bin/mvim -v&apos; 安装完成后 去配置vim的 .vimrc文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&quot;=========================================================================&quot; DesCRiption: 适合自己使用的vimrc文件，for Linux/Windows, GUI/Console&quot;&quot; Last Change: 2019年08月02日 15时13分 &quot;&quot; Version: 1.80&quot;&quot;=========================================================================set nocompatible &quot; 关闭 vi 兼容模式syntax on &quot; 自动语法高亮set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot; 设定 tab 长度为 4set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录filetype plugin indent on &quot; 开启插件set backupcopy=yes &quot; 设置备份时的行为为覆盖set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan &quot; 禁止在搜索到文件两端时重新搜索set incsearch &quot; 输入搜索内容时就显示搜索结果set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码&quot; set showmatch &quot; 插入括号时，短暂地跳转到匹配的对应括号&quot; set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set hidden &quot; 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start&quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ %c:%l/%L%)\\ &quot; 设置在状态行显示的信息set foldenable &quot; 开始折叠set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度setlocal foldlevel=1 &quot; 设置折叠层数为&quot; set foldclose=all &quot; 设置为自动关闭折叠 &quot; nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot; 用空格键来开关折叠&quot; return OS type, eg: windows, or linux, mac, et.st..function! MySys()if has(&quot;win16&quot;) || has(&quot;win32&quot;) || has(&quot;win64&quot;) || has(&quot;win95&quot;)return &quot;windows&quot;elseif has(&quot;unix&quot;)return &quot;linux&quot;endifendfunction&quot; 用户目录变量$VIMFILESif MySys() == &quot;windows&quot;let $VIMFILES = $VIM.&apos;/vimfiles&apos;elseif MySys() == &quot;linux&quot;let $VIMFILES = $HOME.&apos;/.vim&apos;endif&quot; 设定doc文档目录let helptags=$VIMFILES.&apos;/doc&apos;&quot; 设置字体 以及中文支持if has(&quot;win32&quot;)set guifont=Inconsolata:h12:cANSIendif&quot; 配置多语言环境if has(&quot;multi_byte&quot;)&quot; UTF-8 编码set encoding=utf-8set termencoding=utf-8set formatoptions+=mMset fencs=utf-8,gbkif v:lang =~? &apos;^\\(zh\\)\\|\\(ja\\)\\|\\(ko\\)&apos;set ambiwidth=doubleendifif has(&quot;win32&quot;)source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8endifelseechoerr &quot;Sorry, this version of (g)vim was not compiled with +multi_byte&quot;endif&quot; Buffers操作快捷方式!nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;&quot; Tab操作快捷方式!nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;&quot;关于tab的快捷键&quot; map tn :tabnext&lt;cr&gt;&quot; map tp :tabprevious&lt;cr&gt;&quot; map td :tabnew .&lt;cr&gt;&quot; map te :tabedit&quot; map tc :tabclose&lt;cr&gt;&quot;窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动&quot;光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的&quot;时候会变得非常方便.nnoremap &lt;C-h&gt; &lt;C-w&gt;hnnoremap &lt;C-j&gt; &lt;C-w&gt;jnnoremap &lt;C-k&gt; &lt;C-w&gt;knnoremap &lt;C-l&gt; &lt;C-w&gt;l&quot;一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;&quot; set fileformats=unix,dos,mac&quot; nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;&quot; nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;&quot; use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result&quot; map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;&quot; map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;&quot; map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;&quot; map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;&quot; 让 Tohtml 产生有 CSS 语法的 html&quot; syntax/2html.vim，可以用:runtime! syntax/2html.vimlet html_use_css=1&quot; Python 文件的一般设置，比如不要 tab 等autocmd FileType python set tabstop=4 shiftwidth=4 expandtabautocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot; 打开javascript折叠let b:javascript_fold=1&quot; 打开javascript对dom、html和css的支持let javascript_enable_domhtmlcss=1&quot; 设置字典 ~/.vim/dict/文件的路径autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dictautocmd filetype css set dictionary=$VIMFILES/dict/css.dictautocmd filetype php set dictionary=$VIMFILES/dict/php.dict&quot;-----------------------------------------------------------------&quot; plugin - bufexplorer.vim Buffers切换&quot; \\be 全屏方式查看全部打开的文件列表&quot; \\bv 左右方式查看 \\bs 上下方式查看&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - taglist.vim 查看函数列表，需要ctags程序&quot; F4 打开隐藏taglist窗口&quot;-----------------------------------------------------------------if MySys() == &quot;windows&quot; &quot; 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = &apos;&quot;&apos;.$VIMRUNTIME.&apos;/ctags.exe&quot;&apos;elseif MySys() == &quot;linux&quot; &quot; 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = &apos;/usr/bin/ctags&apos;endifnnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;let Tlist_Show_One_File = 1 &quot; 不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow = 1 &quot; 如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window = 1 &quot; 在右侧窗口中显示taglist窗口let Tlist_File_Fold_Auto_Close=1 &quot; 自动折叠当前非编辑文件的方法列表let Tlist_Auto_Open = 0let Tlist_Auto_Update = 1let Tlist_Hightlight_Tag_On_BufEnter = 1let Tlist_Enable_Fold_Column = 0let Tlist_Process_File_Always = 1let Tlist_Display_Prototype = 0let Tlist_Compact_Format = 1&quot;-----------------------------------------------------------------&quot; plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。&quot; \\m mark or unmark the word under (or before) the cursor&quot; \\r manually input a regular expression. 用于搜索.&quot; \\n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .&quot; \\* 当前MarkWord的下一个 \\# 当前MarkWord的上一个&quot; \\/ 所有MarkWords的下一个 \\? 所有MarkWords的上一个&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录&quot; :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree&quot; o 打开关闭文件或者目录 t 在标签页中打开&quot; T 在后台标签页中打开 ! 执行此文件&quot; p 到上层目录 P 到根目录&quot; K 到第一个节点 J 到最后一个节点&quot; u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）&quot; r 递归刷新当前目录 R 递归刷新当前根目录&quot;-----------------------------------------------------------------&quot; F3 NERDTree 切换map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;&quot;-----------------------------------------------------------------&quot; plugin - NERD_commenter.vim 注释代码用的，&quot; [count],cc 光标以下count行逐行添加注释(7,cc)&quot; [count],cu 光标以下count行逐行取消注释(7,cu)&quot; [count],cm 光标以下count行尝试添加块注释(7,cm)&quot; ,cA 在行尾插入 /* */,并且进入插入模式。 这个命令方便写注释。&quot; 注：count参数可选，无则默认为选中行或当前行&quot;-----------------------------------------------------------------let NERDSpaceDelims=1 &quot; 让注释符与语句之间留一个空格let NERDCompactSexyComs=1 &quot; 多行注释时样子更好看&quot;-----------------------------------------------------------------&quot; plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释&quot;-----------------------------------------------------------------let g:DoxygenToolkit_authorName=&quot;Asins - asinsimple AT gmail DOT com&quot;let g:DoxygenToolkit_briefTag_funcName=&quot;yes&quot;map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;map &lt;leader&gt;df :Dox&lt;CR&gt;map &lt;leader&gt;db :DoxBlock&lt;CR&gt;map &lt;leader&gt;dc a /* */&lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;&quot;-----------------------------------------------------------------&quot; plugin – ZenCoding.vim 很酷的插件，HTML代码生成&quot; 插件最新版：http://github.com/mattn/zencoding-vim&quot; 常用命令可看：http://nootn.com/blog/Tool/23/&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin – checksyntax.vim JavaScript常见语法错误检查&quot; 默认快捷方式为 F5&quot;-----------------------------------------------------------------let g:checksyntax_auto = 0 &quot; 不自动检查&quot;-----------------------------------------------------------------&quot; plugin - NeoComplCache.vim 自动补全插件&quot;-----------------------------------------------------------------let g:AutoComplPop_NotEnableAtStartup = 1let g:NeoComplCache_EnableAtStartup = 1let g:NeoComplCache_SmartCase = 1let g:NeoComplCache_TagsAutoUpdate = 1let g:NeoComplCache_EnableInfo = 1let g:NeoComplCache_EnableCamelCaseCompletion = 1let g:NeoComplCache_MinSyntaxLength = 3let g:NeoComplCache_EnableSkipCompletion = 1let g:NeoComplCache_SkipInputTime = &apos;0.5&apos;let g:NeoComplCache_SnippetsDir = $VIMFILES.&apos;/snippets&apos;&quot; &lt;TAB&gt; completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;&quot; snippets expand keyimap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)&quot;-----------------------------------------------------------------&quot; plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转&quot; % 正向匹配 g% 反向匹配&quot; [% 定位块首 ]% 定位块尾&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转&quot; SVN/git管理工具&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin – a.vim&quot;----------------------------------------------------------------&quot;让vimrc配置变更立即生效autocmd BufWritePost $MYVIMRC source $MYVIMRC-","categories":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}],"tags":[]},{"title":"spring cloud alibaba","slug":"alibaba","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-16T06:09:32.591Z","comments":true,"path":"2019/12/16/alibaba/","link":"","permalink":"http://yoursite.com/2019/12/16/alibaba/","excerpt":"","text":"spring cloud alibaba nacos 远程配置 | 服务发现和注册ribbon 负载均衡sentinel 熔断监控gateway 网关skywalking 链路追踪rockertMQ 异步通讯seata 分布式事务管理dubbo RPC框架","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"idea 显示run dashboard","slug":"ideaRun","date":"2019-11-19T16:00:00.000Z","updated":"2019-12-13T10:13:08.733Z","comments":true,"path":"2019/11/20/ideaRun/","link":"","permalink":"http://yoursite.com/2019/11/20/ideaRun/","excerpt":"","text":"在最上面的 help -&gt; edit custom VM options 在打开的xml里面添加 -Dide.run.dashboard=true","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"博客MD模板应用","slug":"tamplate","date":"2019-10-07T16:00:00.000Z","updated":"2019-12-27T09:23:24.826Z","comments":true,"path":"2019/10/08/tamplate/","link":"","permalink":"http://yoursite.com/2019/10/08/tamplate/","excerpt":"","text":"\\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"git 忽略已经提交和没提交的文件","slug":"gitignore","date":"2019-10-07T16:00:00.000Z","updated":"2019-12-27T09:23:18.414Z","comments":true,"path":"2019/10/08/gitignore/","link":"","permalink":"http://yoursite.com/2019/10/08/gitignore/","excerpt":"","text":"没有提交的其实一直都知道有这么个功能 但是一直都是手写没有记录 可以先去看下github官方提供的gitignore 里面有各种语言的 gitignore https://github.com/github/gitignore 自己个性化的话 可以在上面的文件基础上修改 在Git工作区的根目录下创建一个特殊的 .gitignore 下面是我自己使用的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/target/**/targettarget!.mvn/wrapper/maven-wrapper.jar###STS###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache###IntelliJIDEA###.idea*.iws*.iml*.ipr###NetBeans###/nbproject/private//build//nbbuild//dist//nbdist//.nb-gradle/#Compiledclassfile*.class#Logfile*.log#BlueJfiles*.ctxt#MobileToolsforJava(J2ME).mtj.tmp/#PackageFiles#*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.pdf.zip.doc 下面是一些语法使用1234567891011121314151617• bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件• /bin: 忽略根目录下的bin文件• /*.c: 忽略 cat.c，不忽略 build/cat.c• debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj• **/foo: 忽略/foo, a/foo, a/b/foo等• a/**/b: 忽略a/b, a/x/b, a/x/y/b等• !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件• *.log: 忽略所有 .log 文件• config.php: 忽略当前路径的 config.php 文件 已经提交但是本地在修改需要忽略的值得注意的是中央仓库已经存在该文件后 需要取消追踪对某个文件取消跟踪 12345git rm --cached readme1.txt # 删除readme1.txt的跟踪，并保留在本地。git add -A # 这里是将所有的改动提交到gitgit commit -m &apos;update local file&apos; 然后git commit 即可。但是git status查看状态时还是会列出来","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"docker基本语法","slug":"dockerShell","date":"2019-10-07T16:00:00.000Z","updated":"2019-12-13T10:12:52.281Z","comments":true,"path":"2019/10/08/dockerShell/","link":"","permalink":"http://yoursite.com/2019/10/08/dockerShell/","excerpt":"","text":"查看所有正在运行容器 1$ docker ps 查看所有容器 1$ docker ps -a 查看所有容器ID 1$ docker ps -a -q 启动容器 1$ docker start [NAME] stop停止所有容器 12$ docker stop $(docker ps -a -q) remove删除所有容器 1$ docker rm $(docker ps -a -q) run创建一个新的服务 1docker run -it [NAME] /bin/bash Exec 进入一个已经存在的 1docker exec -it 217a29f3495a /bin/bash 查看容器启动日志 1docker logs [容器ID] -删除容器镜像 image12sudo docker rmi IMAGE [IMAGE...] sudo docker rmi centos:latest 强制删除 实例 1docker rm -f 启动一个实例Container 123sudo docker run [OPTIONS] IMAGE [COMMAND] [ARG...]sudo docker run -t -i contos /bin/bashsudo docker run -p 8080:8080 -d [name]","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"基于SLF4J MDC机制配合AOP实现日志的链路追踪","slug":"slf4jMDC","date":"2019-05-30T16:00:00.000Z","updated":"2019-11-08T01:30:21.215Z","comments":true,"path":"2019/05/31/slf4jMDC/","link":"","permalink":"http://yoursite.com/2019/05/31/slf4jMDC/","excerpt":"","text":"问题描述一个合格的项目必须要有日志来支撑,日志不但能记录输入输出,当系统有问题的时候我们还需要做线上问题的排查. 在一个正常的项目中日志里包含了各种各样的接口及其他无关的数据日志,那么我们如何快速定位单次请求中所有的日志呢 ? 问题分析当我们设计一个系统日志的时候 首先我们需要解决以下几个问题 哪些数据需要写进日志中 日志如何分类 按天还是按周 如何区分每次请求 请求参数及返回值需不需要打印 如何进行多环节配置 解决方案按照上面的问题我们来一个一个解决 主要思路是 AOP 负责切入每个请求及参数打印 在进入 controller 之前打印本次请求的各种参数 MDC 添加 hashCode 来做参数校验 日志使用 logback 配置 日志按天分类,每天生成一个日志 利用 thread 来区分每次请求 springProfile 来做多环境配置 aop 有两种CGLIB,JDK 都是动态代理 今天不讨论这两者的区别 我使用的是 CGLIB pom 中引入 SpringBoot 的 web 模块和使用 AOP 相关的依赖： 定义切面类，实现 web 层的日志切面 对所有的 web 请求做切面来记录日志 第一种 AOP 上 logback 的输出1234567891011121314151617181920// 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null &amp;&amp; joinPoint != null) &#123; HttpServletRequest request = attributes.getRequest(); // 记录请求内容 log.info( \"1. 对象请求的URL : \" + request.getRequestURL().toString()); log.info( \"2. 请求方法名称 : \" + request.getMethod()); log.info( \"3. 对方IP地址 : \" + request.getRemoteAddr()); log.info( \"4. 运行的java类 : \" + joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName()); try&#123; log.info(\"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); &#125;catch (Exception e)&#123; log.info(\"请求参数切点无法切入\"); &#125; &#125;else&#123; throw new CheckException(\"网络请求出错, 请清空缓存重新尝试. \"); &#125; 第二种 request.HashCode 唯一标示在获得 12log.info(request.hashCode()+ \"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); 第三种 基于 SLF4J 的 MDC 机制12MDC.put(\"THREAD_ID\", \"userId\"+ userService.getId() ); 1&lt;pattern&gt;%date [%thread] %-5level %logger&#123;80&#125; %X&#123;THREAD_ID&#125; || %msg%n&lt;/pattern&gt; 第四种 结合 HashCode 和 MDC12MDC.put(\"THREAD_ID\", \"\"+request.hashCode()); 最终效果12345678910112019-06-04 10:14:27,743 [main] INFO com.zwkj.zhxt.ZhxtApplication || Started ZhxtApplication in 48.489 seconds (JVM running for 56.375)2019-06-04 10:15:28,310 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:28,313 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:28,314 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:28,323 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:28,585 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：168 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg=='2019-06-04 10:15:30,860 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || @Around:结果是 :ResultBean com.zwkj.zhxt.controller.SysUserController.findSysUser(UserModel) use time: 25512019-06-04 10:15:30,861 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 282556454: 方法的返回值 : ResultBean(msg=success, code=0, data=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub3ciOiIxNTU5NjE0NTMwMjE2emh4dCIsImtleSI6InVzZXIxMiJ9.ae7ra7hvDSp5N6YfuGYzr8ULeq7Zr5OuC_4PbybqceY) 12345672019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：151 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg==' \\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"},{"name":"SLF4J","slug":"SLF4J","permalink":"http://yoursite.com/tags/SLF4J/"},{"name":"MDC","slug":"MDC","permalink":"http://yoursite.com/tags/MDC/"}]},{"title":"spring-boot-ioc 解析","slug":"springBootIOC","date":"2019-05-21T16:00:00.000Z","updated":"2019-11-08T01:29:08.751Z","comments":true,"path":"2019/05/22/springBootIOC/","link":"","permalink":"http://yoursite.com/2019/05/22/springBootIOC/","excerpt":"","text":"spring boot ioc 启动调用堆栈 1234567891011121314151617181920212223242526272829303132333435inject:177, InjectionMetadata$InjectedElement (org.springframework.beans.factory.annotation)inject:90, InjectionMetadata (org.springframework.beans.factory.annotation)postProcessProperties:321, CommonAnnotationBeanPostProcessor (org.springframework.context.annotation)populateBean:1395, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)doCreateBean:592, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)createBean:515, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)lambda$doGetBean$0:320, AbstractBeanFactory (org.springframework.beans.factory.support)getObject:-1, 2018260103 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$144)getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)doGetBean:318, AbstractBeanFactory (org.springframework.beans.factory.support)getBean:199, AbstractBeanFactory (org.springframework.beans.factory.support)resolveCandidate:277, DependencyDescriptor (org.springframework.beans.factory.config)doResolveDependency:1247, DefaultListableBeanFactory (org.springframework.beans.factory.support)resolveDependency:1167, DefaultListableBeanFactory (org.springframework.beans.factory.support)inject:593, AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement (org.springframework.beans.factory.annotation)inject:90, InjectionMetadata (org.springframework.beans.factory.annotation)postProcessProperties:374, AutowiredAnnotationBeanPostProcessor (org.springframework.beans.factory.annotation)populateBean:1395, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)doCreateBean:592, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)createBean:515, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)lambda$doGetBean$0:320, AbstractBeanFactory (org.springframework.beans.factory.support)getObject:-1, 2018260103 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$144)getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)doGetBean:318, AbstractBeanFactory (org.springframework.beans.factory.support)getBean:199, AbstractBeanFactory (org.springframework.beans.factory.support)preInstantiateSingletons:849, DefaultListableBeanFactory (org.springframework.beans.factory.support)finishBeanFactoryInitialization:877, AbstractApplicationContext (org.springframework.context.support)refresh:549, AbstractApplicationContext (org.springframework.context.support)refresh:142, ServletWebServerApplicationContext (org.springframework.boot.web.servlet.context)refresh:775, SpringApplication (org.springframework.boot)refreshContext:397, SpringApplication (org.springframework.boot)run:316, SpringApplication (org.springframework.boot)run:1260, SpringApplication (org.springframework.boot)run:1248, SpringApplication (org.springframework.boot)main:26, ZhxtApplication (com.zwkj.zhxt) AbstractAutowireCapableBeanFactory 320123456789101112131415161718192021@Override public Object configureBean(Object existingBean, String beanName) throws BeansException &#123; markBeanAsCreated(beanName); BeanDefinition mbd = getMergedBeanDefinition(beanName); RootBeanDefinition bd = null; if (mbd instanceof RootBeanDefinition) &#123; RootBeanDefinition rbd = (RootBeanDefinition) mbd; bd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition()); &#125; if (bd == null) &#123; bd = new RootBeanDefinition(mbd); &#125; if (!bd.isPrototype()) &#123; bd.setScope(BeanDefinition.SCOPE_PROTOTYPE); bd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader()); &#125; BeanWrapper bw = new BeanWrapperImpl(existingBean); initBeanWrapper(bw); populateBean(beanName, bd, bw); return initializeBean(beanName, existingBean, bd); &#125; AbstractAutowireCapableBeanFactory 1336 1234567891011121314151617181920212223242526272829303132333435363738394041PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs;&#125;boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);PropertyDescriptor[] filteredPds = null;if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125;&#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"http://yoursite.com/tags/ioc/"}]},{"title":"记一次慢sql的查询记录","slug":"sqlOptimize","date":"2019-05-12T16:00:00.000Z","updated":"2019-11-08T01:30:27.357Z","comments":true,"path":"2019/05/13/sqlOptimize/","link":"","permalink":"http://yoursite.com/2019/05/13/sqlOptimize/","excerpt":"","text":"本质上来讲 sql优化和数据库优化是两种优化 数据库优化包含的种类较多 软件优化,硬件优化 理论上 单个mysql数据库能够支撑的是每秒2000的并发 极限是5000 当然本次不说数据库优化 先说sql优化 sql优化一般是针对单个业务进行优化 比如秒杀 系统的订单查询 (当然一般用redis 这里只是举个例子) 或者说是对excel表格进行分析插入数据库 等等各种各样的业务 当然一个简单的sql 可能就是这样的 1SELECT * from test WHERE ASSIGNEE_ = 'user1' 但在实际业务环境中可能并不是这样 实际会复杂很多 以及很多条件 当我们在处理这样的sql的时候 应该怎么去优化以及从哪里入手 索引我们大家都是知道索引可以很好的帮我们来提高效率 但是具体怎么用 以及针对某个业务或者单条sql怎么优化 再说这些之前我们先针对SQL进行一些常识性优化 比如 基本优化WHERE 子句里面的列尽量被索引 尽量避免使用 “SELECT *” 如果用到分页 尽量使用物理分页 并非逻辑分页 join列尽量使用索引 order by 使用索引 等等 总之是为了避免全表扫描做出的各种操作 大家应该发现索引的使用还是非常频繁的 那么具体某个sql使用了哪些索引 以及进行了什么处理操作 EXPLAIN 优化我们可以用 EXPLAIN 关键字去查看执行计划 12345678910111213141516EXPLAIN SELECT *FROM professor aWHERE NOT EXISTS ( SELECT * FROM sys_attend b WHERE a.id = b.professor_id AND b.`type` = 1 AND b.table_id = 93353728 ) AND a.polling_status = 1 AND a.status = 1 AND (a.Member_category = 1 OR a.Member_category = 3) AND (organization_category IN (4, 7) OR organization_categoryvice IN (4, 7))LIMIT 0, 2 id select_type table type possible_keys key key_len ref rows Extra 1 “PRIMARY” “a” “index_merge” “professor_level_index,professor_levelvice_index” “professor_level_index,professor_levelvice_index” “2,2” NULL 28 “Using sort_union(professor_level_index,professor_levelvice_index); Using where” 2 “DEPENDENT SUBQUERY” “b” “ALL” NULL NULL NULL NULL 85 “Using where” 这张表里大概有这么几个字段 id 执行顺序 可以重复 id相同则从上往下执行 id从大到小执行 select_type 搜索类型 一共有十一种 具体可以看这篇博客SQL_explain操作解释 这里就简单的介绍常见的几种 第一种也是最常见到的一种 SIMPLE 简单的select查询,查询中不包含子查询或者union; PRIMARY:查询中若包含任何复杂的子查询,最外层查询则被标记; 就是刚刚的优先级最外层则会显示PRIMARY SUBQUERY:在select或者where列表中包含了子查询; type 显示的是访问类型，一般我们优化sql就是着重优化这个 , 是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。 一般来说，得保证查询至少达到range级别，最好能达到ref。 那么怎么能达到这个级别呢 ref:非唯一性索引扫描,返回匹配某个单独值得所有行,本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,它可能会找到多个符合条件的行,所以它应该属于查找和扫描的混合体; range:只检索给定范围的行,使用一个索引来选择行,key列显示使用哪个索引,一般就是在你的where语句中出现了between,&lt;,&gt;,in等的查询；这种范围索引扫描比全表扫描要好,因为它只需要开始于索引的某一个点,结束于另一个点,不用扫描全部索引; 之前说的避免全表扫描就是为了这样 possible_keys:显示可能会被应用到这张表的索引,一个或者多个;查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用到; key:实际使用到的索引.如果为null,则没有使用索引;查询中若使用了覆盖索引,则该索引仅出现在key列表中; key_len:表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好; key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的; ref:显示索引的哪一列被使用了,如果可能的话,是一个常数,哪些列或常量别用于查找索引列上的值; rows:根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数; Extra:包含不适合在其它列中显示但十分重要的额外信息: 对于这个消息栏里展示的东西有很多 一般是你的sql违反的数据库相对应的算法,他认为你的不合理 在这里就不详细解释了 当大家出现后可以百度相对应的信息 MySQL中explain执行计划中额外信息字段(Extra)详解 那么根据这些信息我们可以查到需要优化哪些地方 说完 explain 我们可以再说说 explain extended + show warnings 在执行explain extended 之后我们在 show warnings 可以看到在数据库中我们sql的执行方式, 我们可以在这个基础上再次进行优化 我们可以看到sql的执行方式，对于分析sql还是很有帮助的。 ( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; ( 1 ) FROM [ left_table ] ( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; ( 2 ) ON &lt; join_condition &gt; ( 4 ) WHERE &lt; where_condition &gt; ( 5 ) GROUP BY &lt; group_by_list &gt; ( 6 ) WITH &lt; CUBE | RollUP &gt; ( 7 ) HAVING &lt; having_condition &gt; ( 10 ) ORDER BY &lt; order_by_list &gt; 从优先级我们可以看出为什么order by 排序在 group by 之前不生效了 之前那条sql之后后数据库warnings的执行方式是下面这样的123456789101112131415SELECT `zwkj_zhxt`.`a`.`id` AS `id`, `zwkj_zhxt`.`a`.`name` AS `name`, `zwkj_zhxt`.`a`.`sex` AS `sex`,FROM `zwkj_zhxt`.`professor` `a`WHERE ((`zwkj_zhxt`.`a`.`status` = 1) AND (`zwkj_zhxt`.`a`.`polling_status` = 1) AND (not(exists(/* select#2 */SELECT 1FROM `zwkj_zhxt`.`sys_attend` `b`WHERE ((`zwkj_zhxt`.`b`.`table_id` = 93353728) AND (`zwkj_zhxt`.`b`.`sex` = 1) AND (`zwkj_zhxt`.`a`.`id` = `zwkj_zhxt`.`b`.`professor_id`))))) AND ((`zwkj_zhxt`.`a`.`name` = 1) OR (`zwkj_zhxt`.`a`.`name` = 3)) AND ((`zwkj_zhxt`.`a`.`sex` IN (4,7)) OR (`zwkj_zhxt`.`a`.`sex` IN (4,7)))) limit 0,2 从上面还可以看出 and 的优先级 总是高于 or 但有一点需要注意的是 exteneded得到的sql并不是 最终优化执行的sql这一点可以在官方文档中得到确认Extended EXPLAIN Output Format但从优化的角度上来讲也能帮助我们. 一般企业数据库的优化 基本上是 配硬件+差不多的sql优化+分布式+分库分表+读写分离 等等 反正一系列的操作 基本满足80%的业务场景 当然我们优化个别业务需要根据实际场景来优化 如果确实说需要高级别的维护和优化 公司会有相对应的运维或者DB来做很少需要开发者担心","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"}]},{"title":"launchctl自动化脚本","slug":"macLaunchctl","date":"2019-04-17T16:00:00.000Z","updated":"2019-12-13T10:13:30.323Z","comments":true,"path":"2019/04/18/macLaunchctl/","link":"","permalink":"http://yoursite.com/2019/04/18/macLaunchctl/","excerpt":"","text":"启动1launchctl start con.hki.zhxtgit.plist 查找1launchctl list | grep &apos;con&apos; 加载1launchctl load -w con.hki.zhxtgit.plist 卸载1launchctl unload con.hki.zhxtgit.plist 校验语法1plutil -lint com.hki.zhxtgit.plist plist文件1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Disabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;con.hki.zhxtgit.plist&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Documents/shell/zhxtgit.sh&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;false/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/Documents/shell/run.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/Documents/shell/run.err&lt;/string&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;15&lt;/integer&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;5&lt;/integer&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;","categories":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/categories/mac/"}],"tags":[{"name":"自动化脚本","slug":"自动化脚本","permalink":"http://yoursite.com/tags/自动化脚本/"}]},{"title":"异步的观察者模式处理后台任务","slug":"ApplicationEvent","date":"2018-10-07T16:00:00.000Z","updated":"2019-11-13T02:00:07.734Z","comments":true,"path":"2018/10/08/ApplicationEvent/","link":"","permalink":"http://yoursite.com/2018/10/08/ApplicationEvent/","excerpt":"","text":"收到任务说要做一个后台监听文件上传接口 如果有docx文档 需要将任务放在后台进程中 将docx文档转换成pdf文档 首先文档转换不是我们今天要讲的内容 稍后我会开一章来讲 事件监听在spring boot里还是比较容易实现的 有以下几点需要注意 vo实体需要继承 ApplicationEvent 实现接口ApplicationListener里的onApplicationEvent方法 使用applicationContext的publishEvent来发布事件 最后继承AsyncUncaughtExceptionHandler添加异步报错控制 新建实体 因为我这里只用到 id 所以只需要传入id即可123456789101112131415/** * @author: ZHANG.HAO * @Description: */public class WordToPdfEvent extends ApplicationEvent &#123; Integer id; public WordToPdfEvent(Integer id) &#123; super(id); this.id = id; &#125;&#125; 这里需要写你的后台监听到事件后要做的内容 我的是转换文档123456789101112131415/** * @Author: ZHANG.HAO * @Description: */@Slf4j@Componentpublic class handleListener implements ApplicationListener&lt;WordToPdfEvent&gt; &#123; @Override public void onApplicationEvent(WordToPdfEvent wordToPdfEvent) &#123; // do something &#125;&#125; 异步发布事件 12345678910111213141516171819202122/** * @author: ZHANG.HAO * @Description: */@Slf4j@Servicepublic class AsyncService &#123; @Autowired ApplicationContext applicationContext; @Async public void executorAsyncTask(List&lt;SysFile&gt; list)&#123; list.forEach(SysFile -&gt; &#123; applicationContext.publishEvent(new WordToPdfEvent(SysFile.getId())); &#125;); &#125;&#125; 配置后台异步exception12345678910111213141516171819202122232425262728/** * 后台异步exception * @author: ZHANG.HAO * @Description: */@Slf4jpublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler &#123; @Autowired ISysLogService sysLogService; @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123; log.info(\"handleUncaughtException \"); StringJoiner sjr = new StringJoiner(\",\", \"[\", \"]\"); sjr.add(\"Exception Cause - \" + ex.getMessage()) ; sjr.add(\"Method name - \" + method.getName()) ; for (Object param : params) &#123; sjr.add(\"Parameter value - \" + param) ; &#125; sysLogService.save(new SysLog(-99,sjr.toString())); &#125;&#125; 配置异步连接池1234567891011121314151617181920212223242526/** * @author ZHANG.HAO * @Date: 2019-09-09 18:34 * @Description: */@Componentpublic class AsyncConfig implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(17); executor.setMaxPoolSize(42); executor.setQueueCapacity(11); executor.setThreadNamePrefix(\"WordToPdfExecutor-\"); executor.initialize(); return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return new MyAsyncUncaughtExceptionHandler(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"记一次ftp并发导致的bug","slug":"threadLocal","date":"2018-04-19T16:00:00.000Z","updated":"2019-12-13T10:14:00.330Z","comments":true,"path":"2018/04/20/threadLocal/","link":"","permalink":"http://yoursite.com/2018/04/20/threadLocal/","excerpt":"","text":"ThreadLocal 适用于如下两种场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 1234567891011121314151617181920212223242526272829 private ThreadLocal&lt;FTPClient&gt; ftpClientThreadLocal = new ThreadLocal&lt;FTPClient&gt;(); private FTPClient getFTPClient() &#123; if (ftpClientThreadLocal.get() != null &amp;&amp; ftpClientThreadLocal.get().isConnected()) &#123; return ftpClientThreadLocal.get(); &#125;else&#123; FTPClient ftpClient = new FTPClient(); //构造一个FtpClient实例 ftpClient.setControlEncoding(&quot;UTF-8&quot;);// ftpClient.completePendingCommand(); ftpClient.enterLocalPassiveMode();// ftpClient.enterLocalActiveMode(); ftpClient.setBufferSize(1024*2); loginFtp(ftpClient); try &#123; ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; ftpClientThreadLocal.set(ftpClient); return ftpClient; &#125; &#125; 1FTPClient ftpClient = getFTPClient();","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}]},{"title":"jvm 调优参数","slug":"jvmOptimize","date":"2018-04-07T16:00:00.000Z","updated":"2019-12-13T10:13:17.448Z","comments":true,"path":"2018/04/08/jvmOptimize/","link":"","permalink":"http://yoursite.com/2018/04/08/jvmOptimize/","excerpt":"","text":"参数查看可以打开本地jdk下的jconsole查看 可以先查看下本地的jdk环境是client 还是server可以根据java -version 查看1234apple@appletekiMacBook-Air  ~  java -versionjava version \"1.8.0_181\"Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 如果是client jar包启动还可以加上 -server 这样启动虽然会慢点 但是效率会高很多 其他的优化点 12-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC 我在这边简单说一下：-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）-Xms1024m （堆最大大小）-Xmx1024m （堆默认大小）-Xmn256m （新生代大小）-Xss256k （棧最大深度大小）-XX:SurvivorRatio=8 （新生代分区比例 8:2）-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）-XX:+PrintGCDetails （打印详细的GC日志） 知识点：JDK8之后把-XX:PermSize 和 -XX:MaxPermGen移除了，取而代之的是-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。使用本地化的内存有什么好处呢？最直接的表现就是java.lang.OutOfMemoryError: PermGen 空间问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此我们也要限制Metaspace的大小：使用-XX:MaxMetaspaceSize参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"乐扣刷题3 无重复的最长字符串","slug":"leetcode3","date":"2017-11-17T16:00:00.000Z","updated":"2019-11-22T03:24:26.887Z","comments":true,"path":"2017/11/18/leetcode3/","link":"","permalink":"http://yoursite.com/2017/11/18/leetcode3/","excerpt":"","text":"//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。//// 示例 1://// 输入: “abcabcbb”//输出: 3//解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。////// 示例 2://// 输入: “bbbbb”//输出: 1//解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。////// 示例 3://// 输入: “pwwkew”//输出: 3//解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。// 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。//// Related Topics 哈希表 双指针 字符串 Sliding Window 12345678910111213141516171819202122public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; //创建map窗口,i为左区间，j为右区间，右边界移动 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int j = 0, i = 0; j &lt; n; j++) &#123; // 如果窗口中包含当前字符， if (map.containsKey(s.charAt(j))) &#123; //当找到相同的数据 i = Math.max(map.get(s.charAt(j)), i); &#125; //比对当前无重复字段长度和储存的长度，选最大值并替换 //取的[i,j]长度 +1 是因为从0开始的 ans = Math.max(ans, j - i + 1); // 将当前字符为key，下一个索引为value放入map中 // value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了 map.put(s.charAt(j), j+1); &#125; return ans; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"乐扣刷题2 两数相加","slug":"leetcode2","date":"2017-11-17T16:00:00.000Z","updated":"2019-11-22T03:23:48.455Z","comments":true,"path":"2017/11/18/leetcode2/","link":"","permalink":"http://yoursite.com/2017/11/18/leetcode2/","excerpt":"","text":"大概思路都在下面备注里 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode a = new ListNode(0); ListNode p = l1, q = l2,curr = a; int carry = 0; while(p != null || q != null)&#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; // 只能是0 或者 1 carry = sum / 10; //读取个位数 加入next curr.next = new ListNode(sum % 10); // 激活下一位 curr = curr.next; // 赋值两个链表 if(p != null) p = p.next; if(q != null) q = q.next; &#125; // 当最后大于1 但是while不会循环 所以需要给new一个listNode来补充 比如 11 99 110 用来最后添加这个1的 if(carry &gt; 0)&#123; curr.next = new ListNode(carry); &#125; return a.next; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"idea远程debug","slug":"ideaDebug","date":"2017-04-15T16:00:00.000Z","updated":"2019-12-13T10:13:03.698Z","comments":true,"path":"2017/04/16/ideaDebug/","link":"","permalink":"http://yoursite.com/2017/04/16/ideaDebug/","excerpt":"","text":"远程debug 原理是利用端口监听来触发本地idea 所以你本地的代码和远程的代码要保持一致 部署上去之后需要加上特定的参数来启动 原来启动jar包需要的命令1java -jar xxx.jar 如果是远程debug 则需要加上一些参数1java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=4001 xxx.jar 这个参数在idea里可以直接获取到 接下来我们去找如何获取debug参数 菜单 -&gt; Run -&gt; Edit Configurations… 在debug Configurations的弹出框里添加一个remote 添加后需要注意配置好 1-2 后就生成了启动参数 之后启动jar的时候添加上 服务器启动好后 在启动本地的 QAQ 当发现启动报错 首先检查下你的命令 不要直接复制我的 看你自己生成的代码 保证端口没被占用 本地启动remote会发送请求连接服务器 如果本机无法连接服务器也不行","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"}]},{"title":"浅谈jvm","slug":"jvm","date":"2017-04-07T16:00:00.000Z","updated":"2019-11-08T01:29:31.139Z","comments":true,"path":"2017/04/08/jvm/","link":"","permalink":"http://yoursite.com/2017/04/08/jvm/","excerpt":"","text":"jvm运行时数据分析 在区域中一般分为五块 运行时数据区域 计数器 通过改变这个计数器的值来获取下一条需要执行的字节码,包括判断 循环,跳转,异常处理 方法区(method Area) 该区域用来存放我们生成的各种对象信息 虚拟机栈(VM stack) 每个类 都会在执行的时候创建一个栈帧(javap -c -s xxx.class)来存放关于这个类的所有信息. 包括方法内的局部变量,以及各种操作帧数, 动态链接(各种引用)及方法的出口返回值等等。每个方法的调用到结束意味着虚拟机的栈桢的入栈到出栈, 堆(heap) 在遇到new指令后 我们会根据相对应的内存引用来找如果有就引用 没有的话就执行类加载 Java 类加载过程那一套东西 本地方法栈(native mathod stack) 存放本地原生调用方法和虚拟机栈一样只不过内容是原生计算机内的C方法 native是与C++联合开发的时候用的 所以一般开发不会用到 前面在堆中说了类引用会检查是否已经加载过当前需要的类 如果没有加载则会去加载 那么类的加载过程就是下面要说的 当程序用到某个类但这个类还没有加载到内存中,jvm会通过加载,连接,初始化来对这个类进行初始化 加载 jvm通过类的全类名来获取字节流 (也就是.class文件) 然后根据字节流创建class对象 创建完成后写入到内存中,然后放在运行时区域的方法区内(method Area) 然后在堆(heap)中创建出对应的Class对象 链接 分为三部分 验证语法 满足jvm虚拟机规范 准备阶段 为类的静态static 分配内存 设置默认值 解析阶段 将符号引用替换为内存引用(直接引用) 初始化 将static修饰的方法或者变量进行初始化,如果有父级引用优先加载父类 那么这个类的加载机制又是什么 它是通过什么来加载的 采用的双亲委派机制 当加载某个类的时候先去询问父类节点是否可以加载 这样既避免了重复加载也防止了注入还提高了效率","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"Shell 传递参数","slug":"shellArgs","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:13:41.099Z","comments":true,"path":"2015/10/08/shellArgs/","link":"","permalink":"http://yoursite.com/2015/10/08/shellArgs/","excerpt":"","text":"脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 新建shell1234567#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 调用1$ ./test.sh 1 2 3","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"swagger生成项目离线文档","slug":"swaggerTodoc","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:13:53.829Z","comments":true,"path":"2015/10/08/swaggerTodoc/","link":"","permalink":"http://yoursite.com/2015/10/08/swaggerTodoc/","excerpt":"","text":"最近需要写项目文档来记录下把swagger转换成adoc 然后根据adoc的格式依次转换成 pdf html 首先导入 swagger包1234567891011121314151617181920&lt;!-- swagger start --&gt; &lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5-RELEASE&lt;/version&gt; &lt;!----&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-vue-ui&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.version&#125;&lt;/version&gt; &lt;/dependency&gt; 导入转换插件 注意两个路径123456789101112131415161718192021222324252627282930313233&lt;plugin&gt; &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt; &lt;artifactId&gt;swagger2markup-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;configuration&gt; &lt;swaggerInput&gt;http://localhost:8088/zhxtotc/v2/api-docs&lt;/swaggerInput&gt;&lt;!---swagger-api-json路径--&gt; &lt;outputFile&gt;src/docs/asciidoc/generated/swagger&lt;/outputFile&gt;&lt;!---生成路径--&gt; &lt;config&gt; &lt;swagger2markup.markupLanguage&gt;ASCIIDOC&lt;/swagger2markup.markupLanguage&gt;&lt;!--生成格式--&gt; &lt;/config&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;configuration&gt; &lt;!--asciidoc文件目录--&gt; &lt;sourceDirectory&gt;src/docs/asciidoc/generated&lt;/sourceDirectory&gt; &lt;!---生成html的路径--&gt; &lt;outputDirectory&gt;docs/asciidoc/html&lt;/outputDirectory&gt; &lt;backend&gt;html&lt;/backend&gt; &lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt; &lt;attributes&gt; &lt;!--导航栏在左--&gt; &lt;toc&gt;left&lt;/toc&gt; &lt;!--显示层级数--&gt; &lt;!--&lt;toclevels&gt;3&lt;/toclevels&gt;--&gt; &lt;!--自动打数字序号--&gt; &lt;sectnums&gt;true&lt;/sectnums&gt; &lt;/attributes&gt; &lt;/configuration&gt; &lt;/plugin&gt;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://yoursite.com/tags/swagger/"}]},{"title":"局域网共享文件夹如何换用户名登陆","slug":"windows01","date":"2015-10-07T16:00:00.000Z","updated":"2019-11-08T01:28:30.602Z","comments":true,"path":"2015/10/08/windows01/","link":"","permalink":"http://yoursite.com/2015/10/08/windows01/","excerpt":"","text":"你在运行里输入 CMD在命令提示符中输入： 1net use * /delete OR 1net use * /del /y 然后它会问你是否要删除网络连接，按 Y，回车即可。","categories":[{"name":"windwos","slug":"windwos","permalink":"http://yoursite.com/categories/windwos/"}],"tags":[{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://yoursite.com/tags/共享文件夹/"},{"name":"登陆","slug":"登陆","permalink":"http://yoursite.com/tags/登陆/"}]},{"title":"bfg工具 清除git 历史记录","slug":"bfg","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:12:43.061Z","comments":true,"path":"2015/10/08/bfg/","link":"","permalink":"http://yoursite.com/2015/10/08/bfg/","excerpt":"","text":"下载jar包下载地址 下载好后在你的根目录下执行1java -jar bfg.jar --strip-blobs-bigger-than 100M /你的项目地址 回到你的项目目录执行 1git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive 1git push","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"maven多环境配置文件","slug":"mavenProfileSpringboot","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:13:36.353Z","comments":true,"path":"2015/10/08/mavenProfileSpringboot/","link":"","permalink":"http://yoursite.com/2015/10/08/mavenProfileSpringboot/","excerpt":"","text":"123# 多环境配置文件激活属性---开发、测试、生产spring.profiles.active=@activatedProperties@ 12345678910111213141516171819202122&lt;profiles&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 本地开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认环境为开发环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; // 2019/11/22 测试不需要这个12345678910111213141516171819202122&lt;!-- 打包后的名字(test.war) --&gt; &lt;resources&gt; &lt;!-- 打包时要把mapper.xml也打进去！ --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt; &lt;excludes&gt; &lt;exclude&gt;test/*&lt;/exclude&gt; &lt;exclude&gt;dev/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/$&#123;profiles.active&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; 如果先远程部署后本地启动需要先maven install // 没有-P 选择默认的mvn clean package -Pdev -Dmaven.test.skip=true // 命令优先度高java -jar /xxx/xxx.jar –spring.profiles.active=dev yml环境下有些区别 @换成# 详细情况可以参考 SpringBoot + Maven实现多环境动态切换yml配置及配置文件拆分","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"hexo基本命令","slug":"hexoShell","date":"2015-05-01T16:00:00.000Z","updated":"2019-11-11T09:47:04.618Z","comments":true,"path":"2015/05/02/hexoShell/","link":"","permalink":"http://yoursite.com/2015/05/02/hexoShell/","excerpt":"","text":"本地部署验证hexo s -g 清理并生成hexo clean &amp;&amp; hexo g 远程部署hexo d","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}