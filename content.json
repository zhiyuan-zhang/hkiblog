{"meta":{"title":"hki","subtitle":null,"description":null,"author":"zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-12-12T04:27:05.151Z","updated":"2019-12-12T04:27:05.151Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404"}],"posts":[{"title":"设计原则","slug":"设计原则","date":"2020-04-28T16:00:00.000Z","updated":"2020-04-30T05:41:57.444Z","comments":true,"path":"2020/04/29/设计原则/","link":"","permalink":"http://yoursite.com/2020/04/29/设计原则/","excerpt":"","text":"单一职责原则单个类不要设计的太庞大 当关联业务比较多的时候可以单独抽出来做一个manage类 Person 人相关的方法 PersonManager 与人相关的业务方法 开闭原则设计紧抓这一点 “面向修改关闭,面向拓展开放” 当你发现修改一个业务需要更改很多地方或者很多代码的时候说明你的设计有问题 尽量在最少修改的情况下达到完成需求. 留下以前的代码,旧代码也有价值的. 里氏替换原则Liscov Substitutiono Principle 所有引用父类对象的地方,必须能够透明的使用子类对象 依赖倒置原则Dependency INversion Priciple 参考 Array 对应 ArrayList ,LinkedList 就是在你需要添加新业务的时候 只需要新增一个抽象类的子类, 你只需要调用抽象类的方法就可以完成需求,无需修改现有逻辑, 面向接口编程 . 面向抽象编程. 接口隔离原则每个接口承担自己独立的业务,不要混和完成一个功能.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"工厂设计模式实际应用案例","slug":"factory","date":"2020-04-23T16:00:00.000Z","updated":"2020-04-24T03:17:44.652Z","comments":true,"path":"2020/04/24/factory/","link":"","permalink":"http://yoursite.com/2020/04/24/factory/","excerpt":"","text":"设计模式中的工厂模式 工厂模式在实际应用中也很常见 各种框架的factory也很多 先说说需求我们这个项目有一个发送通知的需求 通知有各种各样的 举几个例子 手机验证码通知 项目审批通知 出函通知 确认函通知 会议取消通知 待处理通知 … 发送方式也有很多种 邮件通知 短信通知 微信通知 钉钉通知 … 所以在设计的时候一个合格的通知必须经过三个步骤 确定发送类型 确定发送人 确定发送方式 我们可以把通知类做成一个factory 专门做通知的发送 // 2020年修改 后来我觉得这么设计有点不妥 改成 factory 制作各种通知 由策略模式来负责发送短信 工厂只负责短信的生产,不负责发送 具体实现步骤 1创建一个接口。 ProfessorStrategy 12345public interface notice &#123; void type(); void choose(); void send();&#125; 步骤 2创建实现接口的实体类。 EIMProfessorStrategy 12345678public class EIMProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; IPDProfessorStrategy 123456789public class IPDProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; UserProfessorStrategy 123456789public class UserProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; 步骤 3创建一个工厂，生成基于给定信息的实体类的对象。 123456789101112131415 /** * 返回接口数据 * @param tableId * @param professorStrategy * @return */ public static List&lt;SysAttendsModel&gt; find(Integer tableId, ProfessorStrategy professorStrategy) &#123;// 获取对应的五个专家 List&lt;Professor&gt; five = professorStrategy.five(tableId); List&lt;SysAttendsModel&gt; sysAttendsModels = new ArrayList&lt;&gt;(); return sysAttendsModels; &#125; 步骤 4使用 find 来查看当它改变策略 Strategy 时的行为变化。 main 12345678910111213public static void main(String[] args) &#123; // 单据id int tableId = 10086; // 挂牌算法 List&lt;SysAttendsModel&gt; list = find(tableId, new EIMProfessorStrategy()); // 可转债算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new IPDProfessorStrategy()); // 会员算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new IPDProfessorStrategy()); &#125; 代码讲解","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"权限设计","slug":"权限设计","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-22T08:58:36.239Z","comments":true,"path":"2020/04/14/权限设计/","link":"","permalink":"http://yoursite.com/2020/04/14/权限设计/","excerpt":"","text":"设计核心每个登录用户拥有各自的权限,由后端返回 后端下文整个权限模式基于RBAC理论设计 后台验证角色的权限,前端根据后台返回的menuList, permissionList 来设计前端的页面Router 角色的作用其实只是用来管理分配权限的,真正的验证只验证权限 数据库数据库主要包含五张表，分别是用户表 sys_user 、角色表 sys_role 、用户角色表 sys_job 、权限表 sys_permission 、角色权限表 sys_role_permission 。 关联关系如下图所示 数据库表内容及其含义运营后台用户表12345678910111213CREATE TABLE `sys_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) DEFAULT NULL COMMENT '用户名', `password` varchar(255) DEFAULT NULL COMMENT '密码', `nickname` varchar(255) DEFAULT NULL COMMENT '昵称', `role_id` varchar(64) DEFAULT '0' COMMENT '角色ID', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间', `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', `phone` varchar(255) DEFAULT NULL COMMENT '管理员手机号', `type` varchar(64) DEFAULT '1' COMMENT '1:流程管理用户 2：管理员或者超级管理员', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=10089 DEFAULT CHARSET=utf8 COMMENT='运营后台用户表'; 用户的组织角色和岗位信息123456789101112CREATE TABLE `sys_job` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `org_id` int(11) NOT NULL DEFAULT '0' COMMENT '组织id', `job_name` varchar(255) NOT NULL DEFAULT '0' COMMENT '表单id', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', `user_id` int(11) NOT NULL COMMENT '用户id', `role_id` varchar(64) DEFAULT NULL COMMENT '用户关联组的角色', `claim_type` varchar(12) DEFAULT '1' COMMENT '认领类型 1：可以认领任务 2：不能认领任务', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1084 DEFAULT CHARSET=utf8mb4 COMMENT='判断用户的组织和岗位'; 后台角色表1234567891011CREATE TABLE `sys_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` int(11) DEFAULT NULL COMMENT '角色类型', `name` varchar(20) DEFAULT NULL COMMENT '角色名', `flow_id` varchar(255) NOT NULL COMMENT '流程角色id', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', `note` varchar(255) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=47 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT='后台角色表'; 后台权限表123456789CREATE TABLE `sys_permission` ( `id` int(11) NOT NULL DEFAULT '0' COMMENT '自定id,主要供前端展示权限列表分类排序使用.', `menu_code` varchar(255) DEFAULT '' COMMENT '归属菜单,前端判断并展示菜单使用,', `menu_name` varchar(255) DEFAULT '' COMMENT '菜单的中文释义', `permission_code` varchar(255) DEFAULT '' COMMENT '权限的代码/通配符,对应代码中@RequiresPermissions 的value', `permission_name` varchar(255) DEFAULT '' COMMENT '本权限的中文释义', `required_permission` tinyint(1) DEFAULT '2' COMMENT '是否本菜单必选权限, 1.必选 2非必选 通常是\"列表\"权限是必选', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='后台权限表'; 角色-权限关联表123456789CREATE TABLE `sys_role_permission` ( `id` int(11) NOT NULL AUTO_INCREMENT, `role_id` int(11) DEFAULT NULL COMMENT '角色id', `permission_id` int(11) DEFAULT NULL COMMENT '权限id', `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `delete_status` varchar(1) DEFAULT '1' COMMENT '是否有效 1有效 2无效', PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8 COMMENT='角色-权限关联表'; 逻辑设计用户配置岗位信息举例: 固收分管领导及总裁 账号是 admin11 关联的岗位job信息是1015 岗位信息包含当前系统中所有的岗位 岗位信息关联角色当前系统所有的角色信息 固收分管领导及总裁 流程角色id是user88 角色id是 39 给角色对应的权限当前角色对应权限表中的某些权限 固收分管领导及总裁的角色id是39 所以需要给role_id配置不同的权限. 下面配置了4个权限,具体权限内容可以在权限表中查看 配置所有的权限列表存储系统中不同粒度的权限 包含但不止 其中如果想要分配子权限必须拥有顶级权限 其他问题最后: 如何一个账号对应多个第三方系统的角色 有两种解决方案 理论上来讲它也是当前系统中的一种权限,所以把它加到系统权限表中,之后配置角色的时候来添加不同的第三方角色 如果你觉得第一种比较麻烦,可以在你当前系统的角色表中添加一个第三方系统角色的ID来标识,这样有一个缺点就是无法添加多个角色,不过也有解决办法,就是新建一张表来维护与第三方的角色关系. 角色继承的问题 一个user对应多个岗位 一个岗位对应一个角色 延伸 可以在用户user和岗位job两个表中间添加一个关联表 用户和岗位关联起来 岗位是初始化指定角色权限的个人岗位job 初始化的时候角色和岗位是一对一的 后期添加操作修改权限是针对岗位来操作的 举个例子 张三是程序员岗位的角色后来申请可以操作DB的权限 在数据库中是张三这个岗位可以操作DB 并不是程序员这个角色可以操作DB 上面这种架构系统对继承角色非常麻烦, 要么循环当前角色来继承他的权限,要么多维护一张表.或者可以读下关于RBAC3的继承逻辑. RBAC参考文献 http://csrc.nist.gov/groups/SNS/rbac/index.html http://csrc.nist.gov/groups/SNS/rbac/faq.html","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"浅谈jvm","slug":"jvm","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-22T10:04:03.112Z","comments":true,"path":"2020/04/10/jvm/","link":"","permalink":"http://yoursite.com/2020/04/10/jvm/","excerpt":"","text":"GC的基础知识1.什么是垃圾简单来讲没有任何引用指向的一个对象或者多个对象（循环引用）就是垃圾. 引用又分为强引用，软引用，弱引用，虚引用。 强引用（Strong Reference）：这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象,当内存不够的时候只会抛出OOM异常 1Object obj = new Object(); 软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。 1SoftReference soft = new SoftReference(user); 弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。 虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。 2.如何寻找垃圾 引用计数 java没有在用这种算法,它需要单独维护一个引用计数器 目前OkHttp,netty在用故不在本章节讨论范围. 根可达算法 所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局 部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。 这种算法的基本思路： （1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。 （2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。 （3）重复（2）。 （4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。 常见的根节点(起始点)（1）虚拟机栈中引用的对象（栈帧中的本地变量表）；（2）方法区中的常量引用的对象；final 常量名=值;（3）方法区中的类静态属性引用的对象 static；（4）本地方法栈中JNI（Native方法）的引用对象。（5）活跃线程。 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 1.如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。 2.如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。 3.常见的垃圾回收算法 标记清除 - 位置不连续 产生碎片 拷贝算法 - 没有碎片，浪费空间 标记压缩 - 没有碎片，效率偏低 4.JVM内存分代模型（用于分代垃圾回收算法） 新生代 + 老年代 + 永久代（1.7）/ 元数据区(1.8) Metaspace 永久代 元数据 - Class 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存） 字符串常量 1.7 - 永久代，1.8 - 堆 MethodArea逻辑概念 - 永久代、元数据 新生代 = Eden + 2个suvivor区 YGC回收之后，大多数的对象会被回收，活着的进入 s0 再次YGC，活着的对象eden + s0 -&gt; s1 再次YGC，eden + s1 -&gt; s0 年龄足够 -&gt; 老年代 （15 CMS 6） suvivor区装不下 -&gt; 老年代 老年代 顽固分子 老年代满了FGC Full GC GC Tuning (Generation) 尽量减少FGC MinorGC = YGC MajorGC = FGC 5.常见的垃圾回收器 Serial 年轻代 串行回收 PS 年轻代 并行回收 ParNew 年轻代 配合CMS的并行回收 SerialOld ParallelOld ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms) G1(10ms) ZGC (1ms) PK C++ Shenandoah Eplison 1.8默认的垃圾回收：PS + ParallelOld 6.JVM调优第一步，了解生产环境下的垃圾回收器组合jvm运行时数据分析在区域中一般分为五块 运行时数据区域 计数器 通过改变这个计数器的值来获取下一条需要执行的字节码,包括判断 循环,跳转,异常处理 方法区(method Area) 该区域用来存放我们生成的各种对象信息 虚拟机栈(VM stack) 每个类 都会在执行的时候创建一个栈帧(javap -c -s xxx.class)来存放关于这个类的所有信息. 包括方法内的局部变量,以及各种操作帧数, 动态链接(各种引用)及方法的出口返回值等等。每个方法的调用到结束意味着虚拟机的栈桢的入栈到出栈, 堆(heap) 在遇到new指令后 我们会根据相对应的内存引用 来找如果有就引用 没有的话就执行类加载 Java 类加载过程那一套东西 本地方法栈(native mathod stack) 存放本地原生调用方法和虚拟机栈一样只不过内容是原生计算机内的C方法 native是与C++联合开发的时候用的 所以一般开发不会用到 前面在堆中说了类引用会检查是否已经加载过当前需要的类 如果没有加载则会去加载 那么类的加载过程就是下面要说的 当程序用到某个类但这个类还没有加载到内存中,jvm会通过加载,连接,初始化来对这个类进行初始化 加载 jvm通过类的全类名来获取字节流 (也就是.class文件) 然后根据字节流创建class对象 创建完成后写入到内存中,然后放在运行时区域的方法区内(method Area) 然后在堆(heap)中创建出对应的Class对象 链接 分为三部分 验证语法 满足jvm虚拟机规范 准备阶段 为类的静态static 分配内存 设置默认值 解析阶段 将符号引用替换为内存引用(直接引用) 初始化 将static修饰的方法或者变量进行初始化,如果有父级引用优先加载父类 那么这个类的加载机制又是什么 它是通过什么来加载的 采用的双亲委派机制 当加载某个类的时候先去询问父类节点是否可以加载 这样既避免了重复加载也防止了注入还提高了效率 常见垃圾回收器组合参数设定：(1.8) -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器 -XX:+UseParNewGC = ParNew + SerialOld 这个组合已经很少用（在某些版本中已经废弃） https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future -XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】 -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC java +XX:+PrintCommandLineFlags -version 通过GC的日志来分辨 Linux下1.8版本默认的垃圾回收器到底是什么？ 1.8.0_181 默认（看不出来）Copy MarkCompact 1.8.0_222 默认 PS + PO java -XX:+PrintFlagsWithComments //只有debug版本能用 JVM的命令行参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html JVM参数分类 标准： - 开头，所有的HotSpot都支持 非标准：-X 开头，特定版本HotSpot支持特定命令 不稳定：-XX 开头，下个版本可能取消 -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal 最终参数值 -XX:+PrintFlagsInitial 默认参数值 PS GC日志详解每种垃圾回收器的日志格式是不同的！ PS日志格式 heap dump部分： 12eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000) 后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址 total = eden + 1个survivor 调优前的基础概念： 吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间） 响应时间：STW越短，响应时间越好 所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量… 问题： 科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO） 响应时间：网站 GUI API （1.8 G1） 什么是调优？ 根据需求进行JVM规划和预调优 优化运行JVM运行环境（慢，卡顿） 解决JVM运行过程中出现的各种问题(OOM) 调优，从规划开始 调优，从业务场景开始，没有业务场景的调优都是耍流氓 无监控（压力测试，能看到结果），不调优 步骤： 熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） 响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应） 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS] 选择回收器组合 计算内存需求（经验值 1.5G 16G） 选定CPU（越高越好） 设定年代大小、升级年龄 设定日志参数 -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause 或者每天产生一个日志文件 观察日志情况 思维导图 查看地址: https://www.processon.com/embed/5e902d83e401fd32b82a99c2 参考资料 https://blogs.oracle.com/ jonthecollector/our-collectors https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp GC和GC Tuning 《深入理解JVM虚拟机》","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"redis-bitmap","slug":"redis-bitmap","date":"2020-04-02T16:00:00.000Z","updated":"2020-04-07T07:26:11.766Z","comments":true,"path":"2020/04/03/redis-bitmap/","link":"","permalink":"http://yoursite.com/2020/04/03/redis-bitmap/","excerpt":"","text":"1. BitMap 是什么在redis中可以设置用一个bit的位置来标识某个元素的0-1状态, 具体的操作指令是 指定某个key的offset的0或者1的状态 1SETBIT key offset value 计算某个key的被设置为 1 的比特位的数量 1BITCOUNT key [start end] 2. BitMap 怎么用12345678910/** * 设置reids的bitmap位置 * @param key * @param offset 根据需求设置long int * @param value * @return */public Boolean setBit(String key,int offset, Boolean value) &#123; return redisTemplate.execute((RedisCallback&lt;Boolean&gt;) con -&gt; con.setBit(key.getBytes(),(long)offset,value));&#125; 123456789/** * 统计key的所有1值 * @param key * @return */public long bitCount(String key) &#123; return redisTemplate.execute((RedisCallback&lt;Long&gt;) con -&gt; con.bitCount(key.getBytes()));&#125; 3. BitMap 什么时候用 短信验证一分钟不能发送5次 之前我们的做法调用reids的increment方法来自增完成需求 现在我们的做法将当前用户当做key ,拿到当前分钟的毫秒数做offset,最后用bitcount来统计用户在当前分钟数访问次数. 记录用户当前是否在线 之前我们的做法我们需要在数据库字段里标志处是否离线 现在我们的做法找到我们需要的key, 拿用户id做offset,最后我们标记出是否在线 还可以统计当前在线总人数","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"redis","slug":"java/redis","permalink":"http://yoursite.com/categories/java/redis/"}],"tags":[]},{"title":"IDEA远程调试","slug":"ideaDebug","date":"2020-02-24T16:00:00.000Z","updated":"2020-04-07T07:54:08.489Z","comments":true,"path":"2020/02/25/ideaDebug/","link":"","permalink":"http://yoursite.com/2020/02/25/ideaDebug/","excerpt":"","text":"远程debug是什么 ?远程debug 原理是利用服务器端口监听来触发本地开发工具IDEA的一种调试手段 什么情况下会用到 ?一般我们本地调试的话会直接在代码中打断点然后debug模式运行代码就可以调试了. 但是我们在实际开发中会遇到一些比较复杂的问题我举几个例子 涉及到调用生产环境会出现的网络问题. 本地运行没问题,只有在测试服务器或者生产环境会出现报错 因为开发系统和服务器系统不一致导致的问题 等等类似这样的问题我们在本地就没办法调试,这时候就需要用到远程服务器调试了. 如何使用远程服务器调试远程调试主要有以下几个步骤 在调试之前我们需要你本地的代码和远程的代码要保持一致 部署上去之后需要加上特定的参数来启动 服务器启动之后在启动本地环境 保持一致就不需要我们详细说了,部署最新版的就可以了. 接下来我们来加上启动参数 原来启动jar包需要的命令1java -jar xxx.jar 如果是远程debug 则需要加上一些参数1java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=4001 xxx.jar 这个参数在idea里可以直接获取到 接下来我们去找如何获取debug参数 菜单 -&gt; Run -&gt; Edit Configurations… 在debug Configurations的弹出框里添加一个remote 之后会弹出一个如下图所示的界面 我们需要配置两个地方.图中的1是我们的服务器地址和端口,端口我们一般默认为4001.也可以自己配置.2是我们需要调试的项目.当这两个配置好后3的位置就会自动生成我们需要的启动参数 之后启动jar的时候添加上 服务器启动好后 在启动本地的remote 注意事项 当发现启动报错 首先检查下你的命令 不要直接复制我的 看你自己生成的代码 保证端口没被占用 本地启动remote会发送请求连接服务器 如果本机无法连接服务器也不行","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"},{"name":"debug","slug":"debug","permalink":"http://yoursite.com/tags/debug/"}]},{"title":"迭代器模式","slug":"Iterator","date":"2020-02-10T16:00:00.000Z","updated":"2020-04-28T10:10:39.341Z","comments":true,"path":"2020/02/11/Iterator/","link":"","permalink":"http://yoursite.com/2020/02/11/Iterator/","excerpt":"","text":"查看java代码 Iterator 和 Collection 模式 其原理就是利用了接口实现规则来约束每个array或者link结构来实现他的遍历方式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"策略设计模式实际应用案例","slug":"strategy","date":"2020-01-17T16:00:00.000Z","updated":"2020-04-24T03:15:28.722Z","comments":true,"path":"2020/01/18/strategy/","link":"","permalink":"http://yoursite.com/2020/01/18/strategy/","excerpt":"","text":"设计模式中的策略模式 讲理论的话网上有很多现成的 以前也看了不少 这次特地在实际项目中抽取出来做成笔记 先说说需求根据不同的单据类型选出选出五个教授 其中单据类型有可转债和挂牌两大类 目前可转债和挂牌各有几种选择方式 下面案例我一样拿出一种来 之前的模式在有多种策略选择相似的情况下，使用 if…else 复杂和难以维护,代码阅读起来也比较困难 现在使用策略模式的步骤及简化结果 具体实现步骤 1创建一个接口。 ProfessorStrategy 123456public interface ProfessorStrategy &#123; List&lt;Professor&gt; five(Integer tableId);&#125; 步骤 2创建实现接口的实体类。 EIMProfessorStrategy 12345678public class EIMProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; IPDProfessorStrategy 123456789public class IPDProfessorStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; UserStrategy 123456789public class UserStrategy implements ProfessorStrategy&#123; @Override public List&lt;Professor&gt; five(Integer tableId) &#123; //省略了我的筛选策略 return null; &#125;&#125; 步骤 3创建具体的 find 方法, 你也可以创建一个有泛型的类来使用。 123456789101112131415 /** * 返回接口数据 * @param tableId * @param professorStrategy * @return */ public static List&lt;SysAttendsModel&gt; find(Integer tableId, ProfessorStrategy professorStrategy) &#123;// 获取对应的五个专家 List&lt;Professor&gt; five = professorStrategy.five(tableId); List&lt;SysAttendsModel&gt; sysAttendsModels = new ArrayList&lt;&gt;(); return sysAttendsModels; &#125; 步骤 4使用 find 来查看当它改变策略 Strategy 时的行为变化。 main 12345678910111213public static void main(String[] args) &#123; // 单据id int tableId = 10086; // 挂牌算法 List&lt;SysAttendsModel&gt; list = find(tableId, new EIMProfessorStrategy()); // 可转债算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new IPDProfessorStrategy()); // 会员算法 List&lt;SysAttendsModel&gt; list2 = find(tableId, new UserStrategy()); &#125; 代码讲解讲讲上面的代码 大概就和支付策略是一个逻辑 支付前都需要找出二维码 支付后都需要查看是否到账 中间走具体的 现金 or 微信支付 or 支付宝支付 我们不关心 不管后面有多少个支付手段我们就加上相对应的接口的实体类就行了.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"外部jar包打包方式","slug":"jarOpinize","date":"2020-01-01T16:00:00.000Z","updated":"2020-04-01T03:22:43.132Z","comments":true,"path":"2020/01/02/jarOpinize/","link":"","permalink":"http://yoursite.com/2020/01/02/jarOpinize/","excerpt":"","text":"将原本 jar 包解压缩找到 BOOT-INF 下的 lib ,该目录下包含当前项目中用到的所有 jar包 ,复制出来放到jar包启动位置 在 pom 中 spring-boot-maven-plugin 打包插件设置打包时排除所有 jar 包 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt; &lt;!-- 排除所有Jar --&gt; &lt;groupId&gt;nothing&lt;/groupId&gt; &lt;artifactId&gt;nothing&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt;&lt;/plugin&gt; 这个时候需要在jar包启动参数上添加一个 -Dloader.path 1java -Dloader.path=&quot;lib/&quot; -jar test.jar","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"linux语法操作","slug":"shell","date":"2019-12-27T16:00:00.000Z","updated":"2020-04-08T06:44:19.461Z","comments":true,"path":"2019/12/28/shell/","link":"","permalink":"http://yoursite.com/2019/12/28/shell/","excerpt":"","text":"&gt;File1234ls ll ls -l ll -rt &gt;shell base12345Ctrl+w:删除光标前面的单词的字符Ctrl – a ：移到行首Ctrl – e ：移到行尾esc - f : 前移一个词esc - b: 后移一个词 创建文件用touch1例如：touch [1.txt] 删除文件用rm1例如：rm -f [1.txt] 创建目录用mkdir1例如：mkdir [xxx] &#123; -p 参数来创建多级文件夹 &#125; 删除空目录用rmdir1例如：rmdir [xxx]（有东西的目录不能删） 打开文件 1vi vim open cat more less 批量创建 1mkdir -p nginxdb/&#123;conf,conf.d,html,logs&#125; &gt;删除删除装有东西的目录就用 -rfi 例如rm -rfi [XXX]1i是为了提醒 最好加上 &gt;查看文件末尾123Tail -20 [filename]# &gt;经常查看日志需要用到这个tail -f xxx.log -n100 重新命名1Mv [old.text] [new.text] &gt;杀死进程1Kill [pid] pkill和阿里源码里学的直接删除程序对应的进程1pkill -f zwkj-0.0.1-SNAPSHOT.jar &gt;权限赋予123Chmod -R 777 [目录]建议了解下 linux权限的 0124 组成 这样就知道777怎么来的chown apple/staff xxx &gt;解压1234zip all.zip *.jpgunzip all.zip &gt;Grep 管道查询1234567891011121314151617-A num：匹配到搜索到的行以及该行下面的num行 -B num：匹配到搜索到的行以及该行上面的num行-C num：匹配到搜索到的行以及上下各num行grep -E -B 1 &apos;use time:&apos; /data/home/zhxt/zhxt-test/logs/test.logls | grep &apos;.docx&apos;ls | grep a* (a 开头的)ls | grep &apos;a*&apos; (包含a的)https://www.cnblogs.com/kongzhongqijing/articles/4462793.html &gt;查看历史输入的命令123cat ~/.bash_historyhistory | head -20 &gt;查看执行文件的路径1whereis mysql &gt;读取文件1Cat [filename] &gt;查询文件123find [path_root] -name &apos;*.doc*&apos;find / -name [xxx] -dlocate &gt;查看某个端口是否被占用 习惯用lsof 不想用netstat123456安装 yum install lsof -y lsof -i tcp:8080 (PS 必须用root权限) netstat -tunlp|grep [端口号]ps -axu|grep [java] 启动位置输出 &gt;文件下载1wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.zip --no-check-certificate &gt;scp下载123scp -P 2204 isinonet@106.37.74.50:/home/gzzx/excel/ProfessionReport18584791024.xlsx /Users/apple/Documentsscp -P 2204 isinonet@106.37.74.50:/logs/test.log /Users/apple/Documents-r 文件夹 -p端口 &gt;上传服务器文件移动12scp /Users/apple/Documents/zwsj-category-0.0.1-SNAPSHOT.jar root@192.168.0.118:/home/zwsjObjScp -r &gt;其他查看磁盘容量12df -hl /xxx 查看位置12which java rpm包安装12rpm -ivh **.rpm 后台运行命令12Nohup 详细指南 该命令用来列出目前与过去登录系统的用户相关信息12Last Linux查看文件夹大小12du -sh 查看当前文件夹大小12du -sh * | sort -n 统计当前文件夹(目录)大小，并按文件大小排序12du -sk filename 查看指定文件大小 遇到其他不会的命令实例可以按照这个命令来查看基础语法1tldr mkdir","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"vimrc配置文件","slug":"vimrc","date":"2019-12-17T16:00:00.000Z","updated":"2019-12-19T09:19:22.865Z","comments":true,"path":"2019/12/18/vimrc/","link":"","permalink":"http://yoursite.com/2019/12/18/vimrc/","excerpt":"","text":"替换了本地的自带的vi 采用了 macvim 安装方法通过 brew 1brew install macvim 安装过程需要xcode的支持 下载时间比较长耐心等待下 可能会报错 具体解决原有看报错后的日志 之后需要修改.bash_profile 123alias vi=vimalias vim=mvimalias mvim=&apos;/usr/local/bin/mvim -v&apos; 安装完成后 去配置vim的 .vimrc文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&quot;=========================================================================&quot; DesCRiption: 适合自己使用的vimrc文件，for Linux/Windows, GUI/Console&quot;&quot; Last Change: 2019年08月02日 15时13分 &quot;&quot; Version: 1.80&quot;&quot;=========================================================================set nocompatible &quot; 关闭 vi 兼容模式syntax on &quot; 自动语法高亮set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot; 设定 tab 长度为 4set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录filetype plugin indent on &quot; 开启插件set backupcopy=yes &quot; 设置备份时的行为为覆盖set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan &quot; 禁止在搜索到文件两端时重新搜索set incsearch &quot; 输入搜索内容时就显示搜索结果set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码&quot; set showmatch &quot; 插入括号时，短暂地跳转到匹配的对应括号&quot; set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set hidden &quot; 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start&quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\\ %&lt;%F[%1*%M%*%n%R%H]%=\\ %y\\ %0(%&#123;&amp;fileformat&#125;\\ %&#123;&amp;encoding&#125;\\ %c:%l/%L%)\\ &quot; 设置在状态行显示的信息set foldenable &quot; 开始折叠set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度setlocal foldlevel=1 &quot; 设置折叠层数为&quot; set foldclose=all &quot; 设置为自动关闭折叠 &quot; nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot; 用空格键来开关折叠&quot; return OS type, eg: windows, or linux, mac, et.st..function! MySys()if has(&quot;win16&quot;) || has(&quot;win32&quot;) || has(&quot;win64&quot;) || has(&quot;win95&quot;)return &quot;windows&quot;elseif has(&quot;unix&quot;)return &quot;linux&quot;endifendfunction&quot; 用户目录变量$VIMFILESif MySys() == &quot;windows&quot;let $VIMFILES = $VIM.&apos;/vimfiles&apos;elseif MySys() == &quot;linux&quot;let $VIMFILES = $HOME.&apos;/.vim&apos;endif&quot; 设定doc文档目录let helptags=$VIMFILES.&apos;/doc&apos;&quot; 设置字体 以及中文支持if has(&quot;win32&quot;)set guifont=Inconsolata:h12:cANSIendif&quot; 配置多语言环境if has(&quot;multi_byte&quot;)&quot; UTF-8 编码set encoding=utf-8set termencoding=utf-8set formatoptions+=mMset fencs=utf-8,gbkif v:lang =~? &apos;^\\(zh\\)\\|\\(ja\\)\\|\\(ko\\)&apos;set ambiwidth=doubleendifif has(&quot;win32&quot;)source $VIMRUNTIME/delmenu.vimsource $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8endifelseechoerr &quot;Sorry, this version of (g)vim was not compiled with +multi_byte&quot;endif&quot; Buffers操作快捷方式!nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;&quot; Tab操作快捷方式!nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;&quot;关于tab的快捷键&quot; map tn :tabnext&lt;cr&gt;&quot; map tp :tabprevious&lt;cr&gt;&quot; map td :tabnew .&lt;cr&gt;&quot; map te :tabedit&quot; map tc :tabclose&lt;cr&gt;&quot;窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动&quot;光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的&quot;时候会变得非常方便.nnoremap &lt;C-h&gt; &lt;C-w&gt;hnnoremap &lt;C-j&gt; &lt;C-w&gt;jnnoremap &lt;C-k&gt; &lt;C-w&gt;knnoremap &lt;C-l&gt; &lt;C-w&gt;l&quot;一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;&quot; set fileformats=unix,dos,mac&quot; nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;&quot; nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;&quot; use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result&quot; map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;&quot; map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;&quot; map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;&quot; map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;&quot; 让 Tohtml 产生有 CSS 语法的 html&quot; syntax/2html.vim，可以用:runtime! syntax/2html.vimlet html_use_css=1&quot; Python 文件的一般设置，比如不要 tab 等autocmd FileType python set tabstop=4 shiftwidth=4 expandtabautocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot; 打开javascript折叠let b:javascript_fold=1&quot; 打开javascript对dom、html和css的支持let javascript_enable_domhtmlcss=1&quot; 设置字典 ~/.vim/dict/文件的路径autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dictautocmd filetype css set dictionary=$VIMFILES/dict/css.dictautocmd filetype php set dictionary=$VIMFILES/dict/php.dict&quot;-----------------------------------------------------------------&quot; plugin - bufexplorer.vim Buffers切换&quot; \\be 全屏方式查看全部打开的文件列表&quot; \\bv 左右方式查看 \\bs 上下方式查看&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - taglist.vim 查看函数列表，需要ctags程序&quot; F4 打开隐藏taglist窗口&quot;-----------------------------------------------------------------if MySys() == &quot;windows&quot; &quot; 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = &apos;&quot;&apos;.$VIMRUNTIME.&apos;/ctags.exe&quot;&apos;elseif MySys() == &quot;linux&quot; &quot; 设定windows系统中ctags程序的位置let Tlist_Ctags_Cmd = &apos;/usr/bin/ctags&apos;endifnnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;let Tlist_Show_One_File = 1 &quot; 不同时显示多个文件的tag，只显示当前文件的let Tlist_Exit_OnlyWindow = 1 &quot; 如果taglist窗口是最后一个窗口，则退出vimlet Tlist_Use_Right_Window = 1 &quot; 在右侧窗口中显示taglist窗口let Tlist_File_Fold_Auto_Close=1 &quot; 自动折叠当前非编辑文件的方法列表let Tlist_Auto_Open = 0let Tlist_Auto_Update = 1let Tlist_Hightlight_Tag_On_BufEnter = 1let Tlist_Enable_Fold_Column = 0let Tlist_Process_File_Always = 1let Tlist_Display_Prototype = 0let Tlist_Compact_Format = 1&quot;-----------------------------------------------------------------&quot; plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。&quot; \\m mark or unmark the word under (or before) the cursor&quot; \\r manually input a regular expression. 用于搜索.&quot; \\n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .&quot; \\* 当前MarkWord的下一个 \\# 当前MarkWord的上一个&quot; \\/ 所有MarkWords的下一个 \\? 所有MarkWords的上一个&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录&quot; :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree&quot; o 打开关闭文件或者目录 t 在标签页中打开&quot; T 在后台标签页中打开 ! 执行此文件&quot; p 到上层目录 P 到根目录&quot; K 到第一个节点 J 到最后一个节点&quot; u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）&quot; r 递归刷新当前目录 R 递归刷新当前根目录&quot;-----------------------------------------------------------------&quot; F3 NERDTree 切换map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;&quot;-----------------------------------------------------------------&quot; plugin - NERD_commenter.vim 注释代码用的，&quot; [count],cc 光标以下count行逐行添加注释(7,cc)&quot; [count],cu 光标以下count行逐行取消注释(7,cu)&quot; [count],cm 光标以下count行尝试添加块注释(7,cm)&quot; ,cA 在行尾插入 /* */,并且进入插入模式。 这个命令方便写注释。&quot; 注：count参数可选，无则默认为选中行或当前行&quot;-----------------------------------------------------------------let NERDSpaceDelims=1 &quot; 让注释符与语句之间留一个空格let NERDCompactSexyComs=1 &quot; 多行注释时样子更好看&quot;-----------------------------------------------------------------&quot; plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释&quot;-----------------------------------------------------------------let g:DoxygenToolkit_authorName=&quot;Asins - asinsimple AT gmail DOT com&quot;let g:DoxygenToolkit_briefTag_funcName=&quot;yes&quot;map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;map &lt;leader&gt;df :Dox&lt;CR&gt;map &lt;leader&gt;db :DoxBlock&lt;CR&gt;map &lt;leader&gt;dc a /* */&lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;&quot;-----------------------------------------------------------------&quot; plugin – ZenCoding.vim 很酷的插件，HTML代码生成&quot; 插件最新版：http://github.com/mattn/zencoding-vim&quot; 常用命令可看：http://nootn.com/blog/Tool/23/&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin – checksyntax.vim JavaScript常见语法错误检查&quot; 默认快捷方式为 F5&quot;-----------------------------------------------------------------let g:checksyntax_auto = 0 &quot; 不自动检查&quot;-----------------------------------------------------------------&quot; plugin - NeoComplCache.vim 自动补全插件&quot;-----------------------------------------------------------------let g:AutoComplPop_NotEnableAtStartup = 1let g:NeoComplCache_EnableAtStartup = 1let g:NeoComplCache_SmartCase = 1let g:NeoComplCache_TagsAutoUpdate = 1let g:NeoComplCache_EnableInfo = 1let g:NeoComplCache_EnableCamelCaseCompletion = 1let g:NeoComplCache_MinSyntaxLength = 3let g:NeoComplCache_EnableSkipCompletion = 1let g:NeoComplCache_SkipInputTime = &apos;0.5&apos;let g:NeoComplCache_SnippetsDir = $VIMFILES.&apos;/snippets&apos;&quot; &lt;TAB&gt; completion.inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : &quot;\\&lt;TAB&gt;&quot;&quot; snippets expand keyimap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)&quot;-----------------------------------------------------------------&quot; plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转&quot; % 正向匹配 g% 反向匹配&quot; [% 定位块首 ]% 定位块尾&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转&quot; SVN/git管理工具&quot;-----------------------------------------------------------------&quot;-----------------------------------------------------------------&quot; plugin – a.vim&quot;----------------------------------------------------------------&quot;让vimrc配置变更立即生效autocmd BufWritePost $MYVIMRC source $MYVIMRC-","categories":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}],"tags":[]},{"title":"spring cloud alibaba","slug":"alibaba","date":"2019-12-15T16:00:00.000Z","updated":"2019-12-16T06:09:32.591Z","comments":true,"path":"2019/12/16/alibaba/","link":"","permalink":"http://yoursite.com/2019/12/16/alibaba/","excerpt":"","text":"spring cloud alibaba nacos 远程配置 | 服务发现和注册ribbon 负载均衡sentinel 熔断监控gateway 网关skywalking 链路追踪rockertMQ 异步通讯seata 分布式事务管理dubbo RPC框架","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[]},{"title":"责任链模式","slug":"cor","date":"2019-12-07T16:00:00.000Z","updated":"2020-04-27T07:29:22.701Z","comments":true,"path":"2019/12/08/cor/","link":"","permalink":"http://yoursite.com/2019/12/08/cor/","excerpt":"","text":"123456789101112131415public class Servlet_Main &#123; public static void main(String[] args) &#123; Request request = new Request(); request.str = \"开始 进入: &lt;&gt; 1 \"; Response response = new Response(); response.str = \"结束 退出: \"; FilterChain chain = new FilterChain(); chain.add(new HTMLFilter()).add(new SensitiveFilter()); chain.doFilter(request, response); System.out.println(request.str); System.out.println(response.str); &#125;&#125; 123interface Filter &#123; void doFilter(Request request, Response response, FilterChain chain);&#125; 12345678class Request &#123; String str;&#125;class Response &#123; String str;&#125; 123456789101112131415161718192021222324252627282930313233class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // 进入的时候做的业务逻辑 request.str = request.str.replaceAll(\"&lt;\", \"[\").replaceAll(\"&gt;\", \"]\") + \"HTMLFilter()\"; // 调用下一个chain chain.doFilter(request, response); // 完成后做业务逻辑 response.str += \"--HTMLFilter()\"; &#125;&#125;class SensitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; // 进入之前做的业务逻辑 System.out.println(\"拦截器2\"); request.str = request.str.replaceAll(\"1\", \"2\") + \" SensitiveFilter()\"; // 去找下一个chain chain.doFilter(request, response); // 之后的逻辑处理 response.str += \"--SensitiveFilter()\"; &#125;&#125; 1234567891011121314151617181920212223242526272829class FilterChain &#123; List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); int index = 0; public FilterChain add(Filter f) &#123; filters.add(f); return this; &#125; public void doFilter(Request request, Response response) &#123; if(index == filters.size()) &#123; // 做了某些业务后需要返回 System.out.println(\"做了某些业务后需要返回\"); return; &#125; Filter f = filters.get(index); index ++; f.doFilter(request, response, this); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"装饰者模式","slug":"decorator","date":"2019-11-30T16:00:00.000Z","updated":"2020-04-27T07:30:01.470Z","comments":true,"path":"2019/12/01/decorator/","link":"","permalink":"http://yoursite.com/2019/12/01/decorator/","excerpt":"","text":"decorator 装饰器","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"idea 显示run dashboard","slug":"ideaRun","date":"2019-11-19T16:00:00.000Z","updated":"2020-04-08T06:41:57.428Z","comments":true,"path":"2019/11/20/ideaRun/","link":"","permalink":"http://yoursite.com/2019/11/20/ideaRun/","excerpt":"","text":"在最上面的 help -&gt; edit custom VM options 在打开的xml里面添加 -Dide.run.dashboard=true","categories":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}]},{"title":"享元模式","slug":"flyweight","date":"2019-10-07T16:00:00.000Z","updated":"2020-04-28T03:42:21.514Z","comments":true,"path":"2019/10/08/flyweight/","link":"","permalink":"http://yoursite.com/2019/10/08/flyweight/","excerpt":"","text":"重点是重复利用对象 类似安卓 的 List组件 RecyclerView 创建一个对象 1234567891011class Bullet &#123; public UUID id = UUID.randomUUID(); boolean living = true; @Override public String toString() &#123; return \"Bullet&#123;\" + \"id=\" + id + '&#125;'; &#125;&#125; 维持一个池子里的key for循环查看key的标签是否可以重复利用 如果可以则返回 不可以说明都在用 这个时候需要new出来了 12345678910111213141516171819public class BulletPool &#123; List&lt;Bullet&gt; bullets = new ArrayList&lt;&gt;(); &#123; for (int i = 0; i &lt; 5; i++) bullets.add(new Bullet()); &#125; public Bullet getBullet() &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet b = bullets.get(i); if (!b.living) return b; &#125; return new Bullet(); &#125; &#125; main函数实际使用 12345678public static void main(String[] args) &#123; BulletPool bp = new BulletPool(); for (int i = 0; i &lt; 10; i++) &#123; Bullet b = bp.getBullet(); System.out.println(b); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"docker基本语法","slug":"dockerShell","date":"2019-10-07T16:00:00.000Z","updated":"2020-05-12T06:38:14.847Z","comments":true,"path":"2019/10/08/dockerShell/","link":"","permalink":"http://yoursite.com/2019/10/08/dockerShell/","excerpt":"","text":"查看所有正在运行容器 1$ docker ps 查看所有容器 1$ docker ps -a 查看所有容器ID 1$ docker ps -a -q 启动容器 1$ docker start [NAME] stop停止所有容器 12$ docker stop $(docker ps -a -q) remove删除所有容器 1$ docker rm $(docker ps -a -q) run创建一个新的服务 1docker run -it [NAME] /bin/bash Exec 进入一个已经存在的 1docker exec -it 217a29f3495a /bin/bash 查看容器启动日志 1docker logs [容器ID] -删除容器镜像 image12sudo docker rmi IMAGE [IMAGE...] sudo docker rmi centos:latest 强制删除 实例 1docker rm -f 启动一个实例Container 123sudo docker run [OPTIONS] IMAGE [COMMAND] [ARG...]sudo docker run -t -i contos /bin/bashsudo docker run -p 8080:8080 -d [name]","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"观察者模式","slug":"ObServer","date":"2019-10-07T16:00:00.000Z","updated":"2020-05-13T02:05:05.796Z","comments":true,"path":"2019/10/08/ObServer/","link":"","permalink":"http://yoursite.com/2019/10/08/ObServer/","excerpt":"","text":"简单说下 后续再改 首先这个模式很常见 类似的有 callback function ,listener , hook 都是这样的, 也可以说是一个东西 窗口添加事件 js 回调事件 等等类似的其实本质上都是ObServer模式 首先我们看下main函数运行的代码 12345678910public static void main(String[] args) &#123; Button b = new Button(); b.addActionListener(new MyActionListener()); b.addActionListener(new MyActionListener2()); b.addActionListener((e)-&gt;&#123; System.out.println(\"ppp\"); &#125;); b.buttonPressed();&#125; 因为你之前new Button() 所以我们会实现一个button类 里面会有一个for循环来依次实现你之前添加的事件 就是buttonPressed 里的 for循环 同时还有一个添加事件的方法 12345678910111213141516class Button &#123; private List&lt;ActionListener&gt; actionListeners = new ArrayList&lt;ActionListener&gt;(); public void buttonPressed() &#123; ActionEvent e = new ActionEvent(System.currentTimeMillis(),this); for(int i=0; i&lt;actionListeners.size(); i++) &#123; ActionListener l = actionListeners.get(i); l.actionPerformed(e); &#125; &#125; public void addActionListener(ActionListener l) &#123; actionListeners.add(l); &#125;&#125; 接下来我们需要写 事件类的接口 参数是你具体的事件本身 123interface ActionListener &#123; public void actionPerformed(ActionEvent e);&#125; 添加事件类接口的实现 1234567891011121314151617class MyActionListener implements ActionListener &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"button pressed!\"); &#125; &#125;class MyActionListener2 implements ActionListener &#123; public void actionPerformed(ActionEvent e) &#123; System.out.println(\"button pressed 2!\"); &#125; &#125; 然后是刚刚传的参数你也需要定义 这里我们定义的是 事件本身需要的属性 这里有两个 你可以根据自己的业务需求来判断 123456789101112131415161718192021class ActionEvent &#123; long when; Object source; public ActionEvent(long when, Object source) &#123; super(); this.when = when; this.source = source; &#125; public long getWhen() &#123; return when; &#125; public Object getSource() &#123; return source; &#125; &#125; 一般会和责任链模式配合使用 在返回false后执行失败监听函数","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"git 忽略已经提交和没提交的文件","slug":"gitignore","date":"2019-10-07T16:00:00.000Z","updated":"2019-12-27T09:23:18.414Z","comments":true,"path":"2019/10/08/gitignore/","link":"","permalink":"http://yoursite.com/2019/10/08/gitignore/","excerpt":"","text":"没有提交的其实一直都知道有这么个功能 但是一直都是手写没有记录 可以先去看下github官方提供的gitignore 里面有各种语言的 gitignore https://github.com/github/gitignore 自己个性化的话 可以在上面的文件基础上修改 在Git工作区的根目录下创建一个特殊的 .gitignore 下面是我自己使用的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/target/**/targettarget!.mvn/wrapper/maven-wrapper.jar###STS###.apt_generated.classpath.factorypath.project.settings.springBeans.sts4-cache###IntelliJIDEA###.idea*.iws*.iml*.ipr###NetBeans###/nbproject/private//build//nbbuild//dist//nbdist//.nb-gradle/#Compiledclassfile*.class#Logfile*.log#BlueJfiles*.ctxt#MobileToolsforJava(J2ME).mtj.tmp/#PackageFiles#*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.pdf.zip.doc 下面是一些语法使用1234567891011121314151617• bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件• /bin: 忽略根目录下的bin文件• /*.c: 忽略 cat.c，不忽略 build/cat.c• debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj• **/foo: 忽略/foo, a/foo, a/b/foo等• a/**/b: 忽略a/b, a/x/b, a/x/y/b等• !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件• *.log: 忽略所有 .log 文件• config.php: 忽略当前路径的 config.php 文件 已经提交但是本地在修改需要忽略的值得注意的是中央仓库已经存在该文件后 需要取消追踪对某个文件取消跟踪 12345git rm --cached readme1.txt # 删除readme1.txt的跟踪，并保留在本地。git add -A # 这里是将所有的改动提交到gitgit commit -m &apos;update local file&apos; 然后git commit 即可。但是git status查看状态时还是会列出来","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"博客MD模板应用","slug":"singleton","date":"2019-10-07T16:00:00.000Z","updated":"2020-05-13T02:05:05.797Z","comments":true,"path":"2019/10/08/singleton/","link":"","permalink":"http://yoursite.com/2019/10/08/singleton/","excerpt":"","text":"\\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"多线程与高并发(基础知识)","slug":"juc","date":"2019-08-17T16:00:00.000Z","updated":"2020-05-13T02:03:52.379Z","comments":true,"path":"2019/08/18/juc/","link":"","permalink":"http://yoursite.com/2019/08/18/juc/","excerpt":"","text":"","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"build 复杂对象构造器","slug":"build","date":"2019-08-17T16:00:00.000Z","updated":"2020-04-29T07:26:49.549Z","comments":true,"path":"2019/08/18/build/","link":"","permalink":"http://yoursite.com/2019/08/18/build/","excerpt":"","text":"Build 模式一般是用来对复杂对象的构造器 一般我们可以对一个复杂对象这样new 12345678910111213public SysMessage(String phone, String comm, LocalDateTime sendTime, Integer status, Integer templateId, String tableId, String name, String role) &#123; this.phone = phone; this.comm = comm; this.sendTime = sendTime; this.status = status; this.templateId = templateId; this.tableId = tableId; this.name = name; this.role = role;&#125; 使用的时候是这样的 123new SysMessage(getTel(), comm, LocalDateTime.now() , getDeleted(), 1006, \"10086\", getName(), \"专家\") 上面这个例子是一个短信模板对象的生成 这样写也可以 如果不想要其中某个我们可以传空 但是这么写在&lt;&gt;中是不推荐这么写的 书中写到如果你要构建复杂对象的话 最好使用build模式来做 1234567891011121314151617181920212223242526272829303132public static class SysMessageBuild&#123; SysMessage sysMessage = new SysMessage(); public SysMessageBuild basicInfo(String role,String name,String phone,String comm) &#123; sysMessage.role = role; sysMessage.name = name; sysMessage.phone = phone; sysMessage.comm = comm; return this; &#125; public SysMessageBuild sendTime(LocalDateTime sendTime)&#123; sysMessage.sendTime = sendTime; return this; &#125; public SysMessageBuild status(Integer status)&#123; sysMessage.status = status; return this; &#125; public SysMessageBuild templateId(Integer templateId)&#123; sysMessage.templateId = templateId; return this; &#125; public SysMessageBuild tableId(String tableId)&#123; sysMessage.tableId = tableId; return this; &#125; public SysMessage build() &#123; return sysMessage; &#125; 最后用一个build方法返回","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"AOP之代理模式","slug":"Proxy","date":"2019-08-17T16:00:00.000Z","updated":"2020-04-28T08:15:20.779Z","comments":true,"path":"2019/08/18/Proxy/","link":"","permalink":"http://yoursite.com/2019/08/18/Proxy/","excerpt":"","text":"在我看来 代理模式 最常用 也最难理解 会得不难 , 难得不会, 在我看来现在理解了代理的运作模式也觉得没有以前想的那么复杂 代理模式说白了就是面向切面编程 AOP 业务和实际切点代码分割 那么重点就在于 如何使在最小修改业务代码的情况下 来完成切点的插入 首先实现一个业务接口 123interface Movable &#123; void move();&#125; 接口具体实现类 123456789101112131415public class Tank implements Movable &#123; /** * 模拟坦克移动了一段儿时间 */ @Override public void move() &#123; System.out.println(\"Tank moving claclacla...\"); try &#123; Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个时候我们有一个新的需求需要在 这段业务前后加入某些逻辑 不管是日志还是权限 这个时候我们需要新建一个代理类 实现 InvocationHandler 接口 然后实现具体的invoke方法 具体逻辑看下图 1234567891011121314151617181920212223242526class TimeProxy implements InvocationHandler &#123; Movable m; public TimeProxy(Movable m) &#123; this.m = m; &#125; public void before() &#123; System.out.println(\"method start..\"); &#125; public void after() &#123; System.out.println(\"method stop..\"); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //Arrays.stream(proxy.getClass().getMethods()).map(Method::getName).forEach(System.out::println); before(); Object o = method.invoke(m, args); after(); return o; &#125;&#125; 最纠结的点可能是 这段代码 method.invoke(m, args); 先放一边 我们看是怎么调用的 main函数调用 12345678910public static void main(String[] args) &#123; Tank tank = new Tank(); //返回的是ASM生成的$Proxy0的方法 后续调用也是调用这个方法的move Movable m = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader(), new Class[]&#123;Movable.class&#125;, //tank.class.getInterfaces() new TimeProxy(tank) ); m.move();&#125; 我们给Proxy 传了三个参数 分别是 Tank.class.getClassLoader() 生成的代理对象$Proxy0 我们传的是tank.class 实现的接口是movable 所以ASM生成的代理类对象$Proxy0 也会实现接口movable 同时也会实现里面的方法 move() 可以说 我们把 Movable 传进去告诉ASM 你们给我生成一个实现了Movable接口的类 让我来调用 new Class[]{Movable.class} 也可以写成 1Tank.class.getInterfaces() reflection 通过二进制字节码分析类的属性和方法 就是拿到这个接口类的所有的属性和方法 不明白的话我举个例子 就是 Tank这个类实现的接口是哪个接口类 你要告诉ASM 你也可以直接给我new出来 这个类 也可以通过 Tank拿到他的接口类 new TimeProxy(tank) 这个就是具体的实现类 你具体要给这个接口的哪个实现类实现代理你要给ASM说 这三个参数涉及到 ASM newProxyInstance生成代理类对象的逻辑 可能会有点复杂在这里就不展开谈了","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"博客MD模板应用","slug":"A1tamplate","date":"2019-08-17T16:00:00.000Z","updated":"2020-04-28T03:43:53.312Z","comments":true,"path":"2019/08/18/A1tamplate/","link":"","permalink":"http://yoursite.com/2019/08/18/A1tamplate/","excerpt":"","text":"\\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"},{"name":"java","slug":"other/java","permalink":"http://yoursite.com/categories/other/java/"},{"name":"linux","slug":"other/java/linux","permalink":"http://yoursite.com/categories/other/java/linux/"},{"name":"db","slug":"other/java/linux/db","permalink":"http://yoursite.com/categories/other/java/linux/db/"},{"name":"工具","slug":"other/java/linux/db/工具","permalink":"http://yoursite.com/categories/other/java/linux/db/工具/"}],"tags":[]},{"title":"组合模式","slug":"compsite","date":"2019-08-11T16:00:00.000Z","updated":"2020-04-27T07:29:47.792Z","comments":true,"path":"2019/08/12/compsite/","link":"","permalink":"http://yoursite.com/2019/08/12/compsite/","excerpt":"","text":"组合模式用来处理树状接口 处理树状结构本质上就是查看当前节点是否包含子节点 所以说只需要判断 当前节点下是否有子节点 然后循环遍历 做这个树状结构也只需要 一个节点抽象类 两个节点信息 (一个是下面有节点,一个是没节点的) 一个抽象类 1234abstract class Node &#123; abstract public void p();&#125; 有两个类继承节点信息 区别就是一个类有子节点 一个没有 没有子节点的如下图 12345678910class LeafNode extends Node &#123; String content; public LeafNode(String content) &#123;this.content = content;&#125; @Override public void p() &#123; System.out.println(content); &#125;&#125; 有子节点的如下如 有子节点 意味着需要维护一个list 还需要一个add 方法来添加子节点 12345678910111213141516class BranchNode extends Node &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); String name; public BranchNode(String name) &#123;this.name = name;&#125; @Override public void p() &#123; System.out.println(name); &#125; public void add(Node n) &#123; nodes.add(n); &#125;&#125; 使用的话就是 添加root节点 然后依次添加 大节点和小节点 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; BranchNode root = new BranchNode(\"root\"); BranchNode chapter1 = new BranchNode(\"chapter1\"); BranchNode chapter2 = new BranchNode(\"chapter2\"); Node r1 = new LeafNode(\"r1\"); Node c11 = new LeafNode(\"c11\"); Node c12 = new LeafNode(\"c12\"); BranchNode b21 = new BranchNode(\"section21\"); Node c211 = new LeafNode(\"c211\"); Node c212 = new LeafNode(\"c212\"); root.add(chapter1); root.add(chapter2); root.add(r1); chapter1.add(c11); chapter1.add(c12); chapter2.add(b21); b21.add(c211); b21.add(c212); // 遍历 tree(root, 0); &#125; static void tree(Node b, int depth) &#123; for(int i=0; i&lt;depth; i++) System.out.print(\"--\"); b.p(); if(b instanceof BranchNode) &#123; for (Node n : ((BranchNode)b).nodes) &#123; tree(n, depth + 1); &#125; &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"基于SLF4J MDC机制配合AOP实现日志的链路追踪","slug":"slf4jMDC","date":"2019-05-30T16:00:00.000Z","updated":"2020-04-08T06:44:37.502Z","comments":true,"path":"2019/05/31/slf4jMDC/","link":"","permalink":"http://yoursite.com/2019/05/31/slf4jMDC/","excerpt":"","text":"问题描述一个合格的项目必须要有日志来支撑,日志不但能记录输入输出,当系统有问题的时候我们还需要做线上问题的排查. 在一个正常的项目中日志里包含了各种各样的接口及其他无关的数据日志,那么我们如何快速定位单次请求中所有的日志呢 ? 问题分析当我们设计一个系统日志的时候 首先我们需要解决以下几个问题 哪些数据需要写进日志中 日志如何分类 按天还是按周 如何区分每次请求 请求参数及返回值需不需要打印 如何进行多环节配置 解决方案按照上面的问题我们来一个一个解决 主要思路是 AOP 负责切入每个请求及参数打印 在进入 controller 之前打印本次请求的各种参数 MDC 添加 hashCode 来做参数校验 日志使用 logback 配置 日志按天分类,每天生成一个日志 利用 thread 来区分每次请求 springProfile 来做多环境配置 aop 有两种CGLIB,JDK 都是动态代理 今天不讨论这两者的区别 我使用的是 CGLIB pom 中引入 SpringBoot 的 web 模块和使用 AOP 相关的依赖： 定义切面类，实现 web 层的日志切面 对所有的 web 请求做切面来记录日志 第一种 AOP 上 logback 的输出1234567891011121314151617181920// 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null &amp;&amp; joinPoint != null) &#123; HttpServletRequest request = attributes.getRequest(); // 记录请求内容 log.info( \"1. 对象请求的URL : \" + request.getRequestURL().toString()); log.info( \"2. 请求方法名称 : \" + request.getMethod()); log.info( \"3. 对方IP地址 : \" + request.getRemoteAddr()); log.info( \"4. 运行的java类 : \" + joinPoint.getSignature().getDeclaringTypeName() + \".\" + joinPoint.getSignature().getName()); try&#123; log.info(\"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); &#125;catch (Exception e)&#123; log.info(\"请求参数切点无法切入\"); &#125; &#125;else&#123; throw new CheckException(\"网络请求出错, 请清空缓存重新尝试. \"); &#125; 第二种 request.HashCode 唯一标示在获得 12log.info(request.hashCode()+ \"5. 请求参数 : \" + JSONObject.toJSONString(joinPoint.getArgs() )); 第三种 基于 SLF4J 的 MDC 机制12MDC.put(\"THREAD_ID\", \"userId\"+ userService.getId() ); 1&lt;pattern&gt;%date [%thread] %-5level %logger&#123;80&#125; %X&#123;THREAD_ID&#125; || %msg%n&lt;/pattern&gt; 第四种 结合 HashCode 和 MDC12MDC.put(\"THREAD_ID\", \"\"+request.hashCode()); 最终效果12345678910112019-06-04 10:14:27,743 [main] INFO com.zwkj.zhxt.ZhxtApplication || Started ZhxtApplication in 48.489 seconds (JVM running for 56.375)2019-06-04 10:15:28,310 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:28,313 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:28,314 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:28,323 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:28,585 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：168 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg=='2019-06-04 10:15:30,860 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || @Around:结果是 :ResultBean com.zwkj.zhxt.controller.SysUserController.findSysUser(UserModel) use time: 25512019-06-04 10:15:30,861 [qtp1387878879-21] INFO com.zwkj.zhxt.common.ControllerAOP || 282556454: 方法的返回值 : ResultBean(msg=success, code=0, data=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub3ciOiIxNTU5NjE0NTMwMjE2emh4dCIsImtleSI6InVzZXIxMiJ9.ae7ra7hvDSp5N6YfuGYzr8ULeq7Zr5OuC_4PbybqceY) 12345672019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 1. 对象请求的URL : http://localhost:8088/zhxtotc/sys-user/login2019-06-04 10:15:41,401 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2. 请求方法名称 : POST2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 3. 对方IP地址 : 0:0:0:0:0:0:0:12019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 4. 运行的java类 : com.zwkj.zhxt.controller.SysUserController.findSysUser2019-06-04 10:15:41,402 [qtp1387878879-19] INFO com.zwkj.zhxt.common.ControllerAOP || 2825564545. 请求参数 : [&#123;\"code\":\"string\",\"password\":\"123456\",\"phone\":\"string\",\"username\":\"admin12\"&#125;] Time：151 ms - ID：com.zwkj.zhxt.mvc.sysuser.mapper.SysUserMapper.selectOneExecute SQL：SELECT id,username,password,nickname,role_id,create_time,update_time,delete_status,user_id FROM sys_user WHERE username = 'admin12' AND password = '4QrcOUm6Wau+VuBX8g+IPg==' \\*literal asterisks\\* 转义 *literal asterisks* MD 语法 加粗 **加粗** 比较粗 MD 语法 斜体 *斜体* 本来就是斜的 MD 语法 列表 1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD 语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD 语法 分割线 *** 代表一条分割线 MD 语法 A 标签 [A 标签显示的名称](链接地址) baidu MD 语法 图片 ![ 图片说明 ](图片地址) MD 语法 编写代码 三个 ` 123def test() print('asd')test() MD 语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD 语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"spring-boot-ioc 解析","slug":"springBootIOC","date":"2019-05-21T16:00:00.000Z","updated":"2020-04-08T06:44:50.945Z","comments":true,"path":"2019/05/22/springBootIOC/","link":"","permalink":"http://yoursite.com/2019/05/22/springBootIOC/","excerpt":"","text":"内容过期","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"http://yoursite.com/tags/ioc/"}]},{"title":"记一次慢sql的查询记录","slug":"sqlOptimize","date":"2019-05-12T16:00:00.000Z","updated":"2020-04-08T07:04:30.720Z","comments":true,"path":"2019/05/13/sqlOptimize/","link":"","permalink":"http://yoursite.com/2019/05/13/sqlOptimize/","excerpt":"","text":"本质上来讲 sql优化和数据库优化是两种优化 数据库优化包含的种类较多 软件优化,硬件优化 理论上 单个mysql数据库能够支撑的是每秒2000的并发 极限是5000 当然本次不说数据库优化 先说sql优化 sql优化一般是针对单个业务进行优化 比如秒杀 系统的订单查询 (一般用redis 这里只是举个例子) 或者说是对excel表格进行分析插入数据库 等等各种各样的业务 当然一个简单的sql 可能就是这样的 1SELECT * from test WHERE ASSIGNEE_ = 'user1' 但在实际业务环境中可能并不是这样 实际会复杂很多 以及很多条件 当我们在处理这样的sql的时候 应该怎么去优化以及从哪里入手 索引我们大家都是知道索引可以很好的帮我们来提高效率 但是具体怎么用 以及针对某个业务或者单条sql怎么优化 再说这些之前我们先针对SQL进行一些常识性优化 比如 基本优化WHERE 子句里面的列尽量被索引 尽量避免使用 “SELECT *” 如果用到分页 尽量使用物理分页 并非逻辑分页 join列尽量使用索引 order by 使用索引 等等 总之是为了避免全表扫描做出的各种操作 大家应该发现索引的使用还是非常频繁的 那么具体某个sql使用了哪些索引 以及进行了什么处理操作 EXPLAIN 优化我们可以用 EXPLAIN 关键字去查看执行计划 12345678910111213141516EXPLAIN SELECT *FROM professor aWHERE NOT EXISTS ( SELECT * FROM sys_attend b WHERE a.id = b.professor_id AND b.`type` = 1 AND b.table_id = 93353728 ) AND a.polling_status = 1 AND a.status = 1 AND (a.Member_category = 1 OR a.Member_category = 3) AND (organization_category IN (4, 7) OR organization_categoryvice IN (4, 7))LIMIT 0, 2 这张表里大概有这么几个字段 id 执行顺序 可以重复 id相同则从上往下执行 id从大到小执行 select_type 搜索类型 一共有十一种 具体可以看这篇博客SQL_explain操作解释 这里就简单的介绍常见的几种 第一种也是最常见到的一种 SIMPLE 简单的select查询,查询中不包含子查询或者union; PRIMARY:查询中若包含任何复杂的子查询,最外层查询则被标记; 就是刚刚的优先级最外层则会显示PRIMARY SUBQUERY:在select或者where列表中包含了子查询; type 显示的是访问类型，一般我们优化sql就是着重优化这个 , 是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。 一般来说，得保证查询至少达到range级别，最好能达到ref。 那么怎么能达到这个级别呢 ref:非唯一性索引扫描,返回匹配某个单独值得所有行,本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,它可能会找到多个符合条件的行,所以它应该属于查找和扫描的混合体; range:只检索给定范围的行,使用一个索引来选择行,key列显示使用哪个索引,一般就是在你的where语句中出现了between,&lt;,&gt;,in等的查询；这种范围索引扫描比全表扫描要好,因为它只需要开始于索引的某一个点,结束于另一个点,不用扫描全部索引; 之前说的避免全表扫描就是为了这样 possible_keys:显示可能会被应用到这张表的索引,一个或者多个;查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用到; key:实际使用到的索引.如果为null,则没有使用索引;查询中若使用了覆盖索引,则该索引仅出现在key列表中; key_len:表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好; key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的; ref:显示索引的哪一列被使用了,如果可能的话,是一个常数,哪些列或常量别用于查找索引列上的值; rows:根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数; Extra:包含不适合在其它列中显示但十分重要的额外信息: 对于这个消息栏里展示的东西有很多 一般是你的sql违反的数据库相对应的算法,他认为你的不合理 在这里就不详细解释了 当大家出现后可以百度相对应的信息 MySQL中explain执行计划中额外信息字段(Extra)详解 那么根据这些信息我们可以查到需要优化哪些地方 说完 explain 我们可以再说说 explain extended + show warnings 在执行explain extended 之后我们在 show warnings 可以看到在数据库中我们sql的执行方式, 我们可以在这个基础上再次进行优化 我们可以看到sql的执行方式，对于分析sql还是很有帮助的。 ( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; ( 1 ) FROM [ left_table ] ( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; ( 2 ) ON &lt; join_condition &gt; ( 4 ) WHERE &lt; where_condition &gt; ( 5 ) GROUP BY &lt; group_by_list &gt; ( 6 ) WITH &lt; CUBE | RollUP &gt; ( 7 ) HAVING &lt; having_condition &gt; ( 10 ) ORDER BY &lt; order_by_list &gt; 从优先级我们可以看出为什么order by 排序在 group by 之前不生效了 之前那条sql之后后数据库warnings的执行方式是下面这样的123456789101112131415SELECT `zwkj_zhxt`.`a`.`id` AS `id`, `zwkj_zhxt`.`a`.`name` AS `name`, `zwkj_zhxt`.`a`.`sex` AS `sex`,FROM `zwkj_zhxt`.`professor` `a`WHERE ((`zwkj_zhxt`.`a`.`status` = 1) AND (`zwkj_zhxt`.`a`.`polling_status` = 1) AND (not(exists(/* select#2 */SELECT 1FROM `zwkj_zhxt`.`sys_attend` `b`WHERE ((`zwkj_zhxt`.`b`.`table_id` = 93353728) AND (`zwkj_zhxt`.`b`.`sex` = 1) AND (`zwkj_zhxt`.`a`.`id` = `zwkj_zhxt`.`b`.`professor_id`))))) AND ((`zwkj_zhxt`.`a`.`name` = 1) OR (`zwkj_zhxt`.`a`.`name` = 3)) AND ((`zwkj_zhxt`.`a`.`sex` IN (4,7)) OR (`zwkj_zhxt`.`a`.`sex` IN (4,7)))) limit 0,2 从上面还可以看出 and 的优先级 总是高于 or 但有一点需要注意的是 exteneded得到的sql并不是 最终优化执行的sql这一点可以在官方文档中得到确认Extended EXPLAIN Output Format但从优化的角度上来讲也能帮助我们. 一般企业数据库的优化 基本上是 配硬件+差不多的sql优化+分布式+分库分表+读写分离 等等 反正一系列的操作 基本满足80%的业务场景 当然我们优化个别业务需要根据实际场景来优化 如果确实说需要高级别的维护和优化 公司会有相对应的运维或者DB来做很少需要开发者担心","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"db","slug":"java/db","permalink":"http://yoursite.com/categories/java/db/"}],"tags":[{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"},{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"launchctl自动化脚本","slug":"macLaunchctl","date":"2019-04-17T16:00:00.000Z","updated":"2020-04-08T06:43:46.133Z","comments":true,"path":"2019/04/18/macLaunchctl/","link":"","permalink":"http://yoursite.com/2019/04/18/macLaunchctl/","excerpt":"","text":"启动1launchctl start con.hki.zhxtgit.plist 查找1launchctl list | grep &apos;con&apos; 加载1launchctl load -w con.hki.zhxtgit.plist 卸载1launchctl unload con.hki.zhxtgit.plist 校验语法1plutil -lint com.hki.zhxtgit.plist plist文件1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Disabled&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;con.hki.zhxtgit.plist&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Documents/shell/zhxtgit.sh&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;false/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/Documents/shell/run.log&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/Documents/shell/run.err&lt;/string&gt; &lt;key&gt;StartCalendarInterval&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Hour&lt;/key&gt; &lt;integer&gt;15&lt;/integer&gt; &lt;key&gt;Minute&lt;/key&gt; &lt;integer&gt;5&lt;/integer&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"自动化脚本","slug":"自动化脚本","permalink":"http://yoursite.com/tags/自动化脚本/"}]},{"title":"git stash 在多分支下的使用","slug":"git_stash","date":"2019-03-07T16:00:00.000Z","updated":"2020-04-28T08:49:17.381Z","comments":true,"path":"2019/03/08/git_stash/","link":"","permalink":"http://yoursite.com/2019/03/08/git_stash/","excerpt":"","text":"1. 前言stash命令叫暂存 平常开发很多情况都会遇到 开发一半的代码线上环境要紧急修复个bug这个时候我们可以把代码暂存起来 常用的有 12345678910111213gsta='git stash save'gstaa='git stash apply'gstc='git stash clear'gstd='git stash drop'gstl='git stash list'gstp='git stash pop'gsts='git stash show --text' 问题这一段时间频繁在各个分支上开发及修改bug导致用到的stash命令挺多的 最近出现一个挺让我纠结的问题就是 在各个分支下stash存放的栈是一样的所以在dev分支下和master分支下你保存的数据都是一个地方 如果你在dev 下save了stash 然后切换master分支你仍然可以apply到你刚刚在dev下保存的代码 下面我们看具体代码 2. 出现原因现在我们文件下有两个文档 123 和 abc 123master &gt; ll-rw-r--r-- 1 apple staff 21B 4 23 15:30 123.txt-rw-r--r-- 1 apple staff 66B 10 29 10:44 abc.txt 现在我们删除一个 123master &gt; rm -rf abc.txttotal 8-rw-r--r-- 1 apple staff 21B 4 23 15:30 123.txt 不提交当前代码 stash保存起来 12master &gt; git stash save \"master save\"Saved working directory and index state On master: master save 切换到生产分支 123456master &gt; git checkout prod切换到分支 'prod'prod &gt; lltotal 16-rw-r--r-- 1 apple staff 21B 4 23 15:30 123.txt-rw-r--r-- 1 apple staff 121B 4 23 16:11 abc.txt 再次修改代码 并且stash保存 123 prod &gt; vi 123.txt prod &gt; git stash save \"prod save\"Saved working directory and index state On prod: prod save 切换分支查看stash list 12345master &gt; git checkout master切换到分支 'master'master &gt; git stash liststash@&#123;0&#125;: On prod: prod savestash@&#123;1&#125;: On master: master save 这个时候显示出了两个保存栈 分别是我在master和prod上保存的代码 如果这个时候你直接git stash apply 会使用最近的一个 也就是你在prod下保存的代码而不是你master的代码 3. 优化使用Stash 有两种保存方式 一种是带消息保存和不带消息保存 上面我演示的是带消息所以能看出来我保存的是哪个分支 所以在使用satsh的时候最好带上当前保存的一个标记语 这样方便我们下次使用的时候拉取 1git stash save \"markword\"","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"Quartz cron语法规则及demo","slug":"quartzCron","date":"2018-12-28T16:00:00.000Z","updated":"2020-04-08T06:44:10.589Z","comments":true,"path":"2018/12/29/quartzCron/","link":"","permalink":"http://yoursite.com/2018/12/29/quartzCron/","excerpt":"","text":"测试在线地址 http://cron.qqe2.com/ 下面是一些demo 每天凌晨2点 0 0 2 ?和每天隔一小时 0 /1 ? 例1：每隔5秒执行一次：/5 * ? 例2：每隔5分执行一次：0 /5 ? 在26分、29分、33分执行一次：0 26,29,33 * ? 例3：每天半夜12点30分执行一次：0 30 0 ? （注意日期域为0不是24） 每天凌晨1点执行一次：0 0 1 ? 每天上午10：15执行一次： 0 15 10 ? 或 0 15 10 ? 或 0 15 10 ? * 每天中午十二点执行一次：0 0 12 ? 每天14点到14：59分，每1分钟执行一次：0 14 * ? 每天14点到14：05分，每1分钟执行一次：0 0-5 14 ? 每天14点到14：55分，每5分钟执行一次：0 0/5 14 ? 每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0/5 14,18 ? 每天18点执行一次：0 0 18 ? 每天18点、22点执行一次：0 0 18,22 ? 每天7点到23点，每整点执行一次：0 0 7-23 ? 每个整点执行一次：0 0 0/1 ? 每天凌晨2点 0 0 2 ?和每天隔一小时 0 /1 ? 例1：每隔5秒执行一次：/5 * ? 例2：每隔5分执行一次：0 /5 ? 在26分、29分、33分执行一次：0 26,29,33 * ? 例3：每天半夜12点30分执行一次：0 30 0 ? （注意日期域为0不是24） 每天凌晨1点执行一次：0 0 1 ? 每天上午10：15执行一次： 0 15 10 ? 或 0 15 10 ? 或 0 15 10 ? * 每天中午十二点执行一次：0 0 12 ? 每天14点到14：59分，每1分钟执行一次：0 14 * ? 每天14点到14：05分，每1分钟执行一次：0 0-5 14 ? 每天14点到14：55分，每5分钟执行一次：0 0/5 14 ? 每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0/5 14,18 ? 每天18点执行一次：0 0 18 ? 每天18点、22点执行一次：0 0 18,22 ? 每天7点到23点，每整点执行一次：0 0 7-23 ? 每个整点执行一次：0 0 0/1 ?","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"异步的观察者模式处理后台任务","slug":"ApplicationEvent","date":"2018-10-07T16:00:00.000Z","updated":"2020-04-28T08:57:59.122Z","comments":true,"path":"2018/10/08/ApplicationEvent/","link":"","permalink":"http://yoursite.com/2018/10/08/ApplicationEvent/","excerpt":"","text":"收到任务说要做一个后台监听文件上传接口 如果有docx文档 需要将任务放在后台进程中 将docx文档转换成pdf文档 首先文档转换不是我们今天要讲的内容 稍后我会开一章来讲 事件监听在spring boot里还是比较容易实现的 有以下几点需要注意 vo实体需要继承 ApplicationEvent 实现接口ApplicationListener里的onApplicationEvent方法 使用applicationContext的publishEvent来发布事件 最后继承AsyncUncaughtExceptionHandler添加异步报错控制 新建实体 因为我这里只用到 id 所以只需要传入id即可123456789101112131415/** * @author: ZHANG.HAO * @Description: */public class WordToPdfEvent extends ApplicationEvent &#123; Integer id; public WordToPdfEvent(Integer id) &#123; super(id); this.id = id; &#125;&#125; 这里需要写你的后台监听到事件后要做的内容 我的是转换文档123456789101112131415/** * @Author: ZHANG.HAO * @Description: */@Slf4j@Componentpublic class handleListener implements ApplicationListener&lt;WordToPdfEvent&gt; &#123; @Override public void onApplicationEvent(WordToPdfEvent wordToPdfEvent) &#123; // do something &#125;&#125; 异步发布事件 12345678910111213141516171819202122/** * @author: ZHANG.HAO * @Description: */@Slf4j@Servicepublic class AsyncService &#123; @Autowired ApplicationContext applicationContext; @Async public void executorAsyncTask(List&lt;SysFile&gt; list)&#123; list.forEach(SysFile -&gt; &#123; applicationContext.publishEvent(new WordToPdfEvent(SysFile.getId())); &#125;); &#125;&#125; 配置后台异步exception12345678910111213141516171819202122232425262728/** * 后台异步exception * @author: ZHANG.HAO * @Description: */@Slf4jpublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler &#123; @Autowired ISysLogService sysLogService; @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123; log.info(\"handleUncaughtException \"); StringJoiner sjr = new StringJoiner(\",\", \"[\", \"]\"); sjr.add(\"Exception Cause - \" + ex.getMessage()) ; sjr.add(\"Method name - \" + method.getName()) ; for (Object param : params) &#123; sjr.add(\"Parameter value - \" + param) ; &#125; sysLogService.save(new SysLog(-99,sjr.toString())); &#125;&#125; 配置异步连接池1234567891011121314151617181920212223242526/** * @author ZHANG.HAO * @Date: 2019-09-09 18:34 * @Description: */@Componentpublic class AsyncConfig implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(17); executor.setMaxPoolSize(42); executor.setQueueCapacity(11); executor.setThreadNamePrefix(\"WordToPdfExecutor-\"); executor.initialize(); return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return new MyAsyncUncaughtExceptionHandler(); &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"Lombok的应用","slug":"lombok","date":"2018-09-01T16:00:00.000Z","updated":"2020-04-08T06:43:40.041Z","comments":true,"path":"2018/09/02/lombok/","link":"","permalink":"http://yoursite.com/2018/09/02/lombok/","excerpt":"","text":"eclipse下下载jar运行jar。Java -jar lombok.jar选择要安装的路径 Clean 项目 其实一般情况下都有插件管理中心可以下载idea 下直接去plugins 里下载安装 在项目中添加 lombok123456789&lt;lombok.version&gt;1.16.20&lt;/lombok.version&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 下面是使用的基本用法 123456789101112131415161718192021222324252627282930313233343536373839• al：用在局部变量前面，相当于将变量声明为final• @NonNull：给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）• @Cleanup：自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流• @Getter/@Setter：用在属性上，再也不用自己手写setter和getter方法了，还可以指定访问范围• @ToString：用在类上，可以自动覆写toString方法，当然还可以加其他参数，例如@ToString(exclude=”id”)排除id属性，或者@ToString(callSuper=true, includeFieldNames=true)调用父类的toString方法，包含所有属性• @EqualsAndHashCode：用在类上，自动生成equals方法和hashCode方法• @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor：用在类上，自动生成无参构造和使用所有参数的构造函数以及把所有@NonNull属性作为参数的构造函数，如果指定staticName = “of”参数，同时还会生成一个返回类对象的静态工厂方法，比使用构造函数方便很多• @Data：注解在类上，相当于同时使用了@ToString、@EqualsAndHashCode、@Getter、@Setter和@RequiredArgsConstrutor这些注解，对于POJO类十分有用• @Value：用在类上，是@Data的不可变形式，相当于为属性添加final声明，只提供getter方法，而不提供setter方法• @Builder：用在类、构造器、方法上，为你提供复杂的builder APIs，让你可以像如下方式一样调用Person.builder().name(&quot;Adam Savage&quot;).city(&quot;San Francisco&quot;).job(&quot;Mythbusters&quot;).job(&quot;Unchained Reaction&quot;).build();更多说明参考Builder• @SneakyThrows：自动抛受检异常，而无需显式在方法上使用throws语句• @Synchronized：用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性$lock或$LOCK，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误• @Getter(lazy=true)：可以替代经典的Double Check Lock样板代码• @Log：根据不同的注解生成不同类型的log对象，但是实例名称都是log，有六种可选实现类 ○ @CommonsLog Creates log = org.apache.commons.logging.LogFactory.getLog(LogExample.class); ○ @Log Creates log = java.util.logging.Logger.getLogger(LogExample.class.getName()); ○ @Log4j Creates log = org.apache.log4j.Logger.getLogger(LogExample.class); ○ @Log4j2 Creates log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class); ○ @Slf4j Creates log = org.slf4j.LoggerFactory.getLogger(LogExample.class); ○ @XSlf4j Creates log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"linux开放端口","slug":"linuxPort","date":"2018-05-17T16:00:00.000Z","updated":"2020-01-03T03:35:33.048Z","comments":true,"path":"2018/05/18/linuxPort/","link":"","permalink":"http://yoursite.com/2018/05/18/linuxPort/","excerpt":"","text":"文件local1/etc/sysconfig/iptables 添加 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 5236 -j ACCEPT 生效1service iptables restart -A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 3000:5000 -j ACCEPT","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"记一次ftp并发导致的bug","slug":"threadLocal","date":"2018-04-19T16:00:00.000Z","updated":"2019-12-13T10:14:00.330Z","comments":true,"path":"2018/04/20/threadLocal/","link":"","permalink":"http://yoursite.com/2018/04/20/threadLocal/","excerpt":"","text":"ThreadLocal 适用于如下两种场景 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望被多线程共享 1234567891011121314151617181920212223242526272829 private ThreadLocal&lt;FTPClient&gt; ftpClientThreadLocal = new ThreadLocal&lt;FTPClient&gt;(); private FTPClient getFTPClient() &#123; if (ftpClientThreadLocal.get() != null &amp;&amp; ftpClientThreadLocal.get().isConnected()) &#123; return ftpClientThreadLocal.get(); &#125;else&#123; FTPClient ftpClient = new FTPClient(); //构造一个FtpClient实例 ftpClient.setControlEncoding(&quot;UTF-8&quot;);// ftpClient.completePendingCommand(); ftpClient.enterLocalPassiveMode();// ftpClient.enterLocalActiveMode(); ftpClient.setBufferSize(1024*2); loginFtp(ftpClient); try &#123; ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; ftpClientThreadLocal.set(ftpClient); return ftpClient; &#125; &#125; 1FTPClient ftpClient = getFTPClient();","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}]},{"title":"JVM 调优","slug":"jvmOptimize","date":"2018-04-07T16:00:00.000Z","updated":"2020-03-31T01:37:22.596Z","comments":true,"path":"2018/04/08/jvmOptimize/","link":"","permalink":"http://yoursite.com/2018/04/08/jvmOptimize/","excerpt":"","text":"参数查看可以打开本地jdk下的jconsole查看 可以先查看下本地的jdk环境是client 还是server可以根据java -version 查看1234apple@appletekiMacBook-Air  ~  java -versionjava version \"1.8.0_181\"Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 如果是client jar包启动还可以加上 -server 这样启动虽然会慢点 但是效率会高很多 其他的优化点 12-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC 我在这边简单说一下：-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）-Xms1024m （堆最大大小）-Xmx1024m （堆默认大小）-Xmn256m （新生代大小）-Xss256k （棧最大深度大小）-XX:SurvivorRatio=8 （新生代分区比例 8:2）-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）-XX:+PrintGCDetails （打印详细的GC日志） 知识点：JDK8之后把-XX:PermSize 和 -XX:MaxPermGen移除了，取而代之的是-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。使用本地化的内存有什么好处呢？最直接的表现就是java.lang.OutOfMemoryError: PermGen 空间问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此我们也要限制Metaspace的大小：使用-XX:MaxMetaspaceSize参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://yoursite.com/tags/jvm/"}]},{"title":"乐扣刷题2 两数相加","slug":"leetcode2","date":"2017-11-17T16:00:00.000Z","updated":"2019-11-22T03:23:48.455Z","comments":true,"path":"2017/11/18/leetcode2/","link":"","permalink":"http://yoursite.com/2017/11/18/leetcode2/","excerpt":"","text":"大概思路都在下面备注里 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode a = new ListNode(0); ListNode p = l1, q = l2,curr = a; int carry = 0; while(p != null || q != null)&#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; // 只能是0 或者 1 carry = sum / 10; //读取个位数 加入next curr.next = new ListNode(sum % 10); // 激活下一位 curr = curr.next; // 赋值两个链表 if(p != null) p = p.next; if(q != null) q = q.next; &#125; // 当最后大于1 但是while不会循环 所以需要给new一个listNode来补充 比如 11 99 110 用来最后添加这个1的 if(carry &gt; 0)&#123; curr.next = new ListNode(carry); &#125; return a.next; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"乐扣刷题3 无重复的最长字符串","slug":"leetcode3","date":"2017-11-17T16:00:00.000Z","updated":"2019-11-22T03:24:26.887Z","comments":true,"path":"2017/11/18/leetcode3/","link":"","permalink":"http://yoursite.com/2017/11/18/leetcode3/","excerpt":"","text":"//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。//// 示例 1://// 输入: “abcabcbb”//输出: 3//解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。////// 示例 2://// 输入: “bbbbb”//输出: 1//解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。////// 示例 3://// 输入: “pwwkew”//输出: 3//解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。// 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。//// Related Topics 哈希表 双指针 字符串 Sliding Window 12345678910111213141516171819202122public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; //创建map窗口,i为左区间，j为右区间，右边界移动 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int j = 0, i = 0; j &lt; n; j++) &#123; // 如果窗口中包含当前字符， if (map.containsKey(s.charAt(j))) &#123; //当找到相同的数据 i = Math.max(map.get(s.charAt(j)), i); &#125; //比对当前无重复字段长度和储存的长度，选最大值并替换 //取的[i,j]长度 +1 是因为从0开始的 ans = Math.max(ans, j - i + 1); // 将当前字符为key，下一个索引为value放入map中 // value为j+1是为了当出现重复字符时，i直接跳到上个相同字符的下一个位置，if中取值就不用+1了 map.put(s.charAt(j), j+1); &#125; return ans; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]},{"title":"门面模式和调停者模式","slug":"facade&mediator","date":"2017-01-26T16:00:00.000Z","updated":"2020-04-27T07:30:20.029Z","comments":true,"path":"2017/01/27/facade&mediator/","link":"","permalink":"http://yoursite.com/2017/01/27/facade&mediator/","excerpt":"","text":"facade mediator对外 门面模式对内 调停者模式著名的消息中间件就是这个思路案例 :1234567891011121314151617181920212223242526272829303132333435363738package facade;public class FacadePattern&#123; public static void main(String[] args)&#123; Facade f=new Facade(); f.method(); &#125;&#125;//外观角色class Facade&#123; private SubSystem01 obj1=new SubSystem01(); private SubSystem02 obj2=new SubSystem02(); private SubSystem03 obj3=new SubSystem03(); public void method()&#123; obj1.method1(); obj2.method2(); obj3.method3(); &#125;&#125;//子系统角色class SubSystem01&#123; public void method1()&#123; System.out.println(\"子系统01的method1()被调用！\"); &#125; &#125;//子系统角色class SubSystem02&#123; public void method2()&#123; System.out.println(\"子系统02的method2()被调用！\"); &#125; &#125;//子系统角色class SubSystem03&#123; public void method3()&#123; System.out.println(\"子系统03的method3()被调用！\"); &#125; &#125; 参考资料: http://c.biancheng.net/view/1369.html","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"},{"name":"java","slug":"设计模式/java","permalink":"http://yoursite.com/categories/设计模式/java/"}],"tags":[]},{"title":"benchmark测试","slug":"banchmark","date":"2016-05-31T16:00:00.000Z","updated":"2020-04-28T08:57:44.788Z","comments":true,"path":"2016/06/01/banchmark/","link":"","permalink":"http://yoursite.com/2016/06/01/banchmark/","excerpt":"","text":"benchmark测试 apache旗下的一个软件可以测试 19年 用 jmeter","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"bfg工具 清除git 历史记录","slug":"bfg","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:12:43.061Z","comments":true,"path":"2015/10/08/bfg/","link":"","permalink":"http://yoursite.com/2015/10/08/bfg/","excerpt":"","text":"下载jar包下载地址 下载好后在你的根目录下执行1java -jar bfg.jar --strip-blobs-bigger-than 100M /你的项目地址 回到你的项目目录执行 1git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive 1git push","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"maven多环境配置文件","slug":"mavenProfileSpringboot","date":"2015-10-07T16:00:00.000Z","updated":"2020-04-08T06:43:55.862Z","comments":true,"path":"2015/10/08/mavenProfileSpringboot/","link":"","permalink":"http://yoursite.com/2015/10/08/mavenProfileSpringboot/","excerpt":"","text":"123# 多环境配置文件激活属性---开发、测试、生产spring.profiles.active=@activatedProperties@ 12345678910111213141516171819202122&lt;profiles&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 本地开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认环境为开发环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; // 2019/11/22 测试不需要这个12345678910111213141516171819202122&lt;!-- 打包后的名字(test.war) --&gt; &lt;resources&gt; &lt;!-- 打包时要把mapper.xml也打进去！ --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt; &lt;excludes&gt; &lt;exclude&gt;test/*&lt;/exclude&gt; &lt;exclude&gt;dev/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/$&#123;profiles.active&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; 如果先远程部署后本地启动需要先maven install // 没有-P 选择默认的mvn clean package -Pdev -Dmaven.test.skip=true // 命令优先度高java -jar /xxx/xxx.jar –spring.profiles.active=dev yml环境下有些区别 @换成# 详细情况可以参考 SpringBoot + Maven实现多环境动态切换yml配置及配置文件拆分","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Shell 传递参数","slug":"shellArgs","date":"2015-10-07T16:00:00.000Z","updated":"2020-04-08T06:44:29.486Z","comments":true,"path":"2015/10/08/shellArgs/","link":"","permalink":"http://yoursite.com/2015/10/08/shellArgs/","excerpt":"","text":"脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 新建shell1234567#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 调用1$ ./test.sh 1 2 3","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[]},{"title":"swagger生成项目离线文档","slug":"swaggerTodoc","date":"2015-10-07T16:00:00.000Z","updated":"2019-12-13T10:13:53.829Z","comments":true,"path":"2015/10/08/swaggerTodoc/","link":"","permalink":"http://yoursite.com/2015/10/08/swaggerTodoc/","excerpt":"","text":"最近需要写项目文档来记录下把swagger转换成adoc 然后根据adoc的格式依次转换成 pdf html 首先导入 swagger包1234567891011121314151617181920&lt;!-- swagger start --&gt; &lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.5-RELEASE&lt;/version&gt; &lt;!----&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-vue-ui&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.version&#125;&lt;/version&gt; &lt;/dependency&gt; 导入转换插件 注意两个路径123456789101112131415161718192021222324252627282930313233&lt;plugin&gt; &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt; &lt;artifactId&gt;swagger2markup-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;configuration&gt; &lt;swaggerInput&gt;http://localhost:8088/zhxtotc/v2/api-docs&lt;/swaggerInput&gt;&lt;!---swagger-api-json路径--&gt; &lt;outputFile&gt;src/docs/asciidoc/generated/swagger&lt;/outputFile&gt;&lt;!---生成路径--&gt; &lt;config&gt; &lt;swagger2markup.markupLanguage&gt;ASCIIDOC&lt;/swagger2markup.markupLanguage&gt;&lt;!--生成格式--&gt; &lt;/config&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;configuration&gt; &lt;!--asciidoc文件目录--&gt; &lt;sourceDirectory&gt;src/docs/asciidoc/generated&lt;/sourceDirectory&gt; &lt;!---生成html的路径--&gt; &lt;outputDirectory&gt;docs/asciidoc/html&lt;/outputDirectory&gt; &lt;backend&gt;html&lt;/backend&gt; &lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt; &lt;attributes&gt; &lt;!--导航栏在左--&gt; &lt;toc&gt;left&lt;/toc&gt; &lt;!--显示层级数--&gt; &lt;!--&lt;toclevels&gt;3&lt;/toclevels&gt;--&gt; &lt;!--自动打数字序号--&gt; &lt;sectnums&gt;true&lt;/sectnums&gt; &lt;/attributes&gt; &lt;/configuration&gt; &lt;/plugin&gt;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://yoursite.com/tags/swagger/"}]},{"title":"局域网共享文件夹如何换用户名登陆","slug":"windows01","date":"2015-10-07T16:00:00.000Z","updated":"2020-04-08T06:45:16.134Z","comments":true,"path":"2015/10/08/windows01/","link":"","permalink":"http://yoursite.com/2015/10/08/windows01/","excerpt":"","text":"你在运行里输入 CMD在命令提示符中输入： 1net use * /delete OR 1net use * /del /y 然后它会问你是否要删除网络连接，按 Y，回车即可。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://yoursite.com/tags/共享文件夹/"},{"name":"登陆","slug":"登陆","permalink":"http://yoursite.com/tags/登陆/"}]},{"title":"hexo基本命令","slug":"hexoShell","date":"2015-05-01T16:00:00.000Z","updated":"2019-11-11T09:47:04.618Z","comments":true,"path":"2015/05/02/hexoShell/","link":"","permalink":"http://yoursite.com/2015/05/02/hexoShell/","excerpt":"","text":"本地部署验证hexo s -g 清理并生成hexo clean &amp;&amp; hexo g 远程部署hexo d","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}