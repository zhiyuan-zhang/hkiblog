{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"spring-boot-ioc 解析","slug":"springBootIOC","date":"2019-05-22T09:37:43.468Z","updated":"2019-05-26T07:40:54.035Z","comments":true,"path":"2019/05/22/springBootIOC/","link":"","permalink":"http://yoursite.com/2019/05/22/springBootIOC/","excerpt":"","text":"spring boot ioc 启动调用堆栈 1234567891011121314151617181920212223242526272829303132333435inject:177, InjectionMetadata$InjectedElement (org.springframework.beans.factory.annotation)inject:90, InjectionMetadata (org.springframework.beans.factory.annotation)postProcessProperties:321, CommonAnnotationBeanPostProcessor (org.springframework.context.annotation)populateBean:1395, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)doCreateBean:592, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)createBean:515, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)lambda$doGetBean$0:320, AbstractBeanFactory (org.springframework.beans.factory.support)getObject:-1, 2018260103 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$144)getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)doGetBean:318, AbstractBeanFactory (org.springframework.beans.factory.support)getBean:199, AbstractBeanFactory (org.springframework.beans.factory.support)resolveCandidate:277, DependencyDescriptor (org.springframework.beans.factory.config)doResolveDependency:1247, DefaultListableBeanFactory (org.springframework.beans.factory.support)resolveDependency:1167, DefaultListableBeanFactory (org.springframework.beans.factory.support)inject:593, AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement (org.springframework.beans.factory.annotation)inject:90, InjectionMetadata (org.springframework.beans.factory.annotation)postProcessProperties:374, AutowiredAnnotationBeanPostProcessor (org.springframework.beans.factory.annotation)populateBean:1395, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)doCreateBean:592, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)createBean:515, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)lambda$doGetBean$0:320, AbstractBeanFactory (org.springframework.beans.factory.support)getObject:-1, 2018260103 (org.springframework.beans.factory.support.AbstractBeanFactory$$Lambda$144)getSingleton:222, DefaultSingletonBeanRegistry (org.springframework.beans.factory.support)doGetBean:318, AbstractBeanFactory (org.springframework.beans.factory.support)getBean:199, AbstractBeanFactory (org.springframework.beans.factory.support)preInstantiateSingletons:849, DefaultListableBeanFactory (org.springframework.beans.factory.support)finishBeanFactoryInitialization:877, AbstractApplicationContext (org.springframework.context.support)refresh:549, AbstractApplicationContext (org.springframework.context.support)refresh:142, ServletWebServerApplicationContext (org.springframework.boot.web.servlet.context)refresh:775, SpringApplication (org.springframework.boot)refreshContext:397, SpringApplication (org.springframework.boot)run:316, SpringApplication (org.springframework.boot)run:1260, SpringApplication (org.springframework.boot)run:1248, SpringApplication (org.springframework.boot)main:26, ZhxtApplication (com.zwkj.zhxt) AbstractAutowireCapableBeanFactory 320123456789101112131415161718192021@Override public Object configureBean(Object existingBean, String beanName) throws BeansException &#123; markBeanAsCreated(beanName); BeanDefinition mbd = getMergedBeanDefinition(beanName); RootBeanDefinition bd = null; if (mbd instanceof RootBeanDefinition) &#123; RootBeanDefinition rbd = (RootBeanDefinition) mbd; bd = (rbd.isPrototype() ? rbd : rbd.cloneBeanDefinition()); &#125; if (bd == null) &#123; bd = new RootBeanDefinition(mbd); &#125; if (!bd.isPrototype()) &#123; bd.setScope(BeanDefinition.SCOPE_PROTOTYPE); bd.allowCaching = ClassUtils.isCacheSafe(ClassUtils.getUserClass(existingBean), getBeanClassLoader()); &#125; BeanWrapper bw = new BeanWrapperImpl(existingBean); initBeanWrapper(bw); populateBean(beanName, bd, bw); return initializeBean(beanName, existingBean, bd); &#125; AbstractAutowireCapableBeanFactory 1336 1234567891011121314151617181920212223242526272829303132333435363738394041PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs;&#125;boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);PropertyDescriptor[] filteredPds = null;if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125;&#125;","categories":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/categories/springboot/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"http://yoursite.com/tags/ioc/"}]},{"title":"博客MD模板应用","slug":"mavenProfileSpringboot","date":"2019-05-14T03:32:57.338Z","updated":"2019-05-22T09:38:56.919Z","comments":true,"path":"2019/05/14/mavenProfileSpringboot/","link":"","permalink":"http://yoursite.com/2019/05/14/mavenProfileSpringboot/","excerpt":"","text":"123# 多环境配置文件激活属性---开发、测试、生产spring.profiles.active=@activatedProperties@ 12345678910111213141516171819202122&lt;profiles&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 本地开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- 默认环境为开发环境 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 12345678910111213141516171819202122&lt;!-- 打包后的名字(test.war) --&gt; &lt;resources&gt; &lt;!-- 打包时要把mapper.xml也打进去！ --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt; &lt;excludes&gt; &lt;exclude&gt;test/*&lt;/exclude&gt; &lt;exclude&gt;dev/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/$&#123;profiles.active&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; 如果先远程部署后本地启动需要先maven install mvn clean package -Pdev -Dmaven.test.skip=true java -jar /xxx/xxx.jar –spring.profiles.active=dev","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"浅谈 sql的几个小技巧","slug":"sqlOptimize","date":"2019-05-13T12:20:20.544Z","updated":"2019-05-26T07:31:21.690Z","comments":true,"path":"2019/05/13/sqlOptimize/","link":"","permalink":"http://yoursite.com/2019/05/13/sqlOptimize/","excerpt":"","text":"本质上来讲 sql优化和数据库优化是两种优化 数据库优化包含的种类较多 软件优化,硬件优化理论上 单个mysql数据库能够支撑的是每秒2000的并发 极限是5000 当然本次不说数据库优化 先说sql优化 sql优化一般是针对单个业务进行优化 比如秒杀 系统的订单查询 (当然一般用redis 这里只是举个例子) 或者说是对excel表格进行分析插入数据库 等等各种各样的业务 当然一个简单的sql 可能就是这样的 1SELECT * from test WHERE ASSIGNEE_ = 'user10' 但在实际业务环境中可能并不是这样 实际会复杂很多 以及很多条件 当我们在处理这样的sql的时候 应该怎么去优化以及从哪里入手 索引我们大家都是知道索引可以很好的帮我们来提高效率 但是具体怎么用 以及针对某个业务或者单条sql怎么优化 再说这些之前我们先针对SQL进行一些常识性优化 比如 基本优化WHERE 子句里面的列尽量被索引 尽量避免使用 “SELECT *” 如果用到分页 尽量使用物理分页 并非逻辑分页 join列尽量使用索引 order by 使用索引 等等 总之是为了避免全表扫描做出的各种操作 大家应该发现索引的使用还是非常频繁的 那么具体某个sql使用了哪些索引 以及进行了什么处理操作 EXPLAIN 优化我们可以用 EXPLAIN 关键字去查看执行计划 12345678910111213141516EXPLAIN SELECT *FROM professor aWHERE NOT EXISTS ( SELECT * FROM sys_attend b WHERE a.id = b.professor_id AND b.`type` = 1 AND b.table_id = 93353728 ) AND a.polling_status = 1 AND a.status = 1 AND (a.Member_category = 1 OR a.Member_category = 3) AND (organization_category IN (4, 7) OR organization_categoryvice IN (4, 7))LIMIT 0, 2 id select_type table type possible_keys key key_len ref rows Extra 1 “PRIMARY” “a” “index_merge” “professor_level_index,professor_levelvice_index” “professor_level_index,professor_levelvice_index” “2,2” NULL 28 “Using sort_union(professor_level_index,professor_levelvice_index); Using where” 2 “DEPENDENT SUBQUERY” “b” “ALL” NULL NULL NULL NULL 85 “Using where” 这张表里大概有这么几个字段 id 执行顺序 可以重复 id相同则从上往下执行 id从大到小执行 select_type 搜索类型 一共有十一种 具体可以看这篇博客SQL_explain操作解释 这里就简单的介绍常见的几种 第一种也是最常见到的一种 SIMPLE 简单的select查询,查询中不包含子查询或者union; PRIMARY:查询中若包含任何复杂的子查询,最外层查询则被标记; 就是刚刚的优先级最外层则会显示PRIMARY SUBQUERY:在select或者where列表中包含了子查询; type 显示的是访问类型，一般我们优化sql就是着重优化这个 , 是较为重要的一个指标，结果值从好到坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。 一般来说，得保证查询至少达到range级别，最好能达到ref。 那么怎么能达到这个级别呢 ref:非唯一性索引扫描,返回匹配某个单独值得所有行,本质上也是一种索引访问,它返回所有匹配某个单独值的行,然而,它可能会找到多个符合条件的行,所以它应该属于查找和扫描的混合体; range:只检索给定范围的行,使用一个索引来选择行,key列显示使用哪个索引,一般就是在你的where语句中出现了between,&lt;,&gt;,in等的查询；这种范围索引扫描比全表扫描要好,因为它只需要开始于索引的某一个点,结束于另一个点,不用扫描全部索引; 之前说的避免全表扫描就是为了这样 possible_keys:显示可能会被应用到这张表的索引,一个或者多个;查询涉及到的字段上若存在索引,则该索引将被列出,但不一定被查询实际使用到; key:实际使用到的索引.如果为null,则没有使用索引;查询中若使用了覆盖索引,则该索引仅出现在key列表中; key_len:表示索引中使用的字节数,可通过该列计算查询中使用的索引的长度,在不损失精确性的情况下,长度越短越好; key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即key_len是根据表定义计算而得,不是通过表内检索出的; ref:显示索引的哪一列被使用了,如果可能的话,是一个常数,哪些列或常量别用于查找索引列上的值; rows:根据表统计信息及索引选用情况,大致估算出找到所需的记录所需要读取的行数; Extra:包含不适合在其它列中显示但十分重要的额外信息: 对于这个消息栏里展示的东西有很多 一般是你的sql违反的数据库相对应的算法,他认为你的不合理 在这里就不详细解释了 当大家出现后可以百度相对应的信息 MySQL中explain执行计划中额外信息字段(Extra)详解 那么根据这些信息我们可以查到需要优化哪些地方 说完 explain 我们可以再说说 explain extended + show warnings 在执行explain extended 之后我们在 show warnings 可以看到在数据库中我们sql的执行方式, 我们可以在这个基础上再次进行优化 我们可以看到sql的执行方式，对于分析sql还是很有帮助的。 ( 8 ) SELECT ( 9 ) DISTINCT ( 11 ) &lt; Top Num &gt; &lt; select list &gt; ( 1 ) FROM [ left_table ] ( 3 ) &lt; join_type &gt; JOIN &lt; right_table &gt; ( 2 ) ON &lt; join_condition &gt; ( 4 ) WHERE &lt; where_condition &gt; ( 5 ) GROUP BY &lt; group_by_list &gt; ( 6 ) WITH &lt; CUBE | RollUP &gt; ( 7 ) HAVING &lt; having_condition &gt; ( 10 ) ORDER BY &lt; order_by_list &gt; 从优先级我们可以看出为什么order by 排序在 group by 之前不生效了 之前那条sql之后后数据库warnings的执行方式是下面这样的123456789101112131415SELECT `zwkj_zhxt`.`a`.`id` AS `id`, `zwkj_zhxt`.`a`.`name` AS `name`, `zwkj_zhxt`.`a`.`sex` AS `sex`,FROM `zwkj_zhxt`.`professor` `a`WHERE ((`zwkj_zhxt`.`a`.`status` = 1) AND (`zwkj_zhxt`.`a`.`polling_status` = 1) AND (not(exists(/* select#2 */SELECT 1FROM `zwkj_zhxt`.`sys_attend` `b`WHERE ((`zwkj_zhxt`.`b`.`table_id` = 93353728) AND (`zwkj_zhxt`.`b`.`sex` = 1) AND (`zwkj_zhxt`.`a`.`id` = `zwkj_zhxt`.`b`.`professor_id`))))) AND ((`zwkj_zhxt`.`a`.`name` = 1) OR (`zwkj_zhxt`.`a`.`name` = 3)) AND ((`zwkj_zhxt`.`a`.`sex` IN (4,7)) OR (`zwkj_zhxt`.`a`.`sex` IN (4,7)))) limit 0,2 从上面还可以看出 and 的优先级 总是高于 or 但有一点需要注意的是 exteneded得到的sql并不是 最终优化执行的sql这一点可以在官方文档中得到确认Extended EXPLAIN Output Format 一般企业数据库的优化 基本上是 配硬件+差不多的sql优化+分布式+分库分表+读写分离 等等 反正一系列的操作 基本满足80%的业务场景 当然我们优化个别业务需要根据实际场景来优化 如果确实说需要高级别的维护和优化 公司会有相对应的运维或者DB来做不需要开发者担心","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"db","slug":"db","permalink":"http://yoursite.com/tags/db/"}]},{"title":"博客MD模板应用","slug":"tamplate","date":"2019-05-13T11:34:29.290Z","updated":"2019-05-14T02:34:05.408Z","comments":true,"path":"2019/05/13/tamplate/","link":"","permalink":"http://yoursite.com/2019/05/13/tamplate/","excerpt":"","text":"\\literal asterisks\\\\ 转义 *literal asterisks* MD语法 加粗 **加粗** 比较粗 MD语法 斜体 *斜体* 本来就是斜的 MD语法 列表1. 2. 3. ni shuo ni shi shui ? ni bushi shuo ni me ? wo xi huan de shi ni ! MD语法 列表 -XXX -XXX -XXX wo bu shi yi ge haoren na ni shi shen me ? wo shi dog MD语法 分割线 *** 代表一条分割线 MD语法 A标签 [A标签显示的名称](链接地址) baidu MD语法 图片 ![ 图片说明 ](图片地址) MD语法 编写代码 三个 ` 123def test() print('asd')test() MD语法 表格 id select_type table 1 “SIMPLE” “professor” 2 “SIMPLE” “professor” 3 “SIMPLE” “professor” MD语法 标题 一个#号是一级标题 依此类推 一级标题二级标题三级标题四级标题五级标题六级标题","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"局域网共享文件夹如何换用户名登陆","slug":"windows01","date":"2019-05-05T04:36:17.053Z","updated":"2019-05-07T09:55:03.834Z","comments":true,"path":"2019/05/05/windows01/","link":"","permalink":"http://yoursite.com/2019/05/05/windows01/","excerpt":"","text":"你在运行里输入CMD在命令提示符中输入：1net use * /delete OR1net use * /del /y 然后它会问你是否要删除网络连接，按Y，回车即可。","categories":[{"name":"windwos","slug":"windwos","permalink":"http://yoursite.com/categories/windwos/"}],"tags":[{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://yoursite.com/tags/共享文件夹/"},{"name":"登陆","slug":"登陆","permalink":"http://yoursite.com/tags/登陆/"}]}]}