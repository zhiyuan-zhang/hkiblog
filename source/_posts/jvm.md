---
title: 浅谈jvm
date: 2017/4/8
categories:
  - java
comments: true
abbrlink: 49197
img:
---

jvm运行时数据分析

在区域中一般分为五块


运行时数据区域
1. 计数器
	通过改变这个计数器的值来获取下一条需要执行的字节码,包括判断
	循环,跳转,异常处理
	
2. 方法区(method Area)
	
	该区域用来存放我们生成的各种对象信息
	
	
3. 虚拟机栈(VM stack)
	每个类 都会在执行的时候创建一个栈帧(javap -c -s xxx.class)来存放关于这个类的所有信息.
	包括方法内的局部变量,以及各种操作帧数, 动态链接(各种引用)及方法的出口返回值等等。每个方法的调用到结束意味着虚拟机的栈桢的入栈到出栈,
	
4. 堆(heap) 
	在遇到new指令后 我们会根据相对应的内存引用来找如果有就引用 没有的话就执行类加载 Java 类加载过程那一套东西
	
5. 本地方法栈(native mathod stack)
	存放本地原生调用方法和虚拟机栈一样只不过内容是原生计算机内的C方法native是与C++联合开发的时候用的 所以一般开发不会用到




前面在堆中说了类引用会检查是否已经加载过当前需要的类 

如果没有加载则会去加载 那么类的加载过程就是下面要说的


当程序用到某个类但这个类还没有加载到内存中,jvm会通过加载,连接,初始化来对这个类进行初始化

1. 加载

jvm通过类的全类名来获取字节流 (也就是.class文件) 然后根据字节流创建class对象  创建完成后写入到内存中,然后放在运行时区域的方法区内(method Area)  然后在堆(heap)中创建出对应的Class对象


2. 链接

分为三部分 

验证语法  满足jvm虚拟机规范 

准备阶段  为类的静态static 分配内存 设置默认值

解析阶段  将符号引用替换为内存引用(直接引用)

3. 初始化

将static修饰的方法或者变量进行初始化,如果有父级引用优先加载父类 


那么这个类的加载机制又是什么 它是通过什么来加载的

采用的双亲委派机制

当加载某个类的时候先去询问父类节点是否可以加载 

这样既避免了重复加载也防止了注入还提高了效率

