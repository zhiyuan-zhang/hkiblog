<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-30T08:06:55.860Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志配置文档说明</title>
    <link href="http://yoursite.com/2020/11/30/logProperties/"/>
    <id>http://yoursite.com/2020/11/30/logProperties/</id>
    <published>2020-11-29T16:00:00.000Z</published>
    <updated>2020-11-30T08:06:55.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h1><h2 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置日志文件输出目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>/opt/data/log/hunavi<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志输出文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_NAME"</span>&gt;</span>info.log<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- info日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pattern_layout"</span>&gt;</span></span><br><span class="line">            %d&#123;yyyy-MM-dd HH:mm:ss.SSS/zzz&#125; %-5p [TMS] [%X&#123;hostIp&#125;] [%X&#123;taskId&#125;] [%X&#123;taskRecordId&#125;]  [%X&#123;point&#125;]   [%c, %L] %m%n</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 业务日志格式化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"biz_pattern_layout"</span>&gt;</span></span><br><span class="line">            %d&#123;yyyy-MM-dd HH:mm:ss.SSS/zzz&#125; %-5p [TMS] [%X&#123;hostIp&#125;] [%X&#123;taskId&#125;] [%X&#123;taskRecordId&#125;]   [%c,  %L] %m%n</span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-08-18 18:08:56  Biz  [TMS] [32.112.31.21]  [] []  &#123;"biz":true, "module":"xxx","functionPoint":"xxx" , "objectType":"task" , "objectId": "task_xxx", "output":&#123; "msg": "下载注册任务", "code": "00000"  &#125; &#125;</span><br></pre></td></tr></table></figure><h1 id="MDC配置说明"><a href="#MDC配置说明" class="headerlink" title="MDC配置说明"></a>MDC配置说明</h1><p>在日志文档中需要输出<strong>taskId</strong> 和<strong>taskCode</strong> 这里是利用了 log中的MDC 为“Mapped Diagnostic Context”（映射诊断上下文）功能实现 下面简述下具体实现逻辑</p><p>MDC类基本原理其实非常简单，其内部持有一个InheritableThreadLocal实例，用于保存context数据，MDC提供了put/get/clear等几个核心接口，用于操作ThreadLocal中的数据；ThreadLocal中的K-V，可以在logback.xml中声明，最终将会打印在日志中</p><p>简单描述就是 在代码中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MDC.put(<span class="string">"taskId"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>那么在logback.xml中，即可在layout中通过声明”%X{taskId}”来打印此信息。</p><h1 id="多环境配置说明"><a href="#多环境配置说明" class="headerlink" title="多环境配置说明"></a>多环境配置说明</h1><p> 将不同级别的日志文件输出到不同的文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"ManageBiz"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">fileName</span>=<span class="string">"$&#123;LOG_HOME&#125;/ManageBiz.log"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">filePattern</span>=<span class="string">"$&#123;LOG_HOME&#125;/ManageBiz.%d&#123;yyyy-MM-dd&#125;_%i.log"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"FATAL"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;biz_pattern_layout&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"100 MB"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>RollingRandomAccessFile基本属性</strong></p><p>  name：Appender名称</p><p>  fileName：日志存储路径</p><p>  filePattern：历史日志封存路径。其中%d{yyyyMMddHH}表示了封存历史日志的时间单位（目前单位为小时，yyyy表示年，MM表示月，dd表示天，HH表示小时，mm表示分钟，ss表示秒，SS表示毫秒）。注意后缀，log4j2自动识别zip等后缀，表示历史日志需要压缩。</p><p><strong>ThresholdFilter</strong></p><p>ThresholdFilter：配置的日志过滤<br>               如果要输出的日志级别在当前级别及以上，则为match，否则走mismatch<br>               ACCEPT： 执行日志输出；<br>               DENY： 不执行日志输出，结束过滤；<br>               NEUTRAL： 不执行日志输出，执行下一个过滤器</p><p> 日志级别说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</span><br></pre></td></tr></table></figure><p><strong>PatternLayout</strong></p><p>格式化输出日志的规则定义</p><p><strong>pattern详解</strong></p><p>%d 时间</p><p>%X 参数</p><p>%F 文件名</p><p>%l 输出完整位置</p><p>%L 错误行号</p><p>%m 错误信息</p><p>具体详细配置请看</p><p><a href="https://blog.csdn.net/yu870646595/article/details/88743033" target="_blank" rel="noopener">https://blog.csdn.net/yu870646595/article/details/88743033</a></p><p><a href="https://blog.csdn.net/iteye_19607/article/details/82677252" target="_blank" rel="noopener">https://blog.csdn.net/iteye_19607/article/details/82677252</a></p><p><strong>Policies</strong></p><p><code>Policy</code>是用来控制日志文件何时(When)进行滚动的；</p><p>每天记录一个日志 </p><p>TimeBasedTriggeringPolicy</p><p>按照大小区分日志记录</p><p>SizeBasedTriggeringPolicy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置文件说明&quot;&gt;&lt;a href=&quot;#配置文件说明&quot; class=&quot;headerlink&quot; title=&quot;配置文件说明&quot;&gt;&lt;/a&gt;配置文件说明&lt;/h1&gt;&lt;h2 id=&quot;log4j2&quot;&gt;&lt;a href=&quot;#log4j2&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="log" scheme="http://yoursite.com/categories/java/log/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/11/18/%E6%99%BA%E8%83%BD%E4%BD%93%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2020/11/18/智能体代码模板/</id>
    <published>2020-11-18T09:28:30.884Z</published>
    <updated>2020-11-19T05:30:54.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有就操作-没有就下一步"><a href="#有就操作-没有就下一步" class="headerlink" title="有就操作 没有就下一步"></a>有就操作 没有就下一步</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WorkFlow supFlow = condFlow()</span><br><span class="line">  .execute(ExistsWork.of(<span class="string">""</span>,<span class="string">"Something went wrong."</span>,<span class="number">10f</span>))</span><br><span class="line">  .when(WorkReportPredicate.COMPLETED)</span><br><span class="line">  .then(seqFlow().execute(SaveWork.ofFail(ai,ac,<span class="string">""</span>))</span><br><span class="line">        .then(BIZLogWork.of(<span class="string">"twitter平台注册失败"</span>))</span><br><span class="line">        .then(LogWork.ofFail(ai,ac,<span class="string">"发送的手机号或者IP被污染"</span>))</span><br><span class="line">        .build())</span><br><span class="line">  .otherwise(PageTransitionWork.of(<span class="string">"TW_signin_unlock_phone_postsend"</span>, <span class="string">"Enter your phone number"</span>, <span class="string">"confirmation code"</span>))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h1 id="检测是否存在-不存在就退出"><a href="#检测是否存在-不存在就退出" class="headerlink" title="检测是否存在 不存在就退出"></a>检测是否存在 不存在就退出</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.then(LogWork.of(ai, ac, <span class="string">"3.TW注册: 信息输入成功"</span>))</span><br><span class="line">                                .then(condFlow()</span><br><span class="line">                                        .execute(ExistsWork.of(<span class="string">"TW_signup_mainExceeded_Exists"</span>,  <span class="string">"Please try again later"</span>, <span class="number">1</span>.f))</span><br><span class="line">                                        .then(seqFlow().execute(SaveWork.ofFail(ai,ac,<span class="string">""</span>))</span><br><span class="line">                                                .then(BIZLogWork.of(<span class="string">"twitter平台注册失败"</span>))</span><br><span class="line">                                                .then(LogWork.ofFail(ai,ac,ai.getPlatform()+<span class="string">"--gmail 邮箱被污染"</span>))</span><br><span class="line">                                                .build())</span><br><span class="line">                                        .otherwise(NoOpWork.INST)</span><br><span class="line">                                        .build())</span><br></pre></td></tr></table></figure><h1 id="点击两次-不成功就失败"><a href="#点击两次-不成功就失败" class="headerlink" title="点击两次 不成功就失败"></a>点击两次 不成功就失败</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkFlow doubleCheck = seqFlow()</span><br><span class="line">               .then(ExistsWork.of(<span class="string">"TW_signup_useemail_Click"</span>, <span class="string">"Use email instead"</span>).then(ClickWork.of(<span class="string">"TW_signup_useemail_Click"</span>, <span class="string">"Use email instead"</span>)))</span><br><span class="line">               .then(ExistsWork.of(<span class="string">"TW_signup_useemail_Click"</span>, <span class="string">"Use email instead"</span>).then(seqFlow()</span><br><span class="line">                       .execute(SaveWork.ofFail(ai,ac,<span class="string">""</span>))</span><br><span class="line">                       .then(BIZLogWork.of(<span class="string">"twitter平台注册失败"</span>))</span><br><span class="line">                       .then(LogWork.ofFail(ai,ac,ai.getPlatform()+<span class="string">"--点击问题,查看\"Use email instead\"语句是否存在"</span>))</span><br><span class="line">                       .build()))</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;有就操作-没有就下一步&quot;&gt;&lt;a href=&quot;#有就操作-没有就下一步&quot; class=&quot;headerlink&quot; title=&quot;有就操作 没有就下一步&quot;&gt;&lt;/a&gt;有就操作 没有就下一步&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/09/24/%E7%BB%BC%E5%90%88%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2020/09/24/综合业务系统项目设计及思想/</id>
    <published>2020-09-24T02:51:52.095Z</published>
    <updated>2020-11-03T09:19:20.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="综合业务系统项目框架设计"><a href="#综合业务系统项目框架设计" class="headerlink" title="综合业务系统项目框架设计"></a>综合业务系统项目框架设计</h1><h2 id="综合业务系统项目简介"><a href="#综合业务系统项目简介" class="headerlink" title="综合业务系统项目简介"></a>综合业务系统项目简介</h2><p>整个项目分为<strong>OTC管理系统</strong>和<strong>流程系统</strong>两大块</p><p>流程项目负责OTC的会员，可转债，挂牌等申请流程走向</p><p>otc项目管理涉及业务逻辑</p><p>重要程度从高到低</p><ol><li><strong>流程系统</strong></li><li><strong>可转债模块</strong></li><li><strong>挂牌模块</strong></li><li><strong>会员申请模块</strong></li><li><strong>角色权限模块</strong></li><li>专家模块</li><li>上会模块</li><li>短信模块</li><li>pageoffice模块</li><li>文件生成模块</li><li>打包下载</li><li>订单模块</li><li>文件模块</li><li>通知模块</li><li>审核记录模块</li></ol><h2 id="整体框架设计"><a href="#整体框架设计" class="headerlink" title="整体框架设计"></a>整体框架设计</h2><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>项目的技术栈，包括语言、框架和中间件等；</p><p>核心框架：Spring framework、SpringBoot</p><p>持久层框架：MyBatis Plus</p><p>日志管理：SLF4J、LogBack</p><p>分布式缓存：Redis</p><p>模块化管理：Maven</p><p>数据库连接池：Alibaba Druid</p><p>任务调度：quartz</p><p>客户端验证：JQuery Validation</p><p>配置中心: nacos</p><p>流程组件: flowable</p><p>其他插件: Pageoffice ,POI, Itext, lombok</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>参考 swagger地址</p><p> <a href="http://192.168.0.60:8086/zhxtotc/swagger-ui.html#/" target="_blank" rel="noopener">http://192.168.0.60:8086/zhxtotc/swagger-ui.html#/</a></p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="mysql设计"><a href="#mysql设计" class="headerlink" title="mysql设计"></a>mysql设计</h3><p>参考 : 数据字典V1.0.xlsx</p><h3 id="redis设计"><a href="#redis设计" class="headerlink" title="redis设计"></a>redis设计</h3><p>// 忽略</p><h3 id="技术选型："><a href="#技术选型：" class="headerlink" title="技术选型："></a>技术选型：</h3><p>项目的技术栈，包括语言、框架和中间件等；</p><p>分布式缓存：Redis</p><p>模块化管理：Maven</p><p>数据库连接池：Alibaba Druid</p><p>核心框架：Spring framework、SpringBoot</p><p>持久层框架：MyBatis Plus</p><p>任务调度：quartz</p><p>日志管理：SLF4J 1.7、LogBack</p><p>客户端验证：JQuery Validation</p><p>配置中心: nacos</p><p>流程组件: flowable</p><p>接口查看: swagger-ui</p><p>其他插件: Pageoffice,POI,Itext</p><h3 id="本地构建："><a href="#本地构建：" class="headerlink" title="本地构建："></a>本地构建：</h3><p>本地开发需要启动的步骤 ；</p><ul><li>配置数据库 默认需要vpn连接60的服务器<br>— 配置dev.properties下本地自定义配置及pageOffice配置</li><li>配置office 模板文件</li><li>配置本地的nacos配置文件</li><li>打mavenjar包为 dev</li></ul><p>打包生产环境需要的命令</p><p>mvn clean install -Dmaven.test.skip=true  -Pprod</p><h3 id="环境信息："><a href="#环境信息：" class="headerlink" title="环境信息："></a>环境信息：</h3><p>各个环境的访问方式，数据库连接等；</p><p>各种环境的配置请看<br>application.properties</p><p>本地开发如果需要连接服务器的数据库需要登陆vpn</p><p>—– nacos 版本—–<br>上线nacos后需要登录nacos服务器来更改配置<br>nacos服务器在 bootstrap.properties 处配置</p><h3 id="模块讲解："><a href="#模块讲解：" class="headerlink" title="模块讲解："></a>模块讲解：</h3><p>核心的领域概念</p><p>用户管理：用户分为三种 承销商(会员)，OTC管理员，专家是该系统的基础模块。</p><p>角色管理：承销商分三种角色 专业会员 挂牌业务会员 可转债会员，OTC管理员分两种 后台管理员 审批管理员</p><p>权限管理：每个承销商可以设置其下属协同人员，公司风控，公司领导.  OTC管理员后台可以设置审批人的部门及角色</p><p>部门管理：配置系统组织机构，可随意调整上下级。</p><p>日志管理：系统正常操作日志记录和查询；系统异常信息日志记录和查询。</p><p>连接池监视：监视当期系统数据库连接池状态，可进行分析SQL。</p><p>可转债会员领域</p><p>可转债领域</p><p>挂牌领域</p><p>专家领域</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型:"></a>数据模型:</h3><p>数据库中的表目前分为几大类</p><ul><li>以IPD 开头的 可转债模块</li></ul><ul><li>以 EIM 开头的 挂牌模块</li></ul><ul><li>以sys 开头的 系统模块</li></ul><p>剩下的就是其他模块<br>其他模块又分为两大类</p><ul><li>专家模块</li></ul><ul><li><p>会员领域</p><ul><li>权限管理这一块的问题<br>之前有两套方案</li></ul><ol><li><p>用户表sys_user关联岗位表job</p></li><li><p>用户关联角色表 sys_user_role <strong>( 现在采用的是这一套方案 )</strong></p></li></ol></li></ul><p>现在只讲 在用的这一套权限管理方案</p><p>sys_user</p><p>  sys_user_role<br>     角色名称 role_id<br>     流程id flow_id</p><p>  sys_role_permission<br>     role_id 角色id<br>     permission_id 权限id</p><p>  sys_permission<br>     获取具体权限</p><p>后续要添加按钮级别的控制 需要上shiro 数据库预留字段 (menu_code)</p><h1 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h1><p>项目结构分为两大部分</p><ol><li>流程部分<br> 流程在zwkj.zhxt.flow包中</li></ol><ol start="2"><li>业务部分<br>beans  枚举常量存放位置<br>common 框架基本配置, AOP, 异常存放点<br>config 项目配置包<br>controller 项目接口层<br>filter 入口拦截器, token校验, 幂等性校验, 接口防刷等等<br>flow 流程包<br>model 项目所有实体类<br>mvc 项目接口数据<br>utils  工具类<br>zhxtApplication.java  入口类 </li></ol><h1 id="部署架构："><a href="#部署架构：" class="headerlink" title="部署架构："></a>部署架构：</h1><p>部署架构图；</p><h1 id="外部依赖："><a href="#外部依赖：" class="headerlink" title="外部依赖："></a>外部依赖：</h1><p>项目运行时所依赖的外部集成方，</p><p>可转债模块  依赖  会员模块 和 专家模块</p><p>挂牌模块 依赖 会员模块 和 专家模块</p><h1 id="FAQ："><a href="#FAQ：" class="headerlink" title="FAQ："></a>FAQ：</h1><p>开发过程中常见问题的解答。</p><ul><li><p><strong>流程系统查看当前单子的审批人</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME_,ASSIGNEE_ <span class="keyword">FROM</span> ACT_RU_TASK <span class="keyword">WHERE</span> PROC_INST_ID_ <span class="keyword">IN</span> (<span class="keyword">SELECT</span> PROC_INST_ID_ <span class="keyword">FROM</span> <span class="string">`flowable`</span>.<span class="string">`ACT_RU_EXECUTION`</span> <span class="keyword">WHERE</span> <span class="string">`BUSINESS_KEY_`</span> <span class="keyword">LIKE</span> <span class="string">'%34045882%'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结束任务</span></span><br><span class="line">curl -X POST "http://localhost:8088/zhxtotc/app/reject?taskId=02899e8e-f8af-11ea-b6f3-24418c3ebe54" -H "accept: */*"</span><br></pre></td></tr></table></figure></li><li><p><strong>统计专家会议</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> EIM_base_info.enterprise_name , sys_attend.invite_name,sys_attend.meeting_time,sys_attend.meeting_local,sys_attend.batch <span class="keyword">from</span> EIM_base_info, sys_attend <span class="keyword">where</span> EIM_base_info.id = sys_attend.table_id  <span class="keyword">AND</span> sys_attend.status <span class="keyword">not</span>  <span class="keyword">in</span> (<span class="string">'3'</span>,<span class="string">'2'</span>) <span class="keyword">AND</span> sys_attend.deleted = <span class="number">1</span> <span class="keyword">and</span> batch <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>   <span class="keyword">and</span> meeting_time <span class="keyword">is</span>  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">and</span>  meeting_time &gt;= <span class="string">'2020-03-01 00:00'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> EIM_base_info.enterprise_name</span><br></pre></td></tr></table></figure></li><li><p><strong>当前流程任务不存在的问题</strong><br>确定提交日期 -&gt; 查看日志记录 -&gt; 查看提交单子的接口</p></li><li><p><strong>启动异常 .properties 报错</strong><br>目前不存在这个问题 ,如果出现 是因为maven多环境配置的问题<br>解决方案: 一般情况下重新选择环境打包就可以 </p></li><li><p><strong>下载生成的文件 或者打包文件出现问题</strong><br>一般是模板有问题或者模板未更新<br>解决方案: 找到相对于的模板去更新下<br>如果更新后模板还是有问题需要去ExcelManage 199 行找出确定哪个字段有问题 在对应解决</p></li><li><p><strong>CheckException: 系统错误</strong><br>这个是flow流程系统报错后综合系统自定义的错误提示 当出现这个问题后需要查看所调用的 流程系统 接口以及数据是否正常 是否出现为空或者重复的问题<br>解决方案: 通用错误一般是流程发生报错</p></li><li><p><strong>获取excel 数据报错, 已经赋值为空 !</strong><br>这是一个error告警 是因为你的数据不存在 我们默认赋值成空 但也有一些例外 只需注意就好</p></li></ul><ul><li><strong>任务审批或者提交单据之后发现单子还在本人这里</strong><br>这个问题比较复杂 需要确定很多地方</li></ul><ol><li><strong>查看单子状态是否有变更</strong><br>如果单子状态改变 -&gt; 查看流程是否走到下一个角色那里 <pre><code>-&gt; 走到下一个角色 说明流程没问题 ,单子状态有问题 解决方案: 查询但是为什么没有更改 找对应的接口-&gt; 没有走到下一个角色  说明流程没有被调用 解决方案: 查看日志 是否报错 查看接口参数返回是否正常</code></pre></li></ol><p>如果单子状态没有改变 -&gt; 说明流程报错或者在调用流程之前报错事物回滚导致状态没有变化<br>                  -&gt; 如果流程报错查看日志 及审批人是否是登录角色</p><ul><li><strong>提交多次失败</strong><br>有两种情况</li></ul><ol><li><p>提交流程成功了但是后续逻辑判断出错导致异常 这个问题有一个明显的状况就是下个角色可以看到多条单据任务<br> -&gt; 当出现多条单据的时候 查看是否是状态没有改变导致的可以反复提交同一条单据<br> 解决方案: 更改单子状态</p></li><li><p>在调用流程之前或者调用流程出错导致的提价失败<br>-&gt; 查看业务逻辑错误<br>解决方案: 查询是否是因为更改流程导致</p></li></ol><ul><li><p><strong>提交报错后流程无法流转的问题</strong><br>这个bug是因为当前登录的提交人的手机号和流程当中的审批人手机号不是一个手机号 导致在提交的时候无法查询到当前登录人的任务<br>解决方案: 将当前登录人的手机号设置为流程的ASSIGNEE_ 审批人 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME_,ASSIGNEE_ <span class="keyword">FROM</span> ACT_RU_TASK <span class="keyword">WHERE</span> PROC_INST_ID_ <span class="keyword">IN</span> (<span class="keyword">SELECT</span> PROC_INST_ID_ <span class="keyword">FROM</span> <span class="string">`flowable`</span>.<span class="string">`ACT_RU_EXECUTION`</span> <span class="keyword">WHERE</span> <span class="string">`BUSINESS_KEY_`</span> <span class="keyword">LIKE</span> <span class="string">'%34045882%'</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>完成任务后任务已经流转但是审批人名下还有一个单子(重复单子)</strong><br>这个bug是犹豫多次提交引起的 查询提交是否是多次提交 或者是一次提交ID重复的问题<br>解决方案 调用swagger上的reject接口 taskid参数传 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID_ <span class="keyword">FROM</span> ACT_RU_TASK <span class="keyword">WHERE</span> PROC_INST_ID_ <span class="keyword">IN</span> (<span class="keyword">SELECT</span> PROC_INST_ID_ <span class="keyword">FROM</span> <span class="string">`flowable`</span>.<span class="string">`ACT_RU_EXECUTION`</span> <span class="keyword">WHERE</span> <span class="string">`BUSINESS_KEY_`</span> <span class="keyword">LIKE</span> <span class="string">'%34045882%'</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>其他问题直接看日志错误代码及代码行号定位</strong></p></li></ul><ul><li><strong>常规单子状态和流程任务不对等的情况下的问题排查及解决方案</strong></li></ul><p><strong>举例:  我们用一个生产环境出现问题的单子来举例说明</strong></p><p>问题:<br>单据状态本来应该是17,但是数据库显示当前单据的状态是16.8,<br><strong>16.8</strong>的角色下没有查询到任务.</p><p>解决思路:<br>查询该单据数据库的update_time<br>SQL update time<br>2020-06-09 13:24:32</p><p>去log日志中查询具体调用记录</p><p>生产环境日志查询发现在<br>117870 2020-06-09 12:24:29.556<br>状态 修改过 变为 <strong>17</strong></p><p>由以上两个时间节点可以得出 在12:24:29–13:24:32 期间肯定出现了问题,并且将状态变更为16.8</p><p>所以我们查询将状态变更为16.8的日志记录 关键字 “status”:”16.8”<br>121296 行  2020-06-09 13:24:32<br>发现状态变为status16.8</p><p>第一次16.8为双审的第一个人的记录”状态”没问题<br>接下来往后翻日志发现<br>121720行 2020-06-09 13:28:01.544<br>认领了任务</p><p>然后在日志记录的时候发现该角色短时间内操作了两次审批记录</p><p>第一次在 121255 行<br>第二次在 121244 行</p><p>这是请求参数 将状态由16.8变更为17<br>2020-06-09 13:24:32.359 |-INFO  [qtp593103894-12503] [1968791269_381917] com.zwkj.zhxt.common.ControllerAOP [74] -| 5. 请求参数 : {“admissionId”:21551591,”evalute”:”       已生成挂牌协议”,”ids”:[],”key”:”1”,”name”:”张志波”,”questionList”:[],”sort”:500,”status”:”17”,”sysUser”:”zhangzhibo”,”taskId”:”cb4c0394-a947-11ea-a656-0050568f1897”,       “verifyRole”:”user0”,”words”:”生成挂牌协议”}</p><p>然后去流程业务日志中查询发现请求只收到一次<br>flow<br>37773</p><p>了解综合系统处理流程发现问题出在<br><strong>判断redis缓存中是否有该单据的审核记录 如果有一个人审核则状态变为17 “并且删除当前缓存”  如果没有则16.8</strong></p><p>因为第二个人操作了两次 所以<br>第一次发现有人审批 审核状态变为17 “并且删除当前缓存” 任务完成<br>第二次发现缓存没有人审批过然后状态变为16.8 </p><p>所以会出现 单子是16.8 任务在17这个角色下.</p><p>(判断redis缓存逻辑已经在 Git HASH 8d0a1ad6 处删除)</p><ul><li>查看专家替换选不出来的问题</li></ul><p>主要sql</p><p>替换 table_id , organization_category,organization_categoryvice 这三个内容可以查看替换时专家的筛选人员<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">   professor a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">      <span class="keyword">SELECT</span></span><br><span class="line">         *</span><br><span class="line">      <span class="keyword">FROM</span></span><br><span class="line">         sys_attend b</span><br><span class="line">      <span class="keyword">WHERE</span></span><br><span class="line">         a.id = b.professor_id</span><br><span class="line">         <span class="keyword">AND</span> b. <span class="string">`type`</span> = <span class="number">1</span></span><br><span class="line">         <span class="keyword">AND</span> b.table_id = <span class="number">35932873</span></span><br><span class="line">         <span class="keyword">AND</span> b.deleted = <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">AND</span> a.polling_status <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">AND</span> a.status = <span class="number">1</span></span><br><span class="line">      <span class="keyword">AND</span>(a.Member_category = <span class="number">1</span></span><br><span class="line">         <span class="keyword">OR</span> a.Member_category = <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">and</span>(organization_category <span class="keyword">in</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line">         <span class="keyword">OR</span> organization_categoryvice <span class="keyword">in</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>)</span><br><span class="line">         <span class="keyword">AND</span>(organization_category <span class="keyword">NOT</span> <span class="keyword">in</span>(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">AND</span> organization_categoryvice <span class="keyword">NOT</span> <span class="keyword">in</span>(<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">         *</span><br><span class="line">      <span class="keyword">FROM</span></span><br><span class="line">         sys_attend b</span><br><span class="line">      <span class="keyword">WHERE</span></span><br><span class="line"><span class="comment">--           a.id = b.professor_id</span></span><br><span class="line">          b. <span class="string">`type`</span> = <span class="number">1</span></span><br><span class="line">         <span class="keyword">AND</span> b.table_id = <span class="number">35932873</span></span><br><span class="line">         <span class="keyword">AND</span> b.deleted = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="下面是项目启动后需要用到的各种文件及地址"><a href="#下面是项目启动后需要用到的各种文件及地址" class="headerlink" title="下面是项目启动后需要用到的各种文件及地址"></a>下面是项目启动后需要用到的各种文件及地址</h2><h3 id="测试环境地址"><a href="#测试环境地址" class="headerlink" title="测试环境地址"></a>测试环境地址</h3><p>测试流程查看(失效): <a href="http://192.168.0.60:8085/zhxtflow/app/processDiagram?processId=" target="_blank" rel="noopener">http://192.168.0.60:8085/zhxtflow/app/processDiagram?processId=</a></p><p>测试swagger(失效): <a href="http://192.168.0.60:8085/zhxtflow/swagger-ui.html" target="_blank" rel="noopener">http://192.168.0.60:8085/zhxtflow/swagger-ui.html</a></p><p>测试流程图编辑(失效): <a href="http://192.168.0.60:8085/zhxtflow/modeler/index.html" target="_blank" rel="noopener">http://192.168.0.60:8085/zhxtflow/modeler/index.html</a></p><p>测试环境zhxt-swagger: <a href="http://192.168.0.60:8086/zhxtotc/swagger-ui.html#/" target="_blank" rel="noopener">http://192.168.0.60:8086/zhxtotc/swagger-ui.html#/</a></p><h3 id="预生产地址"><a href="#预生产地址" class="headerlink" title="预生产地址"></a>预生产地址</h3><p>预生产环境后端zhxt:  <a href="http://58.144.147.65:81/zhxtotc" target="_blank" rel="noopener">http://58.144.147.65:81/zhxtotc</a></p><p>预生产流程图 <a href="http://10.110.14.66:8085/zhxtflow/modeler/index.html#/processes" target="_blank" rel="noopener">http://10.110.14.66:8085/zhxtflow/modeler/index.html#/processes</a></p><p>// 废弃  生产流程图: <a href="http://10.110.14.71:8085/zhxtflow/swagger-ui.html" target="_blank" rel="noopener">http://10.110.14.71:8085/zhxtflow/swagger-ui.html</a></p><h3 id="生产环境地址-临时地址-后续取消"><a href="#生产环境地址-临时地址-后续取消" class="headerlink" title="生产环境地址(临时地址 后续取消)"></a>生产环境地址(临时地址 后续取消)</h3><p>生产环境流程图编辑: <a href="http://10.110.14.73:8085/zhxtflow/modeler/index.html#/processes" target="_blank" rel="noopener">http://10.110.14.73:8085/zhxtflow/modeler/index.html#/processes</a></p><p>生产环境流程图查看: <a href="http://10.110.14.73:8085/zhxtflow/app/processDiagram?processId=" target="_blank" rel="noopener">http://10.110.14.73:8085/zhxtflow/app/processDiagram?processId=</a></p><p>生产环境流程swagger: <a href="http://10.110.14.73:8085/zhxtflow/swagger-ui.html" target="_blank" rel="noopener">http://10.110.14.73:8085/zhxtflow/swagger-ui.html</a> </p><h3 id="附带其他文档说明"><a href="#附带其他文档说明" class="headerlink" title="附带其他文档说明"></a>附带其他文档说明</h3><p>查看所有流程的状态及角色以及附带后端接口的文档</p><p>流程状态梳理表V2.0.xlsx</p><p>所有角色权限配置文档</p><p>股转中心角色权限对应表.xlsx</p><p>综合业务需求说明文档</p><p>重庆股转中心综合业务系统产品需求说明书v0.6 8-13.docx</p><p>综合业务系统数据字典结构表</p><p>综合系统-数据字典V1.27.docx</p><p>截止一期项目压力测试报告</p><p>压力测试报告.docx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;综合业务系统项目框架设计&quot;&gt;&lt;a href=&quot;#综合业务系统项目框架设计&quot; class=&quot;headerlink&quot; title=&quot;综合业务系统项目框架设计&quot;&gt;&lt;/a&gt;综合业务系统项目框架设计&lt;/h1&gt;&lt;h2 id=&quot;综合业务系统项目简介&quot;&gt;&lt;a href=&quot;#综合业
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅析redis</title>
    <link href="http://yoursite.com/2020/06/19/Redis/"/>
    <id>http://yoursite.com/2020/06/19/Redis/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-09-09T01:34:33.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="官方帮助文档"><a href="#官方帮助文档" class="headerlink" title="官方帮助文档"></a>官方帮助文档</h2><p>redis.cn</p><p>中文文档</p><p> <a href="https://cloud.tencent.com/developer/section/1374167" target="_blank" rel="noopener">https://cloud.tencent.com/developer/section/1374167</a></p><p>先介绍下它的安装流程吧  以linux为例</p><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h3 id="1-先安装插件-yum-install-wget"><a href="#1-先安装插件-yum-install-wget" class="headerlink" title="1. 先安装插件 yum install wget"></a>1. 先安装插件 yum install wget</h3><h3 id="2-去github找最新的包-然后用命令下载-wget-www-redis-tar-gz"><a href="#2-去github找最新的包-然后用命令下载-wget-www-redis-tar-gz" class="headerlink" title="2. 去github找最新的包 然后用命令下载 wget  www.***redis .tar.gz"></a>2. 去github找最新的包 然后用命令下载 wget  www.***redis .tar.gz</h3><h3 id="3-之后执行解压程序-tar-xf-redis-tar-gz"><a href="#3-之后执行解压程序-tar-xf-redis-tar-gz" class="headerlink" title="3. 之后执行解压程序 tar xf    redis.tar.gz"></a>3. 之后执行解压程序 tar xf    redis.tar.gz</h3><h3 id="4-进入src目录-cd-redis-src"><a href="#4-进入src目录-cd-redis-src" class="headerlink" title="4. 进入src目录 cd redis-src"></a>4. 进入src目录 cd redis-src</h3><h3 id="5-推荐阅读下它的说明文档-README-md"><a href="#5-推荐阅读下它的说明文档-README-md" class="headerlink" title="5.  推荐阅读下它的说明文档 README.md"></a>5.  推荐阅读下它的说明文档 README.md</h3><h3 id="6-编译-make"><a href="#6-编译-make" class="headerlink" title="6. 编译 make"></a>6. 编译 make</h3><p>期间可能会报错 根据报错信息自行百度解决</p><p>我这里遇到的问题是 gcc没安装 </p><p>make yum install gcc<br>make distclean</p><h3 id="7-make"><a href="#7-make" class="headerlink" title="7. make"></a>7. make</h3><p>cd src  … 生成了可执行程序</p><h3 id="8-cd"><a href="#8-cd" class="headerlink" title="8. cd .."></a>8. cd ..</h3><h3 id="9-make-install-PREFIX-opt-xxxx-redis5"><a href="#9-make-install-PREFIX-opt-xxxx-redis5" class="headerlink" title="9. make install  PREFIX=/opt/xxxx/redis5"></a>9. make install  PREFIX=/opt/xxxx/redis5</h3><h3 id="10-vi-etc-profile"><a href="#10-vi-etc-profile" class="headerlink" title="10. vi /etc/profile"></a>10. vi /etc/profile</h3><h3 id="11-cd-utils"><a href="#11-cd-utils" class="headerlink" title="11. cd utils"></a>11. cd utils</h3><p>最后写入<br>… export REDIS_HOME =/opt/xxx/redis5<br>… export PATH=$PATH:$REDIS_HOME/bin<br>source /etc/profile</p><h3 id="12-install-server-sh"><a href="#12-install-server-sh" class="headerlink" title="12. ./install_server.sh"></a>12. ./install_server.sh</h3><ul><li>一个物理机中可以有多个redis实例. 通过port区分</li><li>可执行程序就有一份在目录, 但是内存中需要多个实例有各自的配置文件</li><li>批处理server redi_6379 start/stop/status &gt; linux /etc/init.d/***</li></ul><p>## </p><p>安装好之后 介绍下 具体使用</p><h2 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><h3 id="key-value"><a href="#key-value" class="headerlink" title="key-value"></a>key-value</h3><ul><li><p>String(byte)</p><ul><li><p>字符类型</p><ul><li><p>set k1 test  nx  其中 nx 代表 如果存在则不能插入成功, 只能用来新增</p></li><li><p>set k1 test xx 其中 xx 代表如果不存在的话就失败, 只能用来更新</p></li><li><p>append 追加</p></li><li><p>range</p><ul><li>setrange</li><li>getrange</li></ul></li><li><p>strlen</p></li><li><p>type</p><ul><li>命令是哪个分组的就是哪种类型</li></ul></li><li><p>getset</p><ul><li>更新值并且拿到老值</li></ul></li><li><p>MSETNX</p><ul><li>原子性批量操作  要么都成功 要么都失败</li></ul></li></ul></li><li><p>数值类型</p><ul><li>incr</li><li>incrby</li></ul></li><li><p>bitmap</p><ul><li><p>一个字节(bit)有8个二进制位</p><ul><li>1B=8 Bit<br>1KB＝1024B<br>1MB＝1024KB<br>1GB＝1024MB<br>1TB=1024GB</li></ul></li><li><p>SETBIT key offset value</p><ul><li>设置key 偏移量offset 的 0 或者1</li></ul></li><li><p>BITPOS key bit [start] [end]</p><ul><li><p>查找字符串中第一个设置为1或0的bit位 ,返回该位置</p><ul><li><p>bitpos k1 1 0 0 </p><ul><li>1</li></ul></li><li><p>bitpos k1 1 1 1 </p><ul><li>9</li></ul></li></ul></li></ul></li><li><p>BITCOUNT key [start end]</p><ul><li>返回是1的数量</li><li>start 和end是字节位置</li></ul></li><li><p>BITOP operation destkey key [key …]</p><ul><li><p>AND  </p><ul><li>按位与操作  全1是1  其余为0</li></ul></li><li><p>OR</p><ul><li>按位或操作  有1是1  其余为0</li></ul></li><li><p>XOR</p></li><li>NOT</li></ul></li></ul></li></ul></li><li><p>lists(双向链表)</p><ul><li><p>lpush 左添加 进入队列在链表的左边依次开始添加</p></li><li><p>lpop 左弹出</p></li><li><p>rpush 右添加 进入队列在链表的最右边依次添加</p></li><li><p>rpop 右弹出</p></li><li><p>lrange 得到固定范围内的所有值</p></li><li><p>lrem 移除几个什么类型的元素</p></li><li><p>linsert 只在找到第一个值的地方</p><ul><li>after 后面插入</li><li>before 前面插入</li></ul></li><li><p>blpop (阻塞,单播队列)</p><ul><li>拿到里面的第一个数据 拿不到则阻塞</li></ul></li></ul></li><li><p>Hashes ( 点赞,收藏,详情页)</p><ul><li>存储对象<br>name::age<br>name::sex<br>name::weight</li><li><p>hset key  field value 添加一个对象的属性值</p></li><li><p>hmset 添加一个对象的多个属性值</p></li><li><p>hmget 获取一个对象的多个属性值</p></li><li><p>hvals 获取这个对象的所有属性值</p></li><li><p>hgetall 拿到这个对象的所有key value</p></li><li><p>HINCRBYFLOAT key field increment 对指定的一个属性进行 +1 -1</p></li></ul></li><li><p>sets ( 去重)</p><ul><li><p>SADD key member [member …] 添加元素</p></li><li><p>smembers 去重查看</p></li><li><p>srem 去除某个value</p></li><li><p>sinter key…  返回  多个key 的交集</p></li><li><p>sinterstore  将交集结果 保存到指定key</p></li><li><p>sunion 去重并且打印出 并集</p></li><li><p>sdiff (差集) 前面的key 与后面的key 做差集</p></li><li><p>Srandmember key count(随机事件)</p><ul><li>count 正数 得到一个去重的结果集</li><li>count 负数 得到一个带重复的结果集</li></ul></li><li><p>spop 随机取出一个数据,并删除集合里面的该值</p></li></ul></li><li><p>sorted sets(排序)</p><ul><li><p>zadd 添加一个带数值的set</p></li><li><p>ZRANGE key start stop [WITHSCORES] 得到一个带有起始位置的排序组合 </p></li><li><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 最小值和最大值的一个区间组合</p></li><li><p>zrevrange 逆序输出</p></li><li><p>zscore   通过元素取到分值</p></li><li><p>ZRANGE key start stop [WITHSCORES] 通过元素取到排名</p></li><li><p>ZINCRBY key increment member 对指定key的分值进行加减</p></li><li><p>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</p><ul><li>获取交集和并集 权重和集合指令</li></ul></li></ul></li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="http-redis-cn-topics-pipelining-html"><a href="#http-redis-cn-topics-pipelining-html" class="headerlink" title="http://redis.cn/topics/pipelining.html"></a><a href="http://redis.cn/topics/pipelining.html" target="_blank" rel="noopener">http://redis.cn/topics/pipelining.html</a></h3><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><ul><li><p>历史数据</p><ul><li>全量数据  – 数据库</li><li>短时间内  – sorted set </li></ul></li><li><p>实时数据</p><ul><li>PUBLISH key value 发布</li><li><p>SUBSCRIBE  key  监听</p><ul><li>先监听才能收到发布的消息</li></ul></li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="mutil"><a href="#mutil" class="headerlink" title="mutil"></a>mutil</h3><ul><li>开始事务</li></ul><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><ul><li>执行 哪个先到就执行哪个事务</li></ul><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul><li>乐观锁 CAS 监控某个值是否发生了变更</li></ul><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">https://github.com/RedisBloom/RedisBloom</a><br>redis-server –loadmodule /path/to/redisbloom.so<br>黑名单拦截<br>垃圾邮箱拦截</p><p>其实大家只要记住</p><p>凡是某个值需要经过判断大量数据是否存在并且误报的影响较小的情况下可以使用</p><p>一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。会有误判就是可能存在但是不一定存在的情况,</p><h2 id="Redis使用"><a href="#Redis使用" class="headerlink" title="Redis使用"></a>Redis使用</h2><p>安装使用</p><ul><li><p>redis-cli</p><ul><li>进入redis</li><li>-p 指定端口</li><li>-d 指定DB</li><li>help 帮助文档</li></ul></li><li><p>在使用前 需要规定编码格式  因为是字节流 二进制安全, 不存在客户端解析问题, 所以需要统一加码解码</p></li><li><p>kernel内存响应时间是纳秒  如果在同一时间有十多万个并发来请求redis服务端 那么会有秒级的延迟</p><ul><li>所以内存寻址每个大约在纳秒级别响应</li></ul></li><li><p>install_server.sh</p><ul><li>创建指定端口的配置文件</li></ul></li></ul><h3 id="作为缓存使用"><a href="#作为缓存使用" class="headerlink" title="作为缓存使用"></a>作为缓存使用</h3><ul><li>maxmemory 配置内存尽量控制在1G-10G </li><li><p>设置内存满了之后的拒绝策略</p><ul><li>lfu 碰了多少次</li><li>lru 多久没碰</li></ul></li><li><p>key的有效期设置</p><ul><li><p>主动</p><ul><li>主动访问的时候发现过期删除</li></ul></li><li><p>被动</p><ul><li><p>随机抽查20个key</p></li><li><p>删除已经过期的</p></li><li><p>如果发现超过25%的key过期那么重复第一步骤</p></li></ul></li></ul></li></ul><h3 id="作为数据库使用"><a href="#作为数据库使用" class="headerlink" title="作为数据库使用"></a>作为数据库使用</h3><p>​    目前作为缓存的较多 ,作为数据库比较少 因为存在分布式情况下的数据一致性问题 以及备份问题不推荐使用redis做数据库</p><h2 id="缓存集群"><a href="#缓存集群" class="headerlink" title="缓存集群"></a>缓存集群</h2><h3 id="目前单节点的问题"><a href="#目前单节点的问题" class="headerlink" title="目前单节点的问题"></a>目前单节点的问题</h3><ul><li><p>单点故障</p><p>看集群搭建</p></li><li><p>压力有限</p><p>看集群搭建</p></li><li><p>容量有限</p><ul><li>业务节点拆分不同的redis</li><li><p>算法拆分 (sharding)</p><ul><li>hash+ 取模 (modula )</li><li><p>random</p><ul><li>消息队列 一边lpush  一边只需要去rpop</li></ul></li><li><p>kemata (一致性hash算法)</p><ul><li><ol><li>有一个首尾相连的环 在这个环上有你的物理节点</li></ol></li><li><ol start="2"><li>业务数据过来后通过hash算法最后会有一个结果落在这个环的某个位置,也就是虚拟点</li></ol></li><li><ol start="3"><li>虚拟点去找后面的物理节点然后保存到redis集群中</li></ol></li><li>优点 : 后续加节点 会分担其他节点的压力,并不会造成全局洗牌</li><li><p>缺点: 新增的节点有部分数据不能命中缓存 导致缓存击穿, 压到mysql数据库中</p><ul><li>解决方案 : 去寻找最近的两个节点的缓存数据</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="AKF"><a href="#AKF" class="headerlink" title="AKF"></a>AKF</h3><ul><li>X 轴 全量 镜像</li><li>Y 轴 业务 功能</li><li>Z轴 指定规则将指定的key放在不同的库里面</li></ul><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><ul><li><p>主节点</p><ul><li>当子节点挂在主节点后 主节点会受到一个子节点的消息</li></ul></li><li><p>子节点</p><ul><li><p>启动的时候 添加配置  </p><ul><li>redis-server ./6380.conf  –REPLICAOF  IP  port –appendonly yes</li></ul></li></ul></li><li><p>redis 默认使用的是弱一致性</p></li><li><p>主从复制配置</p><ul><li><p>replica-serve-stale-data yes</p><ul><li>是否在同步期间提供给第三方数据</li></ul></li><li><p>replica-read-only yes </p></li><li><p>repl-backiog-size 1mb</p></li></ul></li></ul><h3 id="监控-Sentinel"><a href="#监控-Sentinel" class="headerlink" title="监控(Sentinel)"></a>监控(Sentinel)</h3><ul><li><p>监控</p><ul><li>port 26379<br>sentinel monitor master1 127.0.0.1 6381 2</li><li>redis-server  ./26379.conf –sentinel</li></ul></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>​        目前纯redis 的分布式锁都不是很好实现 </p><p>​        可以结合zookeeper</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;官方帮助文档&quot;&gt;&lt;a href=&quot;#官方帮助文档&quot; class=&quot;headerlink&quot; title=&quot;官
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="redis" scheme="http://yoursite.com/categories/java/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>从JVM到调优</title>
    <link href="http://yoursite.com/2020/06/11/jvm02/"/>
    <id>http://yoursite.com/2020/06/11/jvm02/</id>
    <published>2020-06-10T16:00:00.000Z</published>
    <updated>2020-11-20T02:11:48.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><h2 id="1-虚拟机基础概念"><a href="#1-虚拟机基础概念" class="headerlink" title="1. 虚拟机基础概念"></a>1. 虚拟机基础概念</h2><h3 id="Class-File-Format"><a href="#Class-File-Format" class="headerlink" title="Class File Format"></a>Class File Format</h3><h2 id="jdk-gt-jre-gt-jvm"><a href="#jdk-gt-jre-gt-jvm" class="headerlink" title="jdk  -&gt; jre -&gt; jvm"></a>jdk  -&gt; jre -&gt; jvm</h2><p>### </p><h2 id="2-class文件结构"><a href="#2-class文件结构" class="headerlink" title="2. class文件结构"></a>2. class文件结构</h2><h2 id="3-内存加载过程-JMM"><a href="#3-内存加载过程-JMM" class="headerlink" title="3. 内存加载过程 JMM"></a>3. 内存加载过程 JMM</h2><font color="#F50A0A">3.1 Loading</font><ul><li>当class 加载到内存中 实际上生成了两块内容<br>一个是将<strong>二进制内容放到内存中</strong> 与此同时<br><font color="red"><strong>生成了一个.class对象 这个对象指向这个内容</strong></font><br>后续所有的代码都会通过这个.class对象访问二进制内容<br><strong>类只会load一次</strong></li><li><p>所以用<strong>EMUN</strong>来实现单例就是这个原理 存放在 在jvm的matespacess中</p></li><li><p>类加载器 的机制及顺序</p><ul><li>1.bootstrap</li></ul></li><li><p>最顶级的加载器 显示null</p></li><li><p>2.extension</p><ul><li>加载插件的加载器 jre/lib/ext/*.jar 下面的扩展jar包</li></ul></li><li><p>3.app</p><ul><li>加载classPath指定内容</li></ul></li><li><p>4.CustomClassLoader</p><ul><li><p>自定义ClassLoad</p><ul><li><p>可以自制类加载器</p><ul><li>代码混淆<ul><li>加密</li></ul></li></ul></li></ul></li><li><p>自定义加载器步骤</p><ul><li><ol><li>extends ClassLoader<ul><li><ol start="2"><li>overwrite findClass() -&gt; defineClass(byte[] -&gt; Class clazz)</li></ol></li><li><ol start="3"><li>加密</li></ol></li></ul></li></ol></li></ul></li></ul></li><li><p>ClassLoad 源码</p><ul><li>findInCache -&gt; parent.loadClass -&gt; findClass()</li></ul></li><li><p>jvm是按需动态加载,采用双亲委派机制</p><ul><li><p>为什么要采用双亲委派机制</p><ul><li>为了防止使用类似String.class 不经过询问直接加载,导致会执行自定义逻辑,<br>使用双亲委派后我们会直接返回已经加载过的内置.class</li></ul></li><li><p>自底向上检查该类是否已经加载 Parent方向</p></li><li>自顶下下进行查找和加载child方向</li></ul></li><li><p>关于jvm编译模式</p><ul><li>解释器- 解释语言</li><li>JIT just in Time compiler 代码编译</li><li>java采用的是混合编译模式  多次被调用的方法和多次被调用的循环 进行编译 </li><li>-Xmixed 默认混合模式</li><li>-Xint  使用解释模式 ,启动很快,执行稍慢</li><li>-Xcomp 使用纯编译模式,执行很快,启动慢</li></ul></li></ul><h3 id="3-2-Linking"><a href="#3-2-Linking" class="headerlink" title="3.2 Linking"></a><font color="#F50A0A">3.2 Linking</font></h3><ul><li><p>Verification</p><ul><li>来验证是否符合JVM语法规范  类似开头cafe babe </li></ul></li><li><p>Preparation</p><ul><li>给静态成员变量赋默认值,  <font color="red">注意是默认值不是初始化值</font></li></ul></li><li><p>Resolution</p><ul><li>将类、方法、属性等符号引用解析为直接引用</li><li>常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</li></ul></li></ul><h3 id="3-3-Initializing-ɪˈnɪʃəlaɪzɪŋ"><a href="#3-3-Initializing-ɪˈnɪʃəlaɪzɪŋ" class="headerlink" title="3.3 Initializing ɪˈnɪʃəlaɪzɪŋ"></a><font color="#F50A0A">3.3 Initializing ɪˈnɪʃəlaɪzɪŋ</font></h3><ul><li>调用类初始化代码 <clinit>，给静态成员变量赋初始值</clinit></li></ul><h2 id="4-运行时内存结构"><a href="#4-运行时内存结构" class="headerlink" title="4. 运行时内存结构"></a>4. 运行时内存结构</h2><h3 id="每个线程都有单独的区域"><a href="#每个线程都有单独的区域" class="headerlink" title="每个线程都有单独的区域"></a>每个线程都有单独的区域</h3><ul><li><font color="#6AACDE">4.1 Program Counter  程序计数器</font><ul><li>存放栈帧的下一步运行 </li><li>虚拟机里面类似这样的循环<br>while( not end ) {<br>​    取PC中的位置，找到对应位置的指令；<br>​    执行该指令；<br>​    PC ++;<br>}</li></ul></li><li><font color="#6AACDE">4.2  JVM Stack</font><ul><li><p>每个方法对应一个栈帧, 栈帧可以叠加 代表方法调用方法</p><ul><li><p>每个方法都有自己的栈帧,并且都拥有这四个属性</p><ul><li><ol><li><p>Local Variable Table</p><ul><li>局部变量表  istore_3</li><li>包括入参和方法内定义的变量</li><li>非static 里面默认包含一个this</li></ul></li></ol></li><li><ol start="2"><li><p>Operand-Stack</p><ul><li>操作数栈 一个用来执行栈操作的 压栈和出栈 </li><li>如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。</li></ul></li></ol></li><li><ol start="3"><li><p>Dynamic Linking</p><ul><li>动态链接   当一个方法里面有指向另一个类的符号引用时, 将符号引用替换为直接引用, </li></ul></li></ol></li><li><ol start="4"><li><p>return address</p><ul><li>a() -&gt; b()，方法a调用了方法b, b方法的返回值放在什么地方</li><li>b方法的返回值放在A方法的栈顶 便于赋值</li><li>return后返回的地方 </li></ul></li></ol></li></ul></li><li><p>A-&gt;B-&gt;C   栈帧也是 A上面是B  B上面是C</p></li></ul></li><li><p>指令集目前分为两种</p><ul><li><p>1 基于栈的指令集  JVM就是这样的</p><ul><li>iadd</li><li>istore_2</li><li>load</li><li>pop</li><li>mul</li><li>sub</li><li>return</li><li><p>invoke</p><ul><li><p>InvokeStatic</p><ul><li>调用静态方法使用的</li></ul></li><li><p>InvokeVirtual</p><ul><li>多数方法使用这个  自带多态</li></ul></li><li><p>InvokeInterface</p><ul><li>List list = new ArrayList<string>(); 使用</string></li></ul></li><li><p>InvokeSpecial</p><ul><li>可以直接调用的 不需要多态 </li><li>private  </li></ul></li><li><p>InvokeDynamic</p><ul><li>lambda 使用或者反射使用 </li></ul></li></ul></li></ul></li><li><ol start="2"><li><font color="red">基于寄存器的指令集  类似汇编  AX BX</font></li></ol></li></ul></li></ul></li><li><font color="#6AACDE">4.3 Native Method Stack</font><ul><li>本地方法栈为虚拟机使用到的Native方法服务</li></ul></li></ul><h3 id="共享区域"><a href="#共享区域" class="headerlink" title="共享区域"></a>共享区域</h3><ul><li><font color="#BD0CF7">4.4 Heap  堆</font><ul><li>详细内容看 下面的 堆内逻辑分区</li></ul></li><li><font color="#BD0CF7">4.5 method Area</font><ul><li>装的各种各样的 class结构</li><li><ol><li>Perm Space (&lt;1.8)<br>字符串常量位于PermSpace<br>FGC不会清理<br>大小启动的时候指定，不能变</li></ol></li><li><ol start="2"><li>Meta Space (&gt;=1.8)<br>字符串常量位于堆<br>会触发FGC清理<br>不设定的话，最大就是物理内存</li></ol></li></ul></li><li><p><font color="#BD0CF7">4.6 Direct Memory</font></p><ul><li>JVM 使用未公开的Unsafe 可以直接访问内核空间的内存 (操作系统OS管理的内存) </li><li>NIO包下ByteBuffer 提高效率, 实现zero copy</li><li><p>在jvm中只保留一个引用,</p></li><li><p>可以扩展至更大的内存空间。比如超过1TB甚至比主存还大的空间</p><ul><li>理论上能减少GC暂停时间（节约了大量的堆内内存）</li><li>它的持久化存储可以支持快速重启，同时还能够在测试环境中重现生产数据</li><li><p>堆外内存能够提升IO效率</p></li><li><p>堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。<br>如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了数据从用户内向内核态的拷贝。</p></li></ul></li></ul></li><li><font color="#BD0CF7">4.7 Run-Time Constant Pool</font><ul><li>常量池的数据</li></ul></li></ul><hr><h2 id="JMM-java-memory-model"><a href="#JMM-java-memory-model" class="headerlink" title="JMM (java memory model)"></a>JMM (java memory model)</h2><h3 id="硬件层数据一致性问题"><a href="#硬件层数据一致性问题" class="headerlink" title="硬件层数据一致性问题"></a>硬件层数据一致性问题</h3><ul><li><p>JMM 有很多协议 一般使用intel的MESI </p><ul><li>MESI 一共有四种状态来表示当前缓存的状态</li></ul></li><li><p>现代CPU的数据一致性是靠 缓存锁 + 总线锁来实现</p></li><li>读取缓存是以cache line为单位, 目前是64bytes位 一块为单位</li><li>四块为一个单位的合并写技术 WCbuffer</li><li><p>伪共享 就是  当内存发现这一块的数据中有一个发生改变就会重新读取整个块的内容 这样就会导致  即使你用不到的数据发生变动 也会导致重新加载内存的问题</p><ul><li>在多线程与高并发期间Disruptor 就采用了在游标前后加上 7个空的long类型 填充缓存块</li></ul></li></ul><h3 id="乱排序问题"><a href="#乱排序问题" class="headerlink" title="乱排序问题"></a>乱排序问题</h3><ul><li>cpu会将无关的指令并行执行 但有时候也会出现问题</li><li><p>处理乱序的规范</p><ul><li><p>硬件内存屏障 X86 cpu硬件级别的内存屏障 利用汇编指令来完成 </p><ul><li>save fence 写操作 写之前必须完成这个指令前的所有操作</li><li>load fence 读操作 读操作之前必须在这个指令前的所有操作</li><li>mfence 读写操作  这条指令前的所有读写必须完成了才能操作后续的指令</li><li>原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序</li></ul></li><li><p>JVM级别的内存屏障</p><ul><li><p>LoadLoad屏障  (读操作)</p><ul><li>语句Load1; LoadLoad; Load2，</li><li>在执行之前必须保证之前的读取数据访问完成</li></ul></li><li><p>StoreStore屏障 (写操作)</p><ul><li>语句Store1; StoreStore; Store2，</li><li>在执行之前保证1的写入操作 对其他处理器可见</li></ul></li><li><p>LoadStore屏障</p><ul><li>语句Load1; LoadStore; Store2，</li><li>在后续写入操作被刷出之前,必须保证之前的操作读取完毕</li></ul></li><li><p>StoreLoad屏障</p><ul><li>语句Store1; StoreLoad; Load2，</li><li>在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul></li></ul></li></ul></li></ul><h3 id="volatile实现细节"><a href="#volatile实现细节" class="headerlink" title="volatile实现细节"></a>volatile实现细节</h3><ul><li><p>字节码层面</p><ul><li>Access flags  = volatile</li></ul></li><li><p>JVM层面</p><ul><li>volatile内存区的读写 都加屏障</li><li>StoreStoreBarrier</li></ul></li></ul><p>volatile 写操作</p><p>StoreLoadBarrier<br>    - LoadLoadBarrier</p><p>volatile 读操作</p><p>LoadStoreBarrier</p><ul><li><p>OS/硬件层面</p><ul><li><p>windows lock 指令实现</p></li><li><p>可以用工具 hsdis 查看 </p></li></ul></li></ul><h3 id="Synchronized-实现细节"><a href="#Synchronized-实现细节" class="headerlink" title="Synchronized 实现细节"></a>Synchronized 实现细节</h3><ul><li><p>字节码层面</p><ul><li>ACC_SYNCHRONIZED<br>monitorenter monitorexit  monitorexit</li></ul></li><li><p>JVM层面的实现</p><ul><li>调用了 C C++ 指令</li></ul></li><li><p>OS/硬件层面的实现</p><ul><li>X86  Lock  cmpxchg XXX 指令 </li></ul></li></ul><hr><h2 id="5-jvm-常用命令"><a href="#5-jvm-常用命令" class="headerlink" title="5. jvm 常用命令"></a>5. jvm 常用命令</h2><h3 id="开头的-标准参数"><a href="#开头的-标准参数" class="headerlink" title="-开头的 标准参数"></a>-开头的 标准参数</h3><h3 id="X-开头的是非标准参数"><a href="#X-开头的是非标准参数" class="headerlink" title="-X 开头的是非标准参数"></a>-X 开头的是非标准参数</h3><h3 id="XX-是不建议使用的参数"><a href="#XX-是不建议使用的参数" class="headerlink" title="-XX 是不建议使用的参数"></a>-XX 是不建议使用的参数</h3><h3 id="常见垃圾回收器的组合参数设定-1-8"><a href="#常见垃圾回收器的组合参数设定-1-8" class="headerlink" title="常见垃圾回收器的组合参数设定 1.8"></a>常见垃圾回收器的组合参数设定 1.8</h3><ul><li><p>一般不会使用的</p><ul><li>-XX:+UseParNewGC = ParNew + SerialOld</li><li>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old</li></ul></li><li><p>常见的几种组合</p><ul><li>-XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old</li><li>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】</li><li>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</li><li>-XX:+UseG1GC = G1</li></ul></li><li><p>Linux下1.8版本默认的垃圾回收器到底是什么？</p><ul><li>1.8.0_181 默认 Copy MarkCompact （暂时无法确定）</li><li>1.8.0_222 默认 PS + PO</li></ul></li></ul><h3 id="GC-日志打印参数"><a href="#GC-日志打印参数" class="headerlink" title="GC 日志打印参数"></a>GC 日志打印参数</h3><ul><li>-XX:+PrintGC 输出GC日志</li><li>-XX:+PrintGCDetails 输出GC的详细日志</li><li>-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</li><li>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.log 日志文件的输出路径</li><li>-XX:+HeapDumpOnOutOfMemoryError   发生异常 自动存储</li><li>例如: java  -XX:+HeapDumpOnOutOfMemoryError   -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclog -jar zhxt-1.01-SNAPSHOT.jar</li></ul><hr><h2 id="6-GC-与调优"><a href="#6-GC-与调优" class="headerlink" title="6. GC 与调优"></a>6. <font color="red">GC 与调优</font></h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><ul><li>没有任何引用指向的一个对象或者多个对象</li></ul><h3 id="怎么查找到它"><a href="#怎么查找到它" class="headerlink" title="怎么查找到它"></a>怎么查找到它</h3><ul><li><p>Reference Count</p><ul><li>无法解决循环引用 </li></ul></li><li><p>Root Searching</p><ul><li><p>哪些可以成为根节点</p><ul><li>static references in method area 本地方法区的静态引用</li><li>class</li><li>run-time constant pool  常量池</li><li>native method stack JNI指针</li><li>JVM Stack</li></ul></li></ul></li></ul><h3 id="GC-垃圾回收算法"><a href="#GC-垃圾回收算法" class="headerlink" title="GC 垃圾回收算法"></a>GC 垃圾回收算法</h3><ul><li><p>Mark-Sweep 标记清除</p><ul><li>通过根节点找到所有在用的,然后清除掉其他没用的</li><li>优点: 存活对象多的情况下效率较高<br>缺点: 容易产生碎片,需要扫描两次</li></ul></li><li><p>Copying</p><ul><li>将内存一分为二<br>优点: 适合存活对象较少 , 只需要扫描一次, 没有碎片<br>缺点: 移动复制对象,需要调整指向引用</li></ul></li><li><p>Mark-Compact</p><ul><li>扫描两次 需要将所以在使用的块移动到一起</li><li>优点: 不会有碎片产生, 不会让内存减半<br>缺点: 需要移动对象,效率偏低,不适合存货对象较多的区域</li></ul></li></ul><h3 id="JVM-内存分代模型"><a href="#JVM-内存分代模型" class="headerlink" title="JVM 内存分代模型"></a>JVM 内存分代模型</h3><ul><li><p>逻辑物理都分代</p><ul><li>POPS, CMS , </li></ul></li><li><p>逻辑分代,物理不分代</p><ul><li>G1</li></ul></li><li><p>逻辑物理都不分代</p><ul><li>Epsilon ZGC Shenandoah</li></ul></li></ul><h3 id="堆内逻辑分区"><a href="#堆内逻辑分区" class="headerlink" title="堆内逻辑分区"></a>堆内逻辑分区</h3><ul><li><p>new / young 新生代  1</p><ul><li>eden 伊甸区 8 </li><li>survivor 1</li><li>survivor 1</li></ul></li><li><p>old tenured老年代  3 </p></li><li>Method area</li></ul><h3 id="Garbage-Collectors"><a href="#Garbage-Collectors" class="headerlink" title="Garbage Collectors"></a>Garbage Collectors</h3><ul><li>Serial</li><li>Seral Old</li><li>ParNew (Parallel New)</li><li><font color="#55ED55">CMS </font></li><li><p>老年代垃圾回收器 </p><ul><li><p>清理过程</p></li><li><p>初始标记</p><ul><li>找到根节点并且标记出来</li></ul></li><li><p>并发标记</p><ul><li>找出根节点下的所有关联节点</li></ul></li><li><p>重新标记</p><ul><li>由于并发标记并会停止线程工作 可能导致一些漏标或者错标问题,所以这个时候需要STW来重新整理下</li></ul></li><li><p>并发清理</p><ul><li>将其他的清理掉 这个时候的垃圾就浮动垃圾 等待下一次回收</li></ul></li></ul></li><li><p>缺点</p><ul><li><p>Memory Fragmentation</p><ul><li>内存碎片的问题 当有新的对象在老年代放不下的时候会产生一次较长时间的STW 然后会有Seral Old 来标记移动对象 这样会效率很慢<ul><li>解决1.  保证老年代有足够的空间 -XX:CMSSInitiatingOccupancyFraction 60%</li></ul></li></ul></li><li><p>Floating Garbage</p><ul><li>浮动垃圾过多</li></ul></li></ul></li><li><p>算法</p><ul><li><p>三色标记 + Incremental Update</p><ul><li>三色标记 是在并发标记的过程中 将标记的所有对象归结为三类 黑,白,灰,<br>黑色代表自己和子节点标记完成,<br>灰色代表自己完成子节点未标记完成,<br>白色代表自己和子节点都没标记</li><li>漏标问题<br>应为并发过程中还有线程会引用 所以会产生一个情况<br>灰色的子节点标记删除了,<br>黑色新增一个白色的子节点,<br>这样导致子节点会不扫描</li></ul></li></ul></li><li><p>Incremental Update</p><pre><code>- 增量更新,关注引用的增加,将黑色重新标记为灰色,下次就会重新扫描</code></pre></li><li><p>Parallel Scavenge</p><ul><li>copy 算法</li></ul></li><li><p>Parallel Old</p><ul><li>mark-compact 算法</li></ul></li><li><font color="#55ED55">G1  1.8成熟  1.9 默认</font></li><li><p>算法</p><ul><li><p>三色标记 + SATB</p><ul><li><p>漏标问题</p><ul><li>SATB(Snapshot at the beginning) 将所有的删除操作放在一个栈里面 保证下一次直接扫描这个栈里面的引用就可以了</li></ul></li></ul></li><li><p>将所有内存 分为 Eden, Survivor, Old , Humongous(分配大对象)</p><ul><li>传统YGC找一个对象是否存活非常麻烦 需要去遍历所有的堆空间, 这样非常消耗时间</li><li>G1 是把所有关联的内存当成一个card,存储在card table里, 然后每个card里面有一个标识 </li><li>RSet = RemenberedSet<br>记录了其他Region中的对象到本Region的引用<br>垃圾回收器只需要扫描这个RSet就能知道谁引用了</li></ul></li><li>新老年代比例 G1会根据上次YGC的时间来控制新老年代的比例 一般在5%-60% 之间<ul><li>什么时候回FGC<br>当内存分配过快的时候 回产生FGC </li></ul></li></ul></li><li><p>扩内存</p><pre><code>- 提高CPU性能- 降低MixedGC的出发阈值,让MixedGC提前发生 默认是45%</code></pre><ul><li>XX:InitiatingHeapOccupacyPercent</li></ul></li><li><p>Card table  bitmap</p></li><li><p>ZGC</p><ul><li><p>算法</p><ul><li>ColoredPointers + 写屏障</li></ul></li></ul></li><li><p>Epsilon</p><ul><li>什么都不做的垃圾回收器</li></ul></li><li><p>Shenandoah</p><ul><li>收费</li><li><p>算法</p><ul><li>ColoredPointers + 读屏障</li></ul></li></ul></li></ul><h3 id="Tunning"><a href="#Tunning" class="headerlink" title="Tunning"></a>Tunning</h3><ul><li><p>基本概念</p><ul><li><p>吞吐量 优先</p><ul><li>PS + PO 算法支撑</li><li>F=N*R/T<br>F：吞吐量；N：并发虚拟用户数；R：每个虚拟用户发出的请求数量；T：性能测试所用的时间</li></ul></li><li><p>响应时间 优先</p><ul><li>G1</li></ul></li><li><p>淘宝一年来最高并发 54W</p></li><li>12306 百万并发</li></ul></li><li><p>什么是调优</p><ul><li><ol><li>根据需求进行JVM规划和预调优</li></ol></li><li><ol start="2"><li>优化运行JVM环境</li></ol></li><li><ol start="3"><li>解决各种JVM在运行过程中的问题 OOM</li></ol></li></ul></li><li><p>调优开始步骤</p><ul><li>需要有具体业务场景</li><li>需要有压力测试报告指明调优方向,</li><li><p>了解业务场景</p><ul><li><ol><li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li></ol></li><li><ol start="2"><li>吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS]</li></ol></li></ul></li><li><p>选择回收器组合</p></li><li>计算内存需求( 经验值 1.5G 16G)</li><li>选定CPU (越高越好)</li><li>设定年代大小, 升级年龄</li><li><p>设定日志参数</p><ul><li><ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li></ol></li><li><ol start="2"><li>或者每天产生一个日志文件</li></ol></li></ul></li><li><p>观察日志情况</p></li></ul></li><li><p>调优步骤</p><ul><li>查询当前机器所有的进程<br>top  11056</li></ul></li></ul><p>或者 jps 查询当前所有java进程</p><p>查询指定进程中的所有线程执行状态<br>top -Hp 11056</p><p>查询所有的线程执行状况<br>jstack  11056</p><p>启动信息查询<br>jinfo 88768</p><p>打印堆栈信息<br>jstat -gc 88768 500</p><p>找出哪个对象占用内存最多<br>jmap -histo 88768 | head -20</p><p>导出<br>jmap -dump:format=b,file=xxx pid：<br>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）</p><ul><li><p>调优工具Arthas</p><ul><li>jvm == jinfo</li><li><p>thread</p><ul><li>thread 54 </li></ul></li></ul></li><li><p>dashboard == top</p><ul><li><p>heapdump</p></li><li><p>heapdump /tmp/dump.hprof</p><ul><li>分析文件 jhat -J -mx=512M dump.hprof</li></ul></li><li>jad</li></ul></li><li>redefine 热替换 (经测试 真实场景无法使用,只能使用无依赖的demo)</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1-对象的创建过程"><a href="#1-对象的创建过程" class="headerlink" title="1. 对象的创建过程"></a>1. 对象的创建过程</h3><ul><li><ol><li>加载到内存</li></ol></li><li><ol start="2"><li>申请对象内存 </li></ol></li><li><ol start="3"><li>成员变量赋默认值 </li></ol></li><li><ol start="4"><li><p>调用构造方法 <init></init></p><ul><li><ol><li>成员变量 顺序 赋初始值</li></ol></li><li><ol start="2"><li>执行构造方法语句</li></ol></li></ul></li></ol></li></ul><h3 id="2-内存布局"><a href="#2-内存布局" class="headerlink" title="2,内存布局"></a>2,内存布局</h3><ul><li><ol><li><p>普通对象</p><ul><li><ol><li>markword 对象头</li></ol></li><li><ol start="2"><li>ClassPointer指针 -XX:+UseConpressedClassPointers 为4个字节  不开启为8个字节</li></ol></li><li><ol start="3"><li>实例数据 -XX: +UserCompressedOops 为4个字节 不开启为8个字节</li></ol></li><li><ol start="4"><li>padding 对其 8 的倍数</li></ol></li></ul></li></ol></li><li><ol start="2"><li><p>数组对象</p><ul><li><ol><li>对象头：markword 8</li></ol></li><li><ol start="2"><li>ClassPointer指针同上</li></ol></li><li><ol start="3"><li>数组长度：4字节</li></ol></li><li><ol start="4"><li>数组数据</li></ol></li><li><ol start="5"><li>对齐 8的倍数</li></ol></li></ul></li></ol></li></ul><h3 id="3-一个空对象在内存中占用多少个字节"><a href="#3-一个空对象在内存中占用多少个字节" class="headerlink" title="3. 一个空对象在内存中占用多少个字节"></a>3. 一个空对象在内存中占用多少个字节</h3><ul><li><p>普通对象</p><ul><li>对象头markword 8个字节</li><li>指针 本来是8个字节 但是64位系统为压缩到4个字节</li><li>本来是8+4 = 12 后续padding补齐 <font color="#55ED55">一共16个字节</font></li></ul></li><li><p>数组对象</p><ul><li>比普通对象多个 数组长度 4个字节</li></ul></li></ul><h3 id="4-对象头具体包含什么"><a href="#4-对象头具体包含什么" class="headerlink" title="4. 对象头具体包含什么"></a>4. 对象头具体包含什么</h3><ul><li>4位的 分代年龄</li><li>1位的偏向锁</li><li>2位的锁标志</li><li>31位的 hash code</li></ul><h3 id="5-对象怎么定位"><a href="#5-对象怎么定位" class="headerlink" title="5. 对象怎么定位"></a>5. 对象怎么定位</h3><ul><li><p>句柄池</p><ul><li><p>通过一个间接指针来指到两个指针上</p><ul><li>其中一个指定 T.clss</li><li>另外一个指定具体内容</li></ul></li></ul></li><li><p>直接指针 (HotSpot使用)</p><ul><li>A指向内容 内容包含B.class</li></ul></li></ul><h3 id="6-对象的分配过程"><a href="#6-对象的分配过程" class="headerlink" title="6. 对象的分配过程"></a>6. 对象的分配过程</h3><ul><li><p>栈上分配</p><ul><li>线程私有小对象</li><li>*逃逸分析</li></ul></li><li><p>查看大不大 如果大的直接old</p></li><li><p>TLAB</p><ul><li>Thread Loocal Allocation Buffer</li><li>多线程的时候每个人分配占用1%的eden区域来分配对象,提高效率</li></ul></li><li><p>eden</p></li></ul><h3 id="对象何时进入老年代"><a href="#对象何时进入老年代" class="headerlink" title="对象何时进入老年代"></a>对象何时进入老年代</h3><ul><li>除了CMS是6次之外 其他的都是15</li></ul><h3 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h3><ul><li>YGC期间 当Sruvivor区内存空间不够了 空间担保直接进入老年代</li></ul><h3 id="动态年龄"><a href="#动态年龄" class="headerlink" title="动态年龄"></a>动态年龄</h3><ul><li>Survivor 的 区域大于50% , 找出年龄最大的放在老年代</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jvm&quot;&gt;&lt;a href=&quot;#jvm&quot; class=&quot;headerlink&quot; title=&quot;jvm&quot;&gt;&lt;/a&gt;jvm&lt;/h1&gt;&lt;h2 id=&quot;1-虚拟机基础概念&quot;&gt;&lt;a href=&quot;#1-虚拟机基础概念&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/categories/java/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>predixy</title>
    <link href="http://yoursite.com/2020/06/06/predixy/"/>
    <id>http://yoursite.com/2020/06/06/predixy/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-18T02:50:23.906Z</updated>
    
    <content type="html"><![CDATA[<p>predixy</p><p>去github 找最新的tar包下载到服务器 </p><p><a href="https://github.com/joyieldInc/predixy.git" target="_blank" rel="noopener">https://github.com/joyieldInc/predixy.git</a></p><p>git clone  <a href="https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz" target="_blank" rel="noopener">https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</a></p><p>解压<br>tar xf predixy-1.0.5-bin-amd64-linux.tar.gz</p><p>进入主目录<br>cd bin </p><p>配置文件<br>cd conf</p><p>vi predixy.conf </p><p>Bind 127.0.0.1:7617</p><p>找到servers<br>Include sentinel.conf</p><p>vi sentinel.conf</p><p>复制examples</p><p>在sentinels 里面配置 你之前设置好的redis-sentinel</p><ul><li>127.0.0.1:26379</li><li>127.0.0.1:26380</li><li>127.0.0.1:26381</li></ul><p>还需要配置你的主库名称</p><p>Group master1 {</p><p>}</p><p>Group master2 {</p><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;predixy&lt;/p&gt;
&lt;p&gt;去github 找最新的tar包下载到服务器 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/joyieldInc/predixy.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/other/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/other/java/linux/"/>
    
      <category term="db" scheme="http://yoursite.com/categories/other/java/linux/db/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/other/java/linux/db/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>推特redis twemproxy集群搭建</title>
    <link href="http://yoursite.com/2020/06/01/twemproxy/"/>
    <id>http://yoursite.com/2020/06/01/twemproxy/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-06-18T03:44:33.829Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍可以查看<a href="https://github.com/twitter/twemproxy.git" target="_blank" rel="noopener">https://github.com/twitter/twemproxy.git</a></p><p>推特redis twemproxy集群搭建 </p><p>twemproxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/twitter/twemproxy.git</span><br></pre></td></tr></table></figure><p>如果报错 yum update nss</p><p>进入twemproxy文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install automake libtool -y</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -fvi</span><br></pre></td></tr></table></figure><p>如果报错</p><p>更改centOS源<br><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p>yum clean all </p><ul><li>进入twemproxy文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search autoconf</span><br></pre></td></tr></table></figure><p>搜索出来的 install 下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install autoreconf268</span><br></pre></td></tr></table></figure><ul><li>autoreconf268 -fvi<br>执行完之后 多了一个 configure</li></ul><ul><li><p>执行 ./configure</p></li><li><p>执行 make</p></li></ul><p>进入scripts</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp nutcracker.init /etc/init.d/twemproxy</span><br><span class="line">cd /etc/init.d/twemproxy</span><br></pre></td></tr></table></figure><p>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x twemproxy</span><br></pre></td></tr></table></figure><p>因为该文件依赖一个yml配置文件</p><p>所以我们需要拷贝一个源码目录的这个配置文件</p><p>进入twemproxy文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp ./conf/* /etc/nutcracker/</span><br><span class="line">cd /twemproxy/nutcracker/src</span><br></pre></td></tr></table></figure><p>拷贝可执行 cp nutcracker /sur/bin</p><ul><li>修改配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd /etc/nutcracker/</span><br><span class="line"></span><br><span class="line">vi nutcracker.yml</span><br></pre></td></tr></table></figure><p>配置对应的server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">servers</span><br><span class="line">- 127.0.0.1:6379</span><br><span class="line">- 127.0.0.1:6380</span><br></pre></td></tr></table></figure><ul><li>启动刚刚配置好的 redis</li></ul><p>启动nutcracker </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nutcracker start</span><br></pre></td></tr></table></figure><p>如果你改名了的话就用改了名字的启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service twemproxy start</span><br></pre></td></tr></table></figure><p>然后去启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure><p>端口是你刚刚那个配置文件里配置的端口</p><p>这个时候你连接22121 的redis 添加的数据会落在你之前配置的yml文件的server数据库中</p><p>缺点<br>不支持 keys *<br>不支持 watch<br>不支持 multi</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单介绍可以查看&lt;a href=&quot;https://github.com/twitter/twemproxy.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/twitter/twemproxy.git&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/redis/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/redis/java/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>设计原则</title>
    <link href="http://yoursite.com/2020/04/29/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2020/04/29/设计原则/</id>
    <published>2020-04-28T16:00:00.000Z</published>
    <updated>2020-04-30T05:41:57.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>单个类不要设计的太庞大</p><p>当关联业务比较多的时候可以单独抽出来做一个manage类</p><p>Person 人相关的方法</p><p>PersonManager 与人相关的业务方法</p><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>设计紧抓这一点 “面向修改关闭,面向拓展开放”</p><p>当你发现修改一个业务需要更改很多地方或者很多代码的时候说明你的设计有问题</p><p>尽量在最少修改的情况下达到完成需求. </p><p>留下以前的代码,旧代码也有价值的.</p><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>Liscov Substitutiono Principle</p><p>所有引用父类对象的地方,必须能够透明的使用子类对象</p><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>Dependency INversion Priciple</p><p>参考 Array 对应 ArrayList ,LinkedList </p><p>就是在你需要添加新业务的时候 只需要新增一个抽象类的子类, </p><p>你只需要调用抽象类的方法就可以完成需求,无需修改现有逻辑,</p><p>面向接口编程 . 面向抽象编程.</p><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>每个接口承担自己独立的业务,不要混和完成一个功能.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h1&gt;&lt;p&gt;单个类不要设计的太庞大&lt;/p&gt;
&lt;p&gt;当关联业务比较多的时候可以单独抽出来做一个manage类&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java/"/>
    
    
  </entry>
  
  <entry>
    <title>模板方法设计模式</title>
    <link href="http://yoursite.com/2020/04/28/TemplateMathod/"/>
    <id>http://yoursite.com/2020/04/28/TemplateMathod/</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2020-05-18T06:07:58.205Z</updated>
    
    <content type="html"><![CDATA[<p>模板方法 也叫钩子函数 </p><p>就是父类把所有的应该做的方法都写出来 让子类去实现</p><p>我先定义一个模板出来 </p><p>具体的实现子类去做</p><p>定义抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        op1();</span><br><span class="line">        op2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现一个子类或多个子类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> <span class="keyword">extends</span> <span class="title">F</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"op1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"op2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F f = <span class="keyword">new</span> C1();</span><br><span class="line">f.m();</span><br></pre></td></tr></table></figure><p>在AQS里面有使用这个模式 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">         * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">            <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">   * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires the lock.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span></span><br><span class="line"><span class="comment">   * immediately, setting the lock hold count to one.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the current thread already holds the lock then the hold</span></span><br><span class="line"><span class="comment">   * count is incremented by one and the method returns immediately.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the lock is held by another thread then the</span></span><br><span class="line"><span class="comment">   * current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">   * purposes and lies dormant until the lock has been acquired,</span></span><br><span class="line"><span class="comment">   * at which time the lock hold count is set to one.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          sync.lock();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;模板方法 也叫钩子函数 &lt;/p&gt;
&lt;p&gt;就是父类把所有的应该做的方法都写出来 让子类去实现&lt;/p&gt;
&lt;p&gt;我先定义一个模板出来 &lt;/p&gt;
&lt;p&gt;具体的实现子类去做&lt;/p&gt;
&lt;p&gt;定义抽象类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java/"/>
    
    
  </entry>
  
  <entry>
    <title>工厂设计模式实际应用案例</title>
    <link href="http://yoursite.com/2020/04/24/factory/"/>
    <id>http://yoursite.com/2020/04/24/factory/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-04-24T03:17:44.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式中的工厂模式"><a href="#设计模式中的工厂模式" class="headerlink" title="设计模式中的工厂模式"></a>设计模式中的工厂模式</h1><p>  工厂模式在实际应用中也很常见 各种框架的factory也很多 </p><h2 id="先说说需求"><a href="#先说说需求" class="headerlink" title="先说说需求"></a>先说说需求</h2><p>我们这个项目有一个发送通知的需求</p><p>通知有各种各样的 举几个例子</p><p>手机验证码通知</p><p>项目审批通知</p><p>出函通知</p><p>确认函通知</p><p>会议取消通知</p><p>待处理通知</p><p>… </p><p>发送方式也有很多种</p><p>邮件通知</p><p>短信通知</p><p>微信通知</p><p>钉钉通知</p><p>…</p><p>所以在设计的时候一个合格的通知必须经过三个步骤</p><ol><li>确定发送类型</li><li>确定发送人</li><li>确定发送方式</li></ol><p>我们可以把通知类做成一个factory 专门做通知的发送</p><p>// 2020年修改</p><p>后来我觉得这么设计有点不妥</p><p>改成</p><p>factory 制作各种通知</p><p>由策略模式来负责发送短信</p><p>工厂只负责短信的生产,不负责发送</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个接口。</p><p>ProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">notice</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">choose</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><p>EIMProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EIMProfessorStrategy</span> <span class="keyword">implements</span> <span class="title">ProfessorStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略了我的筛选策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPDProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPDProfessorStrategy</span> <span class="keyword">implements</span> <span class="title">ProfessorStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//省略了我的筛选策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfessorStrategy</span> <span class="keyword">implements</span> <span class="title">ProfessorStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//省略了我的筛选策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建一个<em>工厂</em>，生成基于给定信息的实体类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回接口数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> professorStrategy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   List&lt;SysAttendsModel&gt; <span class="title">find</span><span class="params">(Integer tableId, ProfessorStrategy professorStrategy)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取对应的五个专家</span></span><br><span class="line">        List&lt;Professor&gt; five = professorStrategy.five(tableId);</span><br><span class="line"></span><br><span class="line">        List&lt;SysAttendsModel&gt; sysAttendsModels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sysAttendsModels;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>使用 <em>find</em> 来查看当它改变策略 <em>Strategy</em> 时的行为变化。</p><p>main</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单据id</span></span><br><span class="line">      <span class="keyword">int</span> tableId = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂牌算法</span></span><br><span class="line">      List&lt;SysAttendsModel&gt; list = find(tableId, <span class="keyword">new</span> EIMProfessorStrategy());</span><br><span class="line">      <span class="comment">// 可转债算法</span></span><br><span class="line">  List&lt;SysAttendsModel&gt; list2 = find(tableId, <span class="keyword">new</span> IPDProfessorStrategy());</span><br><span class="line">      <span class="comment">// 会员算法</span></span><br><span class="line">  List&lt;SysAttendsModel&gt; list2 = find(tableId, <span class="keyword">new</span> IPDProfessorStrategy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式中的工厂模式&quot;&gt;&lt;a href=&quot;#设计模式中的工厂模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式中的工厂模式&quot;&gt;&lt;/a&gt;设计模式中的工厂模式&lt;/h1&gt;&lt;p&gt;  工厂模式在实际应用中也很常见 各种框架的factory也很多 &lt;/p&gt;

      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java/"/>
    
    
  </entry>
  
  <entry>
    <title>权限设计</title>
    <link href="http://yoursite.com/2020/04/14/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/04/14/权限设计/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-22T08:58:36.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计核心"><a href="#设计核心" class="headerlink" title="设计核心"></a>设计核心</h2><p>每个登录用户拥有各自的权限,由后端返回</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>下文整个权限模式基于RBAC理论设计</p><p>后台验证角色的权限,前端根据后台返回的menuList, permissionList 来设计前端的页面Router</p><p>角色的作用其实只是用来管理分配权限的,真正的验证只验证<strong>权限</strong> </p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库主要包含五张表，分别是<br>用户表 <strong>sys_user</strong> 、<br>角色表 <strong>sys_role</strong> 、<br>用户角色表 <strong>sys_job</strong> 、<br>权限表 <strong>sys_permission</strong> 、<br>角色权限表 <strong>sys_role_permission</strong> 。</p><p>关联关系如下图所示</p><p><img src="/static/权限1.png" alt="权限1"></p><h3 id="数据库表内容及其含义"><a href="#数据库表内容及其含义" class="headerlink" title="数据库表内容及其含义"></a>数据库表内容及其含义</h3><h4 id="运营后台用户表"><a href="#运营后台用户表" class="headerlink" title="运营后台用户表"></a>运营后台用户表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`nickname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'昵称'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'角色ID'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="string">`delete_status`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'是否有效  1有效  2无效'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'管理员手机号'</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'1:流程管理用户 2：管理员或者超级管理员'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">10089</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'运营后台用户表'</span>;</span><br></pre></td></tr></table></figure><h4 id="用户的组织角色和岗位信息"><a href="#用户的组织角色和岗位信息" class="headerlink" title="用户的组织角色和岗位信息"></a>用户的组织角色和岗位信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_job`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`org_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'组织id'</span>,</span><br><span class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'表单id'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`delete_status`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'是否有效 1有效     2无效'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户id'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户关联组的角色'</span>,</span><br><span class="line">  <span class="string">`claim_type`</span> <span class="built_in">varchar</span>(<span class="number">12</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'认领类型 1：可以认领任务 2：不能认领任务'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1084</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'判断用户的组织和岗位'</span>;</span><br></pre></td></tr></table></figure><h4 id="后台角色表"><a href="#后台角色表" class="headerlink" title="后台角色表"></a>后台角色表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色类型'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名'</span>,</span><br><span class="line">  <span class="string">`flow_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'流程角色id'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`delete_status`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'是否有效  1有效  2无效'</span>,</span><br><span class="line">  <span class="string">`note`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">47</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ROW_FORMAT=<span class="keyword">COMPACT</span> <span class="keyword">COMMENT</span>=<span class="string">'后台角色表'</span>;</span><br></pre></td></tr></table></figure><h4 id="后台权限表"><a href="#后台权限表" class="headerlink" title="后台权限表"></a>后台权限表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'自定id,主要供前端展示权限列表分类排序使用.'</span>,</span><br><span class="line">  <span class="string">`menu_code`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'归属菜单,前端判断并展示菜单使用,'</span>,</span><br><span class="line">  <span class="string">`menu_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'菜单的中文释义'</span>,</span><br><span class="line">  <span class="string">`permission_code`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'权限的代码/通配符,对应代码中@RequiresPermissions 的value'</span>,</span><br><span class="line">  <span class="string">`permission_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'本权限的中文释义'</span>,</span><br><span class="line">  <span class="string">`required_permission`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'2'</span> <span class="keyword">COMMENT</span> <span class="string">'是否本菜单必选权限, 1.必选 2非必选 通常是"列表"权限是必选'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'后台权限表'</span>;</span><br></pre></td></tr></table></figure><h4 id="角色-权限关联表"><a href="#角色-权限关联表" class="headerlink" title="角色-权限关联表"></a>角色-权限关联表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_role_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色id'</span>,</span><br><span class="line">  <span class="string">`permission_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限id'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`delete_status`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'是否有效 1有效 2无效'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">20</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色-权限关联表'</span>;</span><br></pre></td></tr></table></figure><h2 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h2><h3 id="用户配置岗位信息"><a href="#用户配置岗位信息" class="headerlink" title="用户配置岗位信息"></a>用户配置岗位信息</h3><p>举例: 固收分管领导及总裁 账号是 admin11 关联的岗位job信息是1015</p><p>岗位信息包含当前系统中所有的岗位</p><p><img src="/static/image-20200414163259757.png" alt="image-20200414163259757"></p><h3 id="岗位信息关联角色"><a href="#岗位信息关联角色" class="headerlink" title="岗位信息关联角色"></a>岗位信息关联角色</h3><p>当前系统所有的角色信息</p><p>固收分管领导及总裁 流程角色id是user88 角色id是 <strong>39</strong></p><p><img src="/static/image-20200414165633387.png" alt="image-20200414165633387"></p><h3 id="给角色对应的权限"><a href="#给角色对应的权限" class="headerlink" title="给角色对应的权限"></a>给角色对应的权限</h3><p>当前角色对应权限表中的某些权限</p><p>固收分管领导及总裁的角色id是39 所以需要给role_id配置不同的权限.</p><p>下面配置了4个权限,具体权限内容可以在权限表中查看</p><p><img src="/static/image-20200414165858964.png" alt="image-20200414165858964"></p><h3 id="配置所有的权限列表"><a href="#配置所有的权限列表" class="headerlink" title="配置所有的权限列表"></a>配置所有的权限列表</h3><p>存储系统中不同粒度的权限</p><p>包含但不止</p><p><img src="/static/image-20200414162424318.png" alt="image-20200414162424318"></p><p>其中如果想要分配子权限必须拥有顶级权限</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>最后: </p><ul><li>如何一个账号对应多个第三方系统的角色</li></ul><p>有两种解决方案</p><ol><li><p>理论上来讲它也是当前系统中的一种权限,所以把它加到系统权限表中,之后配置角色的时候来添加不同的第三方角色</p></li><li><p>如果你觉得第一种比较麻烦,可以在你当前系统的角色表中添加一个第三方系统角色的ID来标识,这样有一个缺点就是无法添加多个角色,不过也有解决办法,就是新建一张表来维护与第三方的角色关系.</p></li></ol><ul><li>角色继承的问题</li></ul><p>一个user对应多个岗位</p><p>一个岗位对应一个角色</p><p>延伸</p><p>可以在用户user和岗位job两个表中间添加一个关联表</p><p>用户和岗位关联起来</p><p>岗位是初始化指定角色权限的个人岗位job </p><p>初始化的时候角色和岗位是一对一的  </p><p>后期添加操作修改权限是针对岗位来操作的</p><p>举个例子 </p><p>张三是程序员岗位的角色后来申请可以操作DB的权限</p><p> 在数据库中是<strong>张三这个岗位可以操作DB 并不是程序员这个角色可以操作DB</strong></p><p>上面这种架构系统对继承角色非常麻烦, 要么循环当前角色来继承他的权限,要么多维护一张表.或者可以读下关于RBAC3的继承逻辑.</p><p>RBAC参考文献</p><p><a href="http://csrc.nist.gov/groups/SNS/rbac/index.html" target="_blank" rel="noopener">http://csrc.nist.gov/groups/SNS/rbac/index.html</a></p><p><a href="http://csrc.nist.gov/groups/SNS/rbac/faq.html" target="_blank" rel="noopener">http://csrc.nist.gov/groups/SNS/rbac/faq.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计核心&quot;&gt;&lt;a href=&quot;#设计核心&quot; class=&quot;headerlink&quot; title=&quot;设计核心&quot;&gt;&lt;/a&gt;设计核心&lt;/h2&gt;&lt;p&gt;每个登录用户拥有各自的权限,由后端返回&lt;/p&gt;
&lt;h3 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈jvm</title>
    <link href="http://yoursite.com/2020/04/10/jvm/"/>
    <id>http://yoursite.com/2020/04/10/jvm/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2020-06-18T03:29:55.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GC的基础知识"><a href="#GC的基础知识" class="headerlink" title="GC的基础知识"></a>GC的基础知识</h3><h4 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1.什么是垃圾"></a>1.什么是垃圾</h4><p>简单来讲<strong>没有任何引用指向的一个对象或者多个对象（循环引用）就是垃圾.</strong></p><p>引用又分为强引用，软引用，弱引用，虚引用。 </p><ul><li>强引用（Strong Reference）：这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象,当内存不够的时候只会抛出OOM异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object  obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><ul><li>软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在<strong>系统内存不够用时</strong>，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference  soft = <span class="keyword">new</span> SoftReference(user);</span><br></pre></td></tr></table></figure><ul><li>弱引用（Weak Reference）：它也是用来描述非须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，<strong>无论当前内存是否足够，都会回收掉</strong>只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li></ul><ul><li>虚引用（Phantom Reference）：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的<strong>是希望能在这个对象被收集器回收时收到一个系统通知</strong>。JDK1.2之后提供了PhantomReference类来实现虚引用。</li></ul><h4 id="2-如何寻找垃圾"><a href="#2-如何寻找垃圾" class="headerlink" title="2.如何寻找垃圾"></a>2.如何寻找垃圾</h4><ol><li><p>引用计数</p><p>java没有在用这种算法,它需要单独维护一个引用计数器 目前OkHttp,netty在用故不在本章节讨论范围.</p></li><li><p>根可达算法</p></li></ol><p>所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局 部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。</p><p> 这种算法的基本思路：</p><p>（1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。</p><p>（2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。 </p><p>（3）重复（2）。</p><p>（4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。</p><p>常见的根节点(起始点)<br>（1）虚拟机栈中引用的对象（栈帧中的本地变量表）；<br>（2）方法区中的常量引用的对象；final 常量名=值;<br>（3）方法区中的类静态属性引用的对象 static；<br>（4）本地方法栈中JNI（Native方法）的引用对象。<br>（5）活跃线程。</p><p>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><p>1.如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize（）方法。当对象没有覆盖finalize（）方法，或finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</p><p>2.如果该对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize（）方法。finalize（）方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize（）方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</p><h4 id="3-常见的垃圾回收算法"><a href="#3-常见的垃圾回收算法" class="headerlink" title="3.常见的垃圾回收算法"></a>3.常见的垃圾回收算法</h4><ol><li>标记清除 - 位置不连续 产生碎片</li><li>拷贝算法 - 没有碎片，浪费空间</li><li>标记压缩 - 没有碎片，效率偏低</li></ol><h4 id="4-JVM内存分代模型（用于分代垃圾回收算法）"><a href="#4-JVM内存分代模型（用于分代垃圾回收算法）" class="headerlink" title="4.JVM内存分代模型（用于分代垃圾回收算法）"></a>4.JVM内存分代模型（用于分代垃圾回收算法）</h4><ol><li><p>新生代 + 老年代 + 永久代（1.7）/ 元数据区(1.8) Metaspace</p><ol><li>永久代 元数据 - Class</li><li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）</li><li>字符串常量 1.7 - 永久代，1.8 - 堆</li><li>MethodArea逻辑概念 - 永久代、元数据</li></ol></li><li><p>新生代 = Eden + 2个suvivor区 </p><ol><li>YGC回收之后，大多数的对象会被回收，活着的进入 s0</li><li>再次YGC，活着的对象eden + s0 -&gt; s1</li><li>再次YGC，eden + s1 -&gt; s0</li><li>年龄足够 -&gt; 老年代 （15 CMS 6）</li><li>suvivor区装不下 -&gt; 老年代</li></ol></li><li><p>老年代</p><ol><li>顽固分子</li><li>老年代满了FGC Full GC</li></ol></li><li>GC Tuning (Generation)<ol><li>尽量减少FGC</li><li>MinorGC = YGC</li><li>MajorGC = FGC</li></ol></li></ol><h4 id="5-常见的垃圾回收器"><a href="#5-常见的垃圾回收器" class="headerlink" title="5.常见的垃圾回收器"></a>5.常见的垃圾回收器</h4><ol><li>Serial 年轻代 串行回收</li><li>PS 年轻代 并行回收</li><li>ParNew 年轻代 配合CMS的并行回收</li><li>SerialOld </li><li>ParallelOld</li><li>ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms)</li><li>G1(10ms)</li><li>ZGC (1ms) PK C++</li><li>Shenandoah</li><li>Eplison</li></ol><p>1.8默认的垃圾回收：PS + ParallelOld</p><h4 id="6-JVM调优第一步，了解生产环境下的垃圾回收器组合"><a href="#6-JVM调优第一步，了解生产环境下的垃圾回收器组合" class="headerlink" title="6.JVM调优第一步，了解生产环境下的垃圾回收器组合"></a>6.JVM调优第一步，了解生产环境下的垃圾回收器组合</h4><h3 id="jvm运行时数据分析"><a href="#jvm运行时数据分析" class="headerlink" title="jvm运行时数据分析"></a>jvm运行时数据分析</h3><p>在区域中一般分为五块</p><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ol><li><p>计数器<br> 通过改变这个计数器的值来获取下一条需要执行的字节码,包括判断<br> 循环,跳转,异常处理</p><ol start="2"><li><p>方法区(method Area)</p><p> 该区域用来存放我们生成的各种对象信息</p></li></ol></li></ol><ol start="3"><li><p>虚拟机栈(VM stack)<br> 每个类 都会在执行的时候创建一个栈帧(javap -c -s xxx.class)来存放关于这个类的所有信息.<br> 包括方法内的局部变量,以及各种操作帧数, 动态链接(各种引用)及方法的出口返回值等等。每个方法的调用到结束意味着虚拟机的栈桢的入栈到出栈,</p></li><li><p>堆(heap)<br> 在遇到new指令后 我们会根据相对应的内存引用 来找如果有就引用  没有的话就执行类加载 Java 类加载过程那一套东西</p></li><li><p>本地方法栈(native mathod stack)<br> 存放本地原生调用方法和虚拟机栈一样只不过内容是原生计算机内的C方法native是与C++联合开发的时候用的 所以一般开发不会用到</p></li></ol><p>前面在堆中说了类引用会检查是否已经加载过当前需要的类 </p><p>如果没有加载则会去加载 那么类的加载过程就是下面要说的</p><p>当程序用到某个类但这个类还没有加载到内存中,jvm会通过加载,连接,初始化来对这个类进行初始化</p><ol><li>加载</li></ol><p>jvm通过类的全类名来获取字节流 (也就是.class文件) 然后根据字节流创建class对象  创建完成后写入到内存中,然后放在运行时区域的方法区内(method Area)  然后在堆(heap)中创建出对应的Class对象</p><ol start="2"><li>链接</li></ol><p>分为三部分 </p><p>验证语法  满足jvm虚拟机规范 </p><p>准备阶段  为类的静态static 分配内存 设置默认值</p><p>解析阶段  将符号引用替换为内存引用(直接引用)</p><ol start="3"><li>初始化</li></ol><p>将static修饰的方法或者变量进行初始化,如果有父级引用优先加载父类 </p><p>那么这个类的加载机制又是什么 它是通过什么来加载的</p><p>采用的双亲委派机制</p><p>当加载某个类的时候先去询问父类节点是否可以加载 </p><p>这样既避免了重复加载也防止了注入还提高了效率</p><h3 id="常见垃圾回收器组合参数设定：-1-8"><a href="#常见垃圾回收器组合参数设定：-1-8" class="headerlink" title="常见垃圾回收器组合参数设定：(1.8)"></a>常见垃圾回收器组合参数设定：(1.8)</h3><ul><li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old</p><ul><li>小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器</li></ul></li><li>-XX:+UseParNewGC = ParNew + SerialOld<ul><li>这个组合已经很少用（在某些版本中已经废弃）</li><li><a href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future" target="_blank" rel="noopener">https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future</a></li></ul></li><li>-XX:+UseConc<font color="red">(urrent)</font>MarkSweepGC = ParNew + CMS + Serial Old</li><li>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】</li><li>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</li><li>-XX:+UseG1GC = G1</li><li><p>Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC </p><ul><li>java +XX:+PrintCommandLineFlags -version</li><li>通过GC的日志来分辨</li></ul></li><li><p>Linux下1.8版本默认的垃圾回收器到底是什么？</p><ul><li>1.8.0_181 默认（看不出来）Copy MarkCompact</li><li>1.8.0_222 默认 PS + PO</li></ul></li></ul><p>  java -XX:+PrintFlagsWithComments //只有debug版本能用</p><ul><li><p>JVM的命令行参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p></li><li><p>JVM参数分类</p><blockquote><p>标准： - 开头，所有的HotSpot都支持</p><p>非标准：-X 开头，特定版本HotSpot支持特定命令</p><p>不稳定：-XX 开头，下个版本可能取消</p></blockquote><p>-XX:+PrintCommandLineFlags </p><p>-XX:+PrintFlagsFinal 最终参数值</p><p>-XX:+PrintFlagsInitial 默认参数值</p></li></ul><h3 id="PS-GC日志详解"><a href="#PS-GC日志详解" class="headerlink" title="PS GC日志详解"></a>PS GC日志详解</h3><p>每种垃圾回收器的日志格式是不同的！</p><p>PS日志格式</p><p><img src="./GC日志详解.png" alt="GC日志详解"></p><p>heap dump部分：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eden space <span class="number">5632</span>K, <span class="number">94</span>% used [<span class="number">0</span>x00000000ff980000,<span class="number">0</span>x00000000ffeb3e28,<span class="number">0</span>x00000000fff00000)</span><br><span class="line">                            后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br></pre></td></tr></table></figure><p><img src="GCHeapDump.png" alt="GCHeapDump"></p><p>total = eden + 1个survivor</p><h3 id="调优前的基础概念："><a href="#调优前的基础概念：" class="headerlink" title="调优前的基础概念："></a>调优前的基础概念：</h3><ol><li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li><li>响应时间：STW越短，响应时间越好</li></ol><p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p><p>问题：</p><p>科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）</p><p>响应时间：网站 GUI API （1.8 G1）</p><h3 id="什么是调优？"><a href="#什么是调优？" class="headerlink" title="什么是调优？"></a>什么是调优？</h3><ol><li>根据需求进行JVM规划和预调优</li><li>优化运行JVM运行环境（慢，卡顿）</li><li>解决JVM运行过程中出现的各种问题(OOM)</li></ol><h3 id="调优，从规划开始"><a href="#调优，从规划开始" class="headerlink" title="调优，从规划开始"></a>调优，从规划开始</h3><ul><li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓</p></li><li><p>无监控（压力测试，能看到结果），不调优</p></li><li><p>步骤：</p><ol><li>熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器）<ol><li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li><li>吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS]</li></ol></li><li>选择回收器组合</li><li>计算内存需求（经验值 1.5G 16G）</li><li>选定CPU（越高越好）</li><li>设定年代大小、升级年龄</li><li>设定日志参数<ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li><li>或者每天产生一个日志文件</li></ol></li><li>观察日志情况</li></ol></li></ul><p>思维导图 查看地址:</p><p><a href="https://www.processon.com/embed/5e902d83e401fd32b82a99c2" target="_blank" rel="noopener">https://www.processon.com/embed/5e902d83e401fd32b82a99c2</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">https://blogs.oracle.com/ </a><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">jonthecollector</a><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">/our-collectors</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></li><li><a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank" rel="noopener">http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a></li><li>《深入理解JVM虚拟机》</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GC的基础知识&quot;&gt;&lt;a href=&quot;#GC的基础知识&quot; class=&quot;headerlink&quot; title=&quot;GC的基础知识&quot;&gt;&lt;/a&gt;GC的基础知识&lt;/h3&gt;&lt;h4 id=&quot;1-什么是垃圾&quot;&gt;&lt;a href=&quot;#1-什么是垃圾&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>redis-bitmap</title>
    <link href="http://yoursite.com/2020/04/03/redis-bitmap/"/>
    <id>http://yoursite.com/2020/04/03/redis-bitmap/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-07T07:26:11.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-BitMap-是什么"><a href="#1-BitMap-是什么" class="headerlink" title="1. BitMap 是什么"></a>1. BitMap 是什么</h1><p>在redis中可以设置用一个bit的位置来标识某个元素的0-1状态, </p><p>具体的操作指令是  指定某个key的offset的0或者1的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure><p>计算某个key的被设置为 <code>1</code> 的比特位的数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT key [start end]</span><br></pre></td></tr></table></figure><h1 id="2-BitMap-怎么用"><a href="#2-BitMap-怎么用" class="headerlink" title="2. BitMap 怎么用"></a>2. BitMap 怎么用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置reids的bitmap位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 根据需求设置long int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">setBit</span><span class="params">(String key,<span class="keyword">int</span> offset, Boolean value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Boolean&gt;) con -&gt; con.setBit(key.getBytes(),(<span class="keyword">long</span>)offset,value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计key的所有1值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">bitCount</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;Long&gt;) con -&gt; con.bitCount(key.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-BitMap-什么时候用"><a href="#3-BitMap-什么时候用" class="headerlink" title="3. BitMap 什么时候用"></a>3. BitMap 什么时候用</h1><ul><li><h2 id="短信验证一分钟不能发送5次"><a href="#短信验证一分钟不能发送5次" class="headerlink" title="短信验证一分钟不能发送5次"></a>短信验证一分钟不能发送5次</h2></li></ul><h3 id="之前我们的做法"><a href="#之前我们的做法" class="headerlink" title="之前我们的做法"></a>之前我们的做法</h3><p>调用reids的increment方法来自增完成需求</p><h3 id="现在我们的做法"><a href="#现在我们的做法" class="headerlink" title="现在我们的做法"></a>现在我们的做法</h3><p>将当前用户当做key ,拿到当前分钟的毫秒数做offset,最后用bitcount来统计用户在当前分钟数访问次数.</p><ul><li><h2 id="记录用户当前是否在线"><a href="#记录用户当前是否在线" class="headerlink" title="记录用户当前是否在线"></a>记录用户当前是否在线</h2></li></ul><h3 id="之前我们的做法-1"><a href="#之前我们的做法-1" class="headerlink" title="之前我们的做法"></a>之前我们的做法</h3><p>我们需要在数据库字段里标志处是否离线</p><h3 id="现在我们的做法-1"><a href="#现在我们的做法-1" class="headerlink" title="现在我们的做法"></a>现在我们的做法</h3><p>找到我们需要的key, 拿用户id做offset,最后我们标记出是否在线 还可以统计当前在线总人数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-BitMap-是什么&quot;&gt;&lt;a href=&quot;#1-BitMap-是什么&quot; class=&quot;headerlink&quot; title=&quot;1. BitMap 是什么&quot;&gt;&lt;/a&gt;1. BitMap 是什么&lt;/h1&gt;&lt;p&gt;在redis中可以设置用一个bit的位置来标识某个元素的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
      <category term="redis" scheme="http://yoursite.com/categories/java/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>浅析docker</title>
    <link href="http://yoursite.com/2020/03/10/docker02/"/>
    <id>http://yoursite.com/2020/03/10/docker02/</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-11-19T06:19:57.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>Mac <a href="https://docs.docker.com/docker-for-mac/install/Windows" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/Windows</a> </p><p><a href="https://docs.docker.com/docker-for-windows/install/Ubuntu" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/Ubuntu</a> </p><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/Debian" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/Debian</a> </p><p><a href="https://docs.docker.com/install/linux/docker-ce/debian/CentOS" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/debian/CentOS</a> </p><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/Fedora" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/Fedora</a> </p><p><a href="https://docs.docker.com/install/linux/docker-ce/fedora/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/fedora/</a></p><p>其他 Linux 发行版 </p><p><a href="https://docs.docker.com/install/linux/docker-ce/binaries/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/binaries/</a></p><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a> 可以按照阿里云的步骤 操作</p><h2 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h2><p><img src="https://docs.docker.com/engine/images/architecture.svg" alt="docker"></p><p>docker pull  拉取镜像image 然后根据镜像image 产生具体的容器</p><p>我们最后操作的是容器并不是镜像image</p><p>client 指的是我们的操作命令 各种pull run 等等,<br>我们可以根据命令来操作dockerHost,<br>registry 是我们的远程仓库,或者说是dockerhub接下来就是我们的整体dockerHost</p><p>这里面包含了 整个docker组件, images CONTAINERS  </p><p>你可以把daemon当做是一个管家来管理docker组件你在client端上的所有操作都会由它来执行 </p><h2 id="容器生命周期"><a href="#容器生命周期" class="headerlink" title="容器生命周期"></a>容器生命周期</h2><p><img src="/static/image-20200512143758893.png" alt="image-20200512143758893"></p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>yum install docker</p><p>service docker start</p><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><ul><li>拉取镜像文件命令</li><li>docker pull mysql:latestdocker pull mysql:8.0.20格式是 : docker pull NAME[:TAG] TAG 默认是 latest </li></ul><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><ul><li>docker images 查看所有已经下拉到本地的镜像</li><li>docker images  | grep ‘test’</li></ul><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><ul><li>docker run tomcat</li><li>端口转发docker run -p 8000:8080 tomcat</li><li>-d 后台运行</li><li>–name  赋予容器名称</li><li>–ip 172.17.0.10 指定启动的ip地址</li></ul><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><ul><li>docker logs [容器ID]  查看一个容器的启动日志</li></ul><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><ul><li>docker ps 查看所有正在运行容器 (并不是镜像)</li><li>-a 查看所有容器</li></ul><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><ul><li>将一个已经在运行的容器停止 docker stop [容器ID]</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><ul><li>与stop不同的是 kill 会将这个容器删除 stop是将这个容器停止 后续还可以继续start使用</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul><li>使用前容器必须在stop状态下docker rm [容器id] </li><li>无需容器在stop状态强制删除 -fdocker rm -f [容器ID]</li><li>docker rm $(docker ps -a -q)  删除所有容器</li><li>强制删除镜像imagesdocker rmi -f [容器ID]</li><li>注意点：1. 删除前需要保证容器是停止的  stop2. 需要注意删除镜像和容器的命令不一样。 docker rmi ID  ,其中 容器(rm)  和 镜像(rmi)3. 顺序需要先删除容器</li></ul><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><ul><li>docker exec -it [id] /bin/bash   进入一个已经存在的容器</li></ul><h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><ul><li>docker inspect [容器ID] 查看容器的详细信息</li></ul><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><ul><li>docker network ls 列出当前存在的网络连接</li><li>docker network create  my_net 创建一个网桥 类似于网关</li><li>-d 设置创建的网络驱动</li></ul><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><ul><li>docker build -t  机构/镜像名&lt;版本&gt; Dockerfile目录</li></ul><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><ul><li>docker -h </li><li>docker run -h</li></ul><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="构建docker-build-t-机构-镜像名-lt-版本-gt-Dockerfile目录"><a href="#构建docker-build-t-机构-镜像名-lt-版本-gt-Dockerfile目录" class="headerlink" title="构建docker build -t  机构/镜像名&lt;版本&gt; Dockerfile目录"></a>构建docker build -t  机构/镜像名&lt;版本&gt; Dockerfile目录</h3><h3 id="FROM-基准镜像-基于哪一个来构建的image"><a href="#FROM-基准镜像-基于哪一个来构建的image" class="headerlink" title="FROM 基准镜像 基于哪一个来构建的image"></a>FROM 基准镜像 基于哪一个来构建的image</h3><ul><li>FROM centos</li><li>FROM scratch 不依赖任何镜像</li><li>FROM mysql:8.0.20</li></ul><h3 id="说明信息"><a href="#说明信息" class="headerlink" title="说明信息"></a>说明信息</h3><ul><li>MAINTAINER 当前镜像由谁来维护</li><li>LABEL version=”V1.0”</li><li>LABEL description = “”</li></ul><h3 id="WORKDIR-工作目录-类似cd"><a href="#WORKDIR-工作目录-类似cd" class="headerlink" title="WORKDIR 工作目录 类似cd"></a>WORKDIR 工作目录 类似cd</h3><h3 id="ADD-amp-COPY"><a href="#ADD-amp-COPY" class="headerlink" title="ADD &amp; COPY"></a>ADD &amp; COPY</h3><ul><li>ADD text.txt / 将当前text文件添加到容器的根目录</li><li>ADD text.gz / 添加并解压缩</li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><ul><li>ENV JAVA_HOME /sur/local/jdk  设置容器环境变量</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><ul><li><p>shell 模式</p><ul><li>RUN yum install -y vim </li></ul></li><li><p>exec 模式(推荐)</p><ul><li>RUN [“yum”,”install”,”-y”,”vim”]</li></ul></li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><ul><li>只有最后一个有效</li><li>ENTRYPOINT [“ps”]</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul><li>类似ENTRYPOINT 但是有时候不一定会被执行 建议用ENTRYPOINT</li><li>CMD 当你的容器启动的时候最后附带参数的话就不会被执行 如果不附带参数的话就会执行当前CMD指令</li></ul><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><ul><li>对外暴露端口</li></ul><h3 id="docker-build-t-机构-镜像名-lt-版本-gt-Dockerfile目录docker-build-t-hki-com-myapp-1-0"><a href="#docker-build-t-机构-镜像名-lt-版本-gt-Dockerfile目录docker-build-t-hki-com-myapp-1-0" class="headerlink" title="docker build -t  机构/镜像名&lt;版本&gt; Dockerfile目录docker build -t hki.com/myapp:1.0 ."></a>docker build -t  机构/镜像名&lt;版本&gt; Dockerfile目录docker build -t hki.com/myapp:1.0 .</h3><h2 id="容器间通讯"><a href="#容器间通讯" class="headerlink" title="容器间通讯"></a>容器间通讯</h2><h3 id="单向通讯"><a href="#单向通讯" class="headerlink" title="单向通讯"></a>单向通讯</h3><ul><li>在启动的时候加上一个参数 –link [需要通讯的容器名称]</li></ul><h3 id="bridge网桥-双向通讯"><a href="#bridge网桥-双向通讯" class="headerlink" title="bridge网桥 双向通讯"></a>bridge网桥 双向通讯</h3><ul><li><p>启动的时候指定网桥来通讯</p><ul><li>–network my_net启动的时候多加一个参数来指定当前容器的 网桥是哪个</li></ul></li><li><p>创建一个网桥 用来通讯</p><ul><li><ol><li>创建一个网桥docker network create my_net</li></ol></li><li><ol start="2"><li>将容器containerr1连接到新建网络my_netdocker network connect my_net container1</li></ol></li><li><ol start="3"><li>将容器containerr2连接到新建网络my_netdocker network connect my_net container2</li></ol></li></ul></li></ul><h2 id="volume数据共享"><a href="#volume数据共享" class="headerlink" title="volume数据共享"></a>volume数据共享</h2><h3 id="数据共享分两种-1-在启动的时候加上-v参数来设置数据卷-2-先设置一个存档点-然后后续容器启动的时候直接指定这个存档点"><a href="#数据共享分两种-1-在启动的时候加上-v参数来设置数据卷-2-先设置一个存档点-然后后续容器启动的时候直接指定这个存档点" class="headerlink" title="数据共享分两种 1. 在启动的时候加上-v参数来设置数据卷 2.  先设置一个存档点,然后后续容器启动的时候直接指定这个存档点"></a>数据共享分两种 1. 在启动的时候加上-v参数来设置数据卷 2.  先设置一个存档点,然后后续容器启动的时候直接指定这个存档点</h3><h3 id="v-宿主机文件地址-容器的文件地址"><a href="#v-宿主机文件地址-容器的文件地址" class="headerlink" title="-v 宿主机文件地址:容器的文件地址"></a>-v 宿主机文件地址:容器的文件地址</h3><h3 id="创建共享容器来存放数据"><a href="#创建共享容器来存放数据" class="headerlink" title="创建共享容器来存放数据"></a>创建共享容器来存放数据</h3><ul><li>docker create –name my_volume -v /usr/test:/usr/local/tomcat/webapps/ tomcat</li><li>docker run -d -p  8000:8080 –volumes-from my_volume –name test tomcat</li></ul><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><h3 id="Windows-和-mac-不需要安装-linux需要"><a href="#Windows-和-mac-不需要安装-linux需要" class="headerlink" title="Windows 和 mac 不需要安装 linux需要"></a>Windows 和 mac 不需要安装 linux需要</h3><ul><li>sudo curl -L “<a href="https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$</a>(uname -s)-$(uname -m)” -o /usr/local/bin/docker-compose</li><li>sudo chmod +x /usr/local/bin/docker-compose</li></ul><h3 id="k8s-代替了"><a href="#k8s-代替了" class="headerlink" title="k8s 代替了"></a>k8s 代替了</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h1&gt;&lt;h2 id=&quot;Docker-安装&quot;&gt;&lt;a href=&quot;#Docker-安装&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>IDEA远程调试</title>
    <link href="http://yoursite.com/2020/02/25/ideaDebug/"/>
    <id>http://yoursite.com/2020/02/25/ideaDebug/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-04-07T07:54:08.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程debug是什么"><a href="#远程debug是什么" class="headerlink" title="远程debug是什么 ?"></a>远程debug是什么 ?</h2><p>远程debug 原理是利用服务器端口监听来触发本地开发工具IDEA的一种调试手段 </p><h2 id="什么情况下会用到"><a href="#什么情况下会用到" class="headerlink" title="什么情况下会用到 ?"></a>什么情况下会用到 ?</h2><p>一般我们本地调试的话会直接在代码中打断点然后debug模式运行代码就可以调试了.</p><p>但是我们在实际开发中会遇到一些比较复杂的问题我举几个例子</p><ol><li><p>涉及到调用生产环境会出现的网络问题.</p></li><li><p>本地运行没问题,只有在测试服务器或者生产环境会出现报错</p></li><li><p>因为开发系统和服务器系统不一致导致的问题</p></li></ol><p>等等类似这样的问题我们在本地就没办法调试,这时候就需要用到远程服务器调试了.</p><h2 id="如何使用远程服务器调试"><a href="#如何使用远程服务器调试" class="headerlink" title="如何使用远程服务器调试"></a>如何使用远程服务器调试</h2><p>远程调试主要有以下几个步骤</p><ul><li><p>在调试之前我们需要你本地的代码和远程的代码要保持一致</p></li><li><p>部署上去之后需要加上特定的参数来启动 </p></li><li><p>服务器启动之后在启动本地环境</p></li></ul><p>保持一致就不需要我们详细说了,部署最新版的就可以了.</p><p>接下来我们来加上启动参数</p><p>原来启动jar包需要的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure></p><p>如果是远程debug 则需要加上一些参数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=4001 xxx.jar</span><br></pre></td></tr></table></figure></p><p>这个参数在idea里可以直接获取到</p><p>接下来我们去找如何获取debug参数</p><blockquote><p>菜单 -&gt; Run -&gt; Edit Configurations…</p></blockquote><p><img src="/img/git1.png" alt="img"></p><blockquote><p>在debug Configurations的弹出框里添加一个remote</p></blockquote><p><img src="/img/git2.png" alt="img"></p><blockquote><p>之后会弹出一个如下图所示的界面 我们需要配置两个地方.图中的1是我们的服务器地址和端口,端口我们一般默认为4001.也可以自己配置.2是我们需要调试的项目.当这两个配置好后3的位置就会自动生成我们需要的启动参数</p></blockquote><p><img src="/img/a.png" alt="img"></p><blockquote><p>之后启动jar的时候添加上 服务器启动好后 在启动本地的remote</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>当发现启动报错 首先检查下你的命令 不要直接复制我的 看你自己生成的代码</li><li>保证端口没被占用</li><li>本地启动remote会发送请求连接服务器 如果本机无法连接服务器也不行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;远程debug是什么&quot;&gt;&lt;a href=&quot;#远程debug是什么&quot; class=&quot;headerlink&quot; title=&quot;远程debug是什么 ?&quot;&gt;&lt;/a&gt;远程debug是什么 ?&lt;/h2&gt;&lt;p&gt;远程debug 原理是利用服务器端口监听来触发本地开发工具IDEA的
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
      <category term="debug" scheme="http://yoursite.com/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://yoursite.com/2020/02/11/Iterator/"/>
    <id>http://yoursite.com/2020/02/11/Iterator/</id>
    <published>2020-02-10T16:00:00.000Z</published>
    <updated>2020-04-28T10:10:39.341Z</updated>
    
    <content type="html"><![CDATA[<p>查看java代码</p><p>Iterator 和 Collection 模式</p><p>其原理就是利用了接口实现规则来约束每个array或者link结构来实现他的遍历方式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看java代码&lt;/p&gt;
&lt;p&gt;Iterator 和 Collection 模式&lt;/p&gt;
&lt;p&gt;其原理就是利用了接口实现规则来约束每个array或者link结构来实现他的遍历方式&lt;/p&gt;

      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java/"/>
    
    
  </entry>
  
  <entry>
    <title>策略设计模式实际应用案例</title>
    <link href="http://yoursite.com/2020/01/18/strategy/"/>
    <id>http://yoursite.com/2020/01/18/strategy/</id>
    <published>2020-01-17T16:00:00.000Z</published>
    <updated>2020-04-24T03:15:28.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式中的策略模式"><a href="#设计模式中的策略模式" class="headerlink" title="设计模式中的策略模式"></a>设计模式中的策略模式</h1><p> 讲理论的话网上有很多现成的 以前也看了不少 这次特地在实际项目中抽取出来做成笔记</p><h2 id="先说说需求"><a href="#先说说需求" class="headerlink" title="先说说需求"></a>先说说需求</h2><p>根据不同的单据类型选出选出五个教授</p><p>其中单据类型有可转债和挂牌两大类 目前可转债和挂牌各有几种选择方式 下面案例我一样拿出一种来</p><p>之前的模式在有多种策略选择相似的情况下，使用 if…else 复杂和难以维护,代码阅读起来也比较困难</p><p>现在使用策略模式的步骤及简化结果 </p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个接口。</p><p>ProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProfessorStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><p>EIMProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EIMProfessorStrategy</span> <span class="keyword">implements</span> <span class="title">ProfessorStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略了我的筛选策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPDProfessorStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPDProfessorStrategy</span> <span class="keyword">implements</span> <span class="title">ProfessorStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//省略了我的筛选策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserStrategy</span> <span class="keyword">implements</span> <span class="title">ProfessorStrategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Professor&gt; <span class="title">five</span><span class="params">(Integer tableId)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//省略了我的筛选策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建具体的 <em>find</em> 方法, 你也可以创建一个有泛型的类来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回接口数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> professorStrategy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   List&lt;SysAttendsModel&gt; <span class="title">find</span><span class="params">(Integer tableId, ProfessorStrategy professorStrategy)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取对应的五个专家</span></span><br><span class="line">        List&lt;Professor&gt; five = professorStrategy.five(tableId);</span><br><span class="line"></span><br><span class="line">        List&lt;SysAttendsModel&gt; sysAttendsModels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sysAttendsModels;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>使用 <em>find</em> 来查看当它改变策略 <em>Strategy</em> 时的行为变化。</p><p>main</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 单据id</span></span><br><span class="line">      <span class="keyword">int</span> tableId = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂牌算法</span></span><br><span class="line">      List&lt;SysAttendsModel&gt; list = find(tableId, <span class="keyword">new</span> EIMProfessorStrategy());</span><br><span class="line">      <span class="comment">// 可转债算法</span></span><br><span class="line">  List&lt;SysAttendsModel&gt; list2 = find(tableId, <span class="keyword">new</span> IPDProfessorStrategy());</span><br><span class="line">      <span class="comment">// 会员算法</span></span><br><span class="line">  List&lt;SysAttendsModel&gt; list2 = find(tableId, <span class="keyword">new</span> UserStrategy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>讲讲上面的代码 </p><p>大概就和支付策略是一个逻辑</p><p><strong>支付前都需要找出二维码</strong></p><p><strong>支付后都需要查看是否到账</strong></p><p>中间走具体的 现金 or 微信支付 or 支付宝支付 我们不关心</p><p>不管后面有多少个支付手段我们就加上相对应的接口的实体类就行了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式中的策略模式&quot;&gt;&lt;a href=&quot;#设计模式中的策略模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式中的策略模式&quot;&gt;&lt;/a&gt;设计模式中的策略模式&lt;/h1&gt;&lt;p&gt; 讲理论的话网上有很多现成的 以前也看了不少 这次特地在实际项目中抽取出来做
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java/"/>
    
    
  </entry>
  
  <entry>
    <title>外部jar包打包方式</title>
    <link href="http://yoursite.com/2020/01/02/jarOpinize/"/>
    <id>http://yoursite.com/2020/01/02/jarOpinize/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-04-01T03:22:43.132Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>将原本 jar 包解压缩找到 BOOT-INF 下的 lib ,该目录下包含当前项目中用到的所有 jar包 ,复制出来放到jar包启动位置</p></li><li><p>在 pom 中 spring-boot-maven-plugin 打包插件设置打包时排除所有 jar 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;</span><br><span class="line">                &lt;!-- 排除所有Jar --&gt;</span><br><span class="line">                &lt;groupId&gt;nothing&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;nothing&lt;/artifactId&gt;</span><br><span class="line">            &lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li><li><p>这个时候需要在jar包启动参数上添加一个 -Dloader.path</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dloader.path=&quot;lib/&quot; -jar test.jar</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;将原本 jar 包解压缩找到 BOOT-INF 下的 lib ,该目录下包含当前项目中用到的所有 jar包 ,复制出来放到jar包启动位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 pom 中 spring-boot-maven-plugin 打包插件设置打包
      
    
    </summary>
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程与高并发(基础知识)</title>
    <link href="http://yoursite.com/2019/12/28/JUC02/"/>
    <id>http://yoursite.com/2019/12/28/JUC02/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2020-06-18T03:43:08.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><p>继承thread</p><ul><li>.strat()</li></ul></li><li><p>实现runable接口</p><ul><li>new Thread(new MyRunable()).start()</li></ul></li><li><p>匿名函数实现</p><ul><li>new Thread(()-&gt;{<pre><code>System.out.println(&quot;Hello Lambda!&quot;);</code></pre>  }).start();</li></ul></li><li><p>启动线程的三种方式 1：Thread 2: Runnable 3:Executors.newCachedThrad</p></li></ul><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>让出资源进入等待队列</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><ul><li>调用其他线程</li></ul><h3 id="线程状态迁移图"><a href="#线程状态迁移图" class="headerlink" title="线程状态迁移图"></a>线程状态迁移图</h3><p><img src="/static/线程状态迁移图.png" alt="线程状态迁移图"></p><h3 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait &amp; notify"></a>wait &amp; notify</h3><ul><li>notify 不释放锁 ,需要手动将当前线程wait, 让出锁  notify才能生效</li><li>notifyAll 是让所有线程都醒过来去争抢锁  </li></ul><h3 id="wait-和-await"><a href="#wait-和-await" class="headerlink" title="wait 和 await"></a>wait 和 await</h3><ul><li>await//此时当前线程释放lock锁，进入[等待状态]，等待其他线程执行 signal()时才有可能执行</li><li>signal() //此时当前线程释放obj锁，随机唤醒一个处于等待状态的线程，继续执行wait后面的程序。</li><li><ul><li>使用wait要用notify/notifyAll唤醒</li></ul></li><li><ul><li>使用await要用signal/signalAll唤醒</li></ul></li></ul><h3 id="synchronized-悲观锁"><a href="#synchronized-悲观锁" class="headerlink" title="synchronized 悲观锁"></a>synchronized 悲观锁</h3><ul><li>在对象头中有一个64位的对象头 markword其中有一个2位的标识符 00 - 11 共四个状态来标志这个锁对象</li><li>还有一位来标识是否是偏向锁</li><li>this 和 锁住某个对象意义是一样的</li><li>锁方法和锁住整块代码意义也是一样的</li><li>synchronized static 锁住的是 XX.class</li><li>sychronized 是可重入锁 , 同一个锁可以相互调用,也就是说如果锁的是同一个对象那么可以相互调用</li><li>sychronized 如果抛出异常会释放锁,这样的话会导致其他线程拿到锁之后执行业务逻辑,所以需要做try处理</li><li>synchronized 锁的对象不能是String常量 ,Integer ,Long </li><li><p>synchronized(this) 的锁升级过程 </p><ol><li>无锁状态<br>当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储偏向的线程ID，<br>以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，</li></ol><p>只需测试Mark Word里线程ID是否为当前线程。<br>因为没人和它竞争所以就没必要加锁</p><p>如果后来有线程进来对比发现线程ID和自己不一样 则发生竞争</p></li></ul><ol start="2"><li><p>偏向锁<br>如果判断发现ThreadID和自己不一样，则下一步需要判断偏向锁的标识。如果标识被设置为0（表示当前是无锁状态），则使用CAS(原子操作)竞争锁；</p><p>如果标识设置成1（表示当前是偏向锁状态），则尝试使用CAS将对象头的偏向锁指向当前线程，触发偏向锁的撤销。</p><p>偏向锁只有在竞争出现才会释放锁。当其他线程尝试竞争偏向锁时，程序到达全局安全点后（没有正在执行的代码），它会查看Java对象头中记录的线程是否存活，如果没有存活，那么锁对象被重置为无锁状态，</p><p>其它线程可以竞争将其设置为偏向锁；</p><p>如果存活，那么立刻查找该线程的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程，撤销偏向锁，升级为轻量级锁，</p><p>如果线程1不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p><p>3.轻量级锁</p><p>线程在执行同步块之前，</p><p>JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的MarkWord复制到锁记录中，即Displaced Mark Word。</p><p>然后线程会尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁。如果失败，表示其他线程在竞争锁，当前线程使用自旋来获取锁。</p><p>当自旋次数达到一定次数时，锁就会升级为重量级锁。</p><p>轻量级锁解锁时，会使用CAS操作将Displaced Mark Word替换回到对象头，如果成功，表示没有竞争发生。</p><p>如果失败，表示当前锁存在竞争，</p><p>锁已经被升级为重量级锁，则会释放锁并唤醒等待的线程。</p></li></ol><ol start="4"><li><p>当自旋超过10次之后 我们会进入os的等待队列 退出CPU的资源 然后向系统资源申请重量级锁</p><p>*注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。</p></li></ol><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li><p>1.线程间可见</p><ul><li>缓存一致性协议</li></ul></li><li><p>2.禁止jvm重排序</p><ul><li>线程在分配内存的时候 分三步 1.申请内存,2赋值,3引用指向, 当执行步骤为132的时候  会出现还没有赋值但是对象不为空的问题</li><li><p>JMM模式</p><ul><li>jmm模型中有8个指令完成数据的读写, 其中 load store 指令相互组成的4个内存屏障实现指令重排序</li></ul></li></ul></li><li><p>注意: 和synchronized 不同的是  volatile可以保证可见性但并不能保证原子性, synchronized可以都保证.</p></li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul><li>线程间各占一份 互不影响 </li><li>static ThreadLocal<person> tl = new ThreadLocal&lt;&gt;();</person></li><li>使用完成后必须remove调 不然会产生内存泄露</li></ul><h2 id="JUC同步锁"><a href="#JUC同步锁" class="headerlink" title="JUC同步锁"></a>JUC同步锁</h2><h3 id="CAS-Compare-And-Set-无锁优化-自旋锁-乐观锁"><a href="#CAS-Compare-And-Set-无锁优化-自旋锁-乐观锁" class="headerlink" title="CAS (Compare And Set ) 无锁优化| 自旋锁 | 乐观锁"></a>CAS (Compare And Set ) 无锁优化| 自旋锁 | 乐观锁</h3><ul><li>atomic包中的都是CAS操作</li><li>cas(V, Expected, NewValue) 有三个参数需要注意, v本次的对象, Expected 期望的值, NewValue 新的值 如果发现期望的值和现在的不一样那么就重新轮询一次获取新值</li><li><p>CAS自旋原理</p><ul><li>在解释一下<br>cas (操作对象， 期望值，更新值)</li></ul></li></ul><p>如果发现期望值不一样 则重新读取内存当中的值<br>if(当前值== 期望值){<br> 当前值 = 更新值<br>}else{<br> 重新获取值<br>}</p><ul><li>CPU源语支持 不存在指令重排序</li><li><p>ABA问题 </p><ul><li>解决方法就是加一个版本号 不停地增加 AtomicStampedReference</li></ul></li></ul><h3 id="increment-高并发递增值的方法"><a href="#increment-高并发递增值的方法" class="headerlink" title="increment 高并发递增值的方法"></a>increment 高并发递增值的方法</h3><ul><li>sync</li><li>atomicXXXX</li><li><p>LongAdder 高并发情况下效率最高</p><ul><li>采用跳表实现 分段锁</li></ul></li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul><li>类似snychronized<br>可以使用 .lock()  nulock() 来锁代码 </li><li>trylock(time)<br>尝试去拿锁， 如果规定时间内拿不到锁则继续执行，拿到了就加锁执行</li><li><p>lockInterruptibly<br>在一个线程等待锁的过程中可以被打断<br>如果一个线程开启锁的方式是lockInterruptibly()那么这个线程可以调用.interrupt()被打断</p></li><li><p>new ReentrantLock(true)<br>如果设置成公平锁，新的线程在竞争锁的时候回去检查队列里面是否有线程在等待 如果有则进入队列进行排队取锁</p></li></ul><h3 id="CountDownLatch-门闩"><a href="#CountDownLatch-门闩" class="headerlink" title="CountDownLatch 门闩"></a>CountDownLatch 门闩</h3><ul><li><p>使用环境是在于并发转换文件 当转换完成后需要继续执行业务<br>Thread[] threads = new Thread[100];<br> CountDownLatch latch = new CountDownLatch(threads.length);</p><p> 当执行完成某个后需要调用latch.countDown();<br> 当全部执行完成后 latch.await()后继续之后的逻辑</p></li></ul><h3 id="CyclicBarrier-线程栅栏"><a href="#CyclicBarrier-线程栅栏" class="headerlink" title="CyclicBarrier 线程栅栏"></a>CyclicBarrier 线程栅栏</h3><ul><li>当任务达到一定数量后再执行并发操作</li><li>积攒一定数量的任务当数量达到阈值后开始执行任务</li></ul><h3 id="Phaser-feize"><a href="#Phaser-feize" class="headerlink" title="Phaser  (feize)"></a>Phaser  (feize)</h3><ul><li>升级版的CyclicBarrier , 可以控制执行阶段 就是一个业务分为十个阶段,每个阶段都需要并发执行,只有当上个阶段的都执行完才能执行下一个阶段,</li><li>arriveAndAwaitAdvance()</li><li>arriveAndDeregister()</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><ul><li>共享锁 | 排他锁 | 读写锁</li><li>写锁 是排他锁 , 读锁是共享锁. </li><li>类似读写分离吧, 读操作可以并发,写操作在后续执行<br>static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();<br>  static Lock readLock = readWriteLock.readLock();<br>  static Lock writeLock = readWriteLock.writeLock();</li></ul><h3 id="Semaphoer"><a href="#Semaphoer" class="headerlink" title="Semaphoer"></a>Semaphoer</h3><ul><li>信号量 , 信号灯 0 - 1 </li><li>可以设置数量<br>Semaphore s = new Semaphore(2);</li><li>可以设置公平锁<br>Semaphore s = new Semaphore(2, true);</li><li>使用场景 限流 (车道-收费站)</li><li>semaphoer和lock的区别</li></ul><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><ul><li>线程间通讯</li><li>s = exchanger.exchange(s);</li><li>当线程运行到这段代码后会阻塞等待交换</li></ul><h3 id="Locksupport"><a href="#Locksupport" class="headerlink" title="Locksupport"></a>Locksupport</h3><ul><li>part 停车 或者 停止</li><li>unpart 开始 或者 启动</li></ul><h2 id="AQS-AbstractQueuedSynchronized"><a href="#AQS-AbstractQueuedSynchronized" class="headerlink" title="AQS (AbstractQueuedSynchronized)"></a>AQS (AbstractQueuedSynchronized)</h2><h3 id="ReentrantLock-–-sync-–-AQS"><a href="#ReentrantLock-–-sync-–-AQS" class="headerlink" title="ReentrantLock – sync – AQS"></a>ReentrantLock – sync – AQS</h3><h3 id="维护了一个双向链表队列-所有人去抢-status这个状态值-它用volatile-修饰-后续会用CAS操作更改值"><a href="#维护了一个双向链表队列-所有人去抢-status这个状态值-它用volatile-修饰-后续会用CAS操作更改值" class="headerlink" title="维护了一个双向链表队列- 所有人去抢 status这个状态值 它用volatile 修饰 后续会用CAS操作更改值"></a>维护了一个双向链表队列- 所有人去抢 status这个状态值 它用volatile 修饰 后续会用CAS操作更改值</h3><h3 id="锁住链表最后一个节点然后用CAS来操作"><a href="#锁住链表最后一个节点然后用CAS来操作" class="headerlink" title="锁住链表最后一个节点然后用CAS来操作"></a>锁住链表最后一个节点然后用CAS来操作</h3><h3 id="公平锁和非公平锁的区别是会去尝试通过CAS来操作如果不成功则进入队列-成功抢到锁则运行"><a href="#公平锁和非公平锁的区别是会去尝试通过CAS来操作如果不成功则进入队列-成功抢到锁则运行" class="headerlink" title="公平锁和非公平锁的区别是会去尝试通过CAS来操作如果不成功则进入队列 成功抢到锁则运行"></a>公平锁和非公平锁的区别是会去尝试通过CAS来操作如果不成功则进入队列 成功抢到锁则运行</h3><h2 id="强软弱虚-引用"><a href="#强软弱虚-引用" class="headerlink" title="强软弱虚 引用"></a>强软弱虚 引用</h2><h3 id="强-new-Object"><a href="#强-new-Object" class="headerlink" title="强  new Object()"></a>强  new Object()</h3><h3 id="软-SoftReference"><a href="#软-SoftReference" class="headerlink" title="软 SoftReference"></a>软 SoftReference</h3><ul><li>软引用在系统内存不够用的时候会回收</li><li>主要用来做缓存</li></ul><h3 id="弱waekReference"><a href="#弱waekReference" class="headerlink" title="弱waekReference"></a>弱waekReference</h3><ul><li>只要遭遇GC,就会回收<br>只要进行一次GC,就会回收</li><li>TheadLocal 使用了弱引用中的entry<br>entry继承自弱引用 , 如果当前线程存在则不会回收,如果当前线程消失可能会存在内存泄露,但是使用弱引用泄露的概率就很小了</li></ul><h3 id="虚phantomReterence"><a href="#虚phantomReterence" class="headerlink" title="虚phantomReterence"></a>虚phantomReterence</h3><ul><li>当你的框架或者是项目需要使用对外内存可能会用到这个引用</li><li><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，<br>也无法通过虚引用来获取一个对象的实例。<br>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。<br>虚引用和弱引用对关联对象的回收都不会产生影响，如果只有虚引用活着弱引用关联着对象，<br>那么这个对象就会被回收。它们的不同之处在于弱引用的get方法，虚引用的get方法始终返回null,<br>弱引用可以使用ReferenceQueue,虚引用必须配合ReferenceQueue使用。</p><p>jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，<br>而直接内存是在堆内存之外（其实是内存映射文件，自行去理解虚拟内存空间的相关概念），<br>所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，<br>会在堆内存分配一个对象保存这个堆外内存的引用，<br>这个对象被垃圾收集器管理，一旦这个对象被回收，<br>相应的用户线程会收到通知并对直接内存进行清理工作。</p><p>事实上，虚引用有一个很重要的用途就是用来做堆外内存的释放，<br>DirectByteBuffer就是通过虚引用来实现堆外内存的释放的。</p></li></ul><h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><h3 id="Collections-单个数据进出"><a href="#Collections-单个数据进出" class="headerlink" title="Collections 单个数据进出"></a>Collections 单个数据进出</h3><ul><li><p>List</p><ul><li>完全没锁 线程不安全, 需要手动加锁来处理任务</li><li><p>CopyOnWrite  写-时-复制</p><ul><li>也就是说 在写的时候复制一份对象  如果一个业务写的业务较少 读取的业务较多的时候 可以考虑用这个， 其本质上来讲就是一个ReadWriteLock</li><li><p>CopyOnWriteList</p><ul><li>/**<ul><li>Appends the specified element to the end of this list.<br>*</li><li>@param e element to be appended to this list</li><li>@return {@code true} (as specified by {@link Collection#add})<br>*/<br>public boolean add(E e) {<br>final ReentrantLock lock = this.lock;<br>lock.lock();<br>try {<br>Object[] elements = getArray();<br>int len = elements.length;<br>//重点是这一句话<br>Object[] newElements = Arrays.copyOf(elements, len + 1);<br>newElements[len] = e;<br>setArray(newElements);<br>return true;<br>} finally {<br>lock.unlock();<br>}<br>}</li></ul></li></ul></li><li><p>CopyOnWriteSet</p><ul><li>/**<ul><li>A version of addIfAbsent using the strong hint that given</li><li>recent snapshot does not contain e.<br>*/<br>private boolean addIfAbsent(E e, Object[] snapshot) {<br>final ReentrantLock lock = this.lock;<br>lock.lock();<br>try {<br>Object[] current = getArray();<br>int len = current.length;<br>if (snapshot != current) {<br>// Optimize for lost race to another addXXX operation<br>int common = Math.min(snapshot.length, len);<br>for (int i = 0; i &lt; common; i++)<pre><code>if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))    return false;</code></pre>if (indexOf(e, current, common, len) &gt;= 0)<pre><code>return false;</code></pre>}<br>Object[] newElements = Arrays.copyOf(current, len + 1);<br>newElements[len] = e;<br>setArray(newElements);<br>return true;<br>} finally {<br>lock.unlock();<br>}<br>}</li></ul></li></ul></li></ul></li><li><p>ArrayList</p><ul><li>未考虑多线程安全（未实现同步）</li></ul></li></ul></li><li><p>Set</p></li><li><p>vector</p><ul><li>Vector 线程安全 大部分关键方法都加了锁<br>但是可能出现锁与锁之间的共享问题 还是会出现线程不安全<br>就是两个方法虽然都加了锁但是 调用过程中会出现问题</li></ul></li></ul><ul><li><p>Queue 面对高并发准备</p><ul><li>(*高并发,多线程) 内部使用的是CAS来操作数据</li><li><p>ConcurrentLinkedQueue</p><ul><li>和Queue 的区别<br>offer -&gt; add  会有返回值<br>peek -&gt; get<br>poll -&gt; get remove</li></ul></li></ul></li></ul><pre><code>- ArrayBlockingQueue    - 数组阻塞队列  </code></pre><p>strs.offer(“aaa”, 1, TimeUnit.SECONDS);当内容满了之后就会等待阻塞 如果后面加上时间参数则会等待规定的时间后返回false 继续执行</p><pre><code>- LinkedBlockQueue    - 链表实现的阻塞队列 </code></pre><p>在ConcurrentLinkedQueue基础上添加了方法<br>    put 如果满了就等待<br>    take 如果空了就等待<br>    底层实现是利用了part 和unpart  类似之前面试题用到的 wait notify</p><pre><code>- DelayQueue    -     按照等待时间排序  也是阻塞队列的一种 BlockingQueue按照时间进行任务调度可以用这个本质上是PriorityQueue- SychronusQueue 同步    - 本质上和exchange线程差不多 线程size为0  所以不能add 不能往里面装东西 会阻塞等待消费者进行消费 puttake- TransferQueue    - 需要得到一个线程完成的标记或者是结果 可以用这个</code></pre><h3 id="Map-键值对K-V"><a href="#Map-键值对K-V" class="headerlink" title="Map 键值对K-V"></a>Map 键值对K-V</h3><ul><li><p>HashMap</p><ul><li><p>HashTable</p><ul><li>刚开始设计的时候只有这个,所有方法都加了锁的 线程是安全的 但是性能不是很高</li></ul></li><li><p>HashMap</p><ul><li>后来意识到之后就把锁都给取消了 , 所有方法都没有加锁  线程不安全  但是性能较高</li></ul></li><li><p>SynchronizedHashTable</p><ul><li>后来觉得锁的粒度放细一点,只在具体调用函数的代码块来锁 其实和HashTable本质上并没什么区别.</li></ul></li><li><p>ConcurrentHashMap  无序集合 高并发使用 </p><ul><li>采用了跳表的形式虽然写的时候不如 HashTable高 但是读起来性能高很多</li></ul></li><li><p>ConcurrentSkipListMap</p><ul><li>有序集合线程安全高并发使用  跳表实现原理 读取效率高</li></ul></li><li><p>LinkedHashMap</p><ul><li>里面维护了一个 LinkedKeySet</li><li>非线程安全 </li></ul></li></ul></li><li><p>TreeMap</p></li><li>WeakHashMap</li><li>identityHashMap</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="背过"><a href="#背过" class="headerlink" title="背过"></a>背过</h3><ul><li><p>面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，</p><ul><li><p>能够支持2个生产者线程以及10个消费者线程的阻塞调用</p><ul><li>注意点:  1.wait 和await的区别  2. lock 和unlock  要全部包住代码 </li></ul></li></ul></li><li><p>put get</p></li></ul><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li>Concurrent VS Parallel</li></ul><p>并发指的是任务同时到达某个接口</p><p>并行指的是多个CPU同时去处理某个事情</p><p>并行是并发的子集</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="ExecutorServices-gt-Executor-线程池"><a href="#ExecutorServices-gt-Executor-线程池" class="headerlink" title="ExecutorServices -&gt;  Executor   线程池"></a>ExecutorServices -&gt;  Executor   线程池</h3><ul><li><p>里面拥有很多操作线程的方法 </p><ul><li>awaitTermination</li><li>invokeAll</li><li>invokeAny</li><li>isShutdown</li><li>isTerminated</li><li>shutdown</li><li>shutdownNow</li><li>submit</li></ul></li><li><p>ExecutorServeices.submit 之后是异步执行的 不影响主线程</p></li></ul><h3 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h3><ul><li>Callable(String)  一个有返回值的线程</li><li><p>Future</p><ul><li>Future<string> submit = executorService.submit(() -&gt; {<pre><code>return &quot;&quot;;</code></pre>  });<br>submit.get();</string></li><li>线程池提交一个线程之后会返回这个线程的future 我们可以get它的返回值 提交是异步 get是阻塞的</li></ul></li><li><p>FutureTask</p><ul><li>用来存放Callable的返回值 –public FutureTask(Callable<v> callable)</v></li><li>如果想拿到的话 直接调用 FutureTask.get() 这个方法是阻塞的<br>相当于直接拿到这个线程的返回值 不需要生成线程池</li></ul></li><li><p>CompletableFuture</p><ul><li>组合各个线程的返回结果然后统一返回一个结果 </li></ul></li></ul><h3 id="两种线程池的自定义方式"><a href="#两种线程池的自定义方式" class="headerlink" title="两种线程池的自定义方式"></a>两种线程池的自定义方式</h3><ul><li><p>ThreadPoolExecutor</p><ul><li>ThreadPoolExecutor -&gt; AbstractExecutorService -&gt; ExecutorService -&gt;  Executor</li><li><p>ThreadPoolExecutor tpe = new ThreadPoolExecutor(2, 4,</p><pre><code>60, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;Runnable&gt;(4),Executors.defaultThreadFactory(),new ThreadPoolExecutor.CallerRunsPolicy());</code></pre></li><li><ol><li>corePoolSize 核心线程</li></ol></li><li><ol start="2"><li>maxPoolSize 可扩展的最大线程</li></ol></li><li><ol start="3"><li>keepAliveTime  如果一个线程空闲时间超过设定值则讲线程紫苑交给操作系统 核心线程永远活着 不过有个方法可以设置核心线程参不参与归还资源</li></ol></li><li><ol start="4"><li>TimeUnit 时间单位</li></ol></li><li><ol start="5"><li>queue  BolckingQueue线程队列<br>当核心线程满了之后 后续任务进入的等待队列</li></ol></li><li><ol start="6"><li>threadFactory DefaultThreadFactory 线程池的工厂类<br>实现 ThreadFactory 接口  里面有一个newThread 自己去实现具体的线程<br>public Thread newThread(Runnable r) {<br>Thread t = new Thread(group, r,<pre><code>namePrefix + threadNumber.getAndIncrement(),0);</code></pre>if (t.isDaemon())<br>//设置线程守护<br>t.setDaemon(false);<br>if (t.getPriority() != Thread.NORM_PRIORITY)<br>//设置优先级<br>t.setPriority(Thread.NORM_PRIORITY);<br>return t;<br>}</li></ol></li><li><ol start="7"><li>rejectedExecutionHandler 拒绝策略 </li></ol></li></ul></li></ul><p>线程池满了 并且 任务队列也满了 然后启动的非核心线程数也满了  会执行拒绝策略</p><pre><code>- JDK默认提供了四种拒绝策略 - Abort  抛异常- Discard 扔掉,不抛异常- DiscardOldest 扔掉排队时间最久的- CallerRuns 调用处理任务 哪个线程调用的哪个去处理 非异步处理- 我们也可以去自定义自己的拒绝策略</code></pre><p>实现 implements RejectedExecutionHandler接口<br>完成rejectedExecution方法</p><pre><code>- </code></pre><p>自定义拒绝策略</p><p>static class MyHandler implements RejectedExecutionHandler {</p><pre><code>@Overridepublic void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {    //log(&quot;r rejected&quot;)    //save r kafka mysql redis    //try 3 times    if(executor.getQueue().size() &lt; 10000) {        //try put again();    }}</code></pre><p>}</p><ul><li><p>ForkJoinPool</p><ul><li>ForkJoinPool -&gt; AbstractExecutorService -&gt; ExecutorService -&gt;  Executor</li><li>主要用来处理CPU密集型的任务 </li><li>每个线程有自己的任务队列</li><li>把大任务切分成一个一个的小任务来执行<br>然后再汇总结果</li><li>newWorkStealingPool<br>new ForkJoinPool<br>(Runtime.getRuntime().availableProcessors(),<br>ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>null, true);</li></ul></li></ul><h3 id="JDK默认的线程池的实现"><a href="#JDK默认的线程池的实现" class="headerlink" title="JDK默认的线程池的实现"></a>JDK默认的线程池的实现</h3><ul><li>Executors -线程池的工厂</li><li><ol><li><p>SingleThreadExecutor</p><ul><li>单例的线程池 里面只有一个线程<br>new FinalizableDelegatedExecutorService<br>(new ThreadPoolExecutor(1, 1,<pre><code>0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()));</code></pre></li></ul></li></ol></li><li><ol start="2"><li><p>newCachedThreadPool</p><ul><li>里面拥有核心线程池为0, 可以扩展最大的为int最大值<br>new ThreadPoolExecutor(0, Integer.MAX_VALUE,<pre><code>60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;());</code></pre></li></ul></li></ol></li><li><ol start="3"><li><p>newFixedThreadPool</p><ul><li>核心线程和扩展线程都是固定的值 可以通过计算 一般是CPU的核心线程数+1<br>new ThreadPoolExecutor(nThreads, nThreads,<pre><code>0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</code></pre></li></ul></li></ol></li></ul><ul><li><ol start="4"><li><p>newScheduledThreadPool</p><ul><li>定时任务线程池<br>可以用框架代替<br>Quartz cron </li></ul></li></ol></li></ul><p>super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,<br>      new DelayedWorkQueue());</p><ul><li>以上四个线程池底层都是ThreadPoolExecutor来实现的</li></ul><h2 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h2><h3 id="维护一个环形数组队列-首尾相连"><a href="#维护一个环形数组队列-首尾相连" class="headerlink" title="维护一个环形数组队列 首尾相连"></a>维护一个环形数组队列 首尾相连</h3><h3 id="目前性能最高的MQ"><a href="#目前性能最高的MQ" class="headerlink" title="目前性能最高的MQ"></a>目前性能最高的MQ</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUC&quot;&gt;&lt;a href=&quot;#JUC&quot; class=&quot;headerlink&quot; title=&quot;JUC&quot;&gt;&lt;/a&gt;JUC&lt;/h1&gt;&lt;h2 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知
      
    
    </summary>
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
      <category term="java" scheme="http://yoursite.com/categories/other/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/other/java/linux/"/>
    
      <category term="db" scheme="http://yoursite.com/categories/other/java/linux/db/"/>
    
      <category term="工具" scheme="http://yoursite.com/categories/other/java/linux/db/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>linux语法操作</title>
    <link href="http://yoursite.com/2019/12/28/shell/"/>
    <id>http://yoursite.com/2019/12/28/shell/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2020-04-08T06:44:19.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gt-File"><a href="#gt-File" class="headerlink" title="&gt;File"></a>&gt;File</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls       </span><br><span class="line">ll     </span><br><span class="line">ls -l  </span><br><span class="line">ll -rt</span><br></pre></td></tr></table></figure><h1 id="gt-shell-base"><a href="#gt-shell-base" class="headerlink" title="&gt;shell base"></a>&gt;shell base</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+w:删除光标前面的单词的字符</span><br><span class="line">Ctrl – a ：移到行首</span><br><span class="line">Ctrl – e ：移到行尾</span><br><span class="line">esc - f  : 前移一个词</span><br><span class="line">esc - b:  后移一个词</span><br></pre></td></tr></table></figure><p>创建文件用touch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：touch [1.txt]</span><br></pre></td></tr></table></figure></p><p>删除文件用rm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：rm -f [1.txt]</span><br></pre></td></tr></table></figure></p><p>创建目录用mkdir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：mkdir [xxx]     &#123; -p 参数来创建多级文件夹 &#125;</span><br></pre></td></tr></table></figure></p><p>删除空目录用rmdir<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：rmdir [xxx]（有东西的目录不能删）</span><br></pre></td></tr></table></figure></p><p>打开文件    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi  vim open cat more less</span><br></pre></td></tr></table></figure><p>批量创建    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p nginxdb/&#123;conf,conf.d,html,logs&#125;</span><br></pre></td></tr></table></figure><h1 id="gt-删除"><a href="#gt-删除" class="headerlink" title="&gt;删除"></a>&gt;删除</h1><p>删除装有东西的目录就用</p><figure class="highlight plain"><figcaption><span>-rfi 例如rm -rfi [XXX]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i是为了提醒 最好加上</span><br></pre></td></tr></table></figure><h1 id="gt-查看"><a href="#gt-查看" class="headerlink" title="&gt;查看"></a>&gt;查看</h1><p>文件末尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tail -20 [filename]</span><br><span class="line"># &gt;经常查看日志需要用到这个</span><br><span class="line">tail -f xxx.log -n100</span><br></pre></td></tr></table></figure></p><p>重新命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mv [old.text] [new.text]</span><br></pre></td></tr></table></figure></p><h1 id="gt-杀死进程"><a href="#gt-杀死进程" class="headerlink" title="&gt;杀死进程"></a>&gt;杀死进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kill [pid]</span><br></pre></td></tr></table></figure><p>pkill和阿里源码里学的<br>直接删除程序对应的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -f zwkj-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p><h1 id="gt-权限赋予"><a href="#gt-权限赋予" class="headerlink" title="&gt;权限赋予"></a>&gt;权限赋予</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chmod -R 777 [目录]</span><br><span class="line">建议了解下 linux权限的 0124 组成 这样就知道777怎么来的</span><br><span class="line">chown apple/staff xxx</span><br></pre></td></tr></table></figure><h1 id="gt-解压"><a href="#gt-解压" class="headerlink" title="&gt;解压"></a>&gt;解压</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zip all.zip *.jpg</span><br><span class="line"></span><br><span class="line">unzip all.zip</span><br></pre></td></tr></table></figure><h1 id="gt-Grep-管道查询"><a href="#gt-Grep-管道查询" class="headerlink" title="&gt;Grep 管道查询"></a>&gt;Grep 管道查询</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-A num：匹配到搜索到的行以及该行下面的num行</span><br><span class="line">  </span><br><span class="line">-B num：匹配到搜索到的行以及该行上面的num行</span><br><span class="line"></span><br><span class="line">-C num：匹配到搜索到的行以及上下各num行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep -E -B 1  &apos;use time:&apos; /data/home/zhxt/zhxt-test/logs/test.log</span><br><span class="line"></span><br><span class="line">ls | grep &apos;.docx&apos;</span><br><span class="line"></span><br><span class="line">ls | grep a*   (a 开头的)</span><br><span class="line"></span><br><span class="line">ls | grep &apos;a*&apos;  (包含a的)</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/kongzhongqijing/articles/4462793.html</span><br></pre></td></tr></table></figure><h1 id="gt-查看历史输入的命令"><a href="#gt-查看历史输入的命令" class="headerlink" title="&gt;查看历史输入的命令"></a>&gt;查看历史输入的命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br><span class="line"></span><br><span class="line">history | head -20</span><br></pre></td></tr></table></figure><h1 id="gt-查看执行文件的路径"><a href="#gt-查看执行文件的路径" class="headerlink" title="&gt;查看执行文件的路径"></a>&gt;查看执行文件的路径</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis mysql</span><br></pre></td></tr></table></figure><h1 id="gt-读取文件"><a href="#gt-读取文件" class="headerlink" title="&gt;读取文件"></a>&gt;读取文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat [filename]</span><br></pre></td></tr></table></figure><h1 id="gt-查询文件"><a href="#gt-查询文件" class="headerlink" title="&gt;查询文件"></a>&gt;查询文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find [path_root] -name &apos;*.doc*&apos;</span><br><span class="line">find / -name [xxx] -d</span><br><span class="line">locate</span><br></pre></td></tr></table></figure><h1 id="gt-查看某个端口是否被占用"><a href="#gt-查看某个端口是否被占用" class="headerlink" title="&gt;查看某个端口是否被占用"></a>&gt;查看某个端口是否被占用</h1><p>习惯用lsof  不想用netstat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装 </span><br><span class="line">yum install lsof -y</span><br><span class="line">lsof -i tcp:8080     (PS 必须用root权限)</span><br><span class="line"></span><br><span class="line">netstat -tunlp|grep [端口号]</span><br><span class="line">ps -axu|grep [java]  启动位置输出</span><br></pre></td></tr></table></figure></p><h1 id="gt-文件下载"><a href="#gt-文件下载" class="headerlink" title="&gt;文件下载"></a>&gt;文件下载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.zip --no-check-certificate</span><br></pre></td></tr></table></figure><h1 id="gt-scp下载"><a href="#gt-scp下载" class="headerlink" title="&gt;scp下载"></a>&gt;scp下载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2204 isinonet@106.37.74.50:/home/gzzx/excel/ProfessionReport18584791024.xlsx /Users/apple/Documents</span><br><span class="line">scp -P 2204 isinonet@106.37.74.50:/logs/test.log /Users/apple/Documents</span><br><span class="line">-r 文件夹   -p端口</span><br></pre></td></tr></table></figure><h1 id="gt-上传"><a href="#gt-上传" class="headerlink" title="&gt;上传"></a>&gt;上传</h1><p>服务器文件移动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /Users/apple/Documents/zwsj-category-0.0.1-SNAPSHOT.jar root@192.168.0.118:/home/zwsjObj</span><br><span class="line">Scp -r</span><br></pre></td></tr></table></figure></p><h1 id="gt-其他"><a href="#gt-其他" class="headerlink" title="&gt;其他"></a>&gt;其他</h1><p>查看磁盘容量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df -hl /xxx</span><br></pre></td></tr></table></figure></p><p>查看位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">which java</span><br></pre></td></tr></table></figure></p><p>rpm包安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rpm -ivh **.rpm</span><br></pre></td></tr></table></figure></p><p>后台运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Nohup 详细指南</span><br></pre></td></tr></table></figure></p><p>该命令用来列出目前与过去登录系统的用户相关信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Last</span><br></pre></td></tr></table></figure></p><p>Linux查看文件夹大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">du -sh</span><br></pre></td></tr></table></figure></p><p>查看当前文件夹大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">du -sh * | sort -n</span><br></pre></td></tr></table></figure></p><p>统计当前文件夹(目录)大小，并按文件大小排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">du -sk filename 查看指定文件大小</span><br></pre></td></tr></table></figure></p><p>遇到其他不会的命令实例可以按照这个命令来查看基础语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tldr  mkdir</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gt-File&quot;&gt;&lt;a href=&quot;#gt-File&quot; class=&quot;headerlink&quot; title=&quot;&amp;gt;File&quot;&gt;&lt;/a&gt;&amp;gt;File&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
</feed>
